(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{433:function(t,e,n){"use strict";n.r(e);var a=n(1),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"prototype原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prototype原型"}},[t._v("#")]),t._v(" prototype原型")]),t._v(" "),n("h2",{attrs:{id:"原型的基本知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型的基本知识"}},[t._v("#")]),t._v(" 原型的基本知识")]),t._v(" "),n("h3",{attrs:{id:"_1、创建构造函数-都有一个-属性：prototype-属性值-是对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、创建构造函数-都有一个-属性：prototype-属性值-是对象"}},[t._v("#")]),t._v(" 1、创建构造函数(都有一个 属性：prototype ; 属性值 : 是对象)")]),t._v(" "),n("pre",[n("code",[t._v("function Person (name,age) {\n    this.name = name;\n    this.age = age;\n}\nconsole.log(Person.prototype);   //原型对象   Object {constructor: function}\n")])]),t._v(" "),n("h3",{attrs:{id:"_2、可以给原型对象添加属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、可以给原型对象添加属性"}},[t._v("#")]),t._v(" 2、可以给原型对象添加属性")]),t._v(" "),n("pre",[n("code",[t._v('Person.prototype.name = "姬如千泷";\nPerson.prototype.sex = "女";\nPerson.prototype.say = function () {\n    console.log("我是原型对象中的say函数");\n}\n\nconsole.log(Person);\nconsole.log(Person.prototype);\n')])]),t._v(" "),n("h3",{attrs:{id:"_3、实例一个对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、实例一个对象"}},[t._v("#")]),t._v(" 3、实例一个对象")]),t._v(" "),n("pre",[n("code",[t._v('var person1 = new Person("荆天明",29);    //结果：荆天明   优先访问构造函数\nconsole.log(person1.name);\n')])]),t._v(" "),n("h3",{attrs:{id:"_4、原型对象中的属性，可以为-通过构造函数创建的-实例对象所使用-共用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4、原型对象中的属性，可以为-通过构造函数创建的-实例对象所使用-共用"}},[t._v("#")]),t._v(" 4、原型对象中的属性，可以为(通过构造函数创建的)实例对象所使用(共用);")]),t._v(" "),n("pre",[n("code",[t._v("实例对象能够访问原型对象中的属性，实例对象中并没有该属性，但可以使用。节省了空间。\n\nconsole.log(person1.sex);\nperson1.say();\n")])]),t._v(" "),n("h3",{attrs:{id:"_5、其他"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5、其他"}},[t._v("#")]),t._v(" 5、其他")]),t._v(" "),n("pre",[n("code",[t._v("约定俗成：构造函数设置静态属性，原型对象设置共用的动态属性。\n属性访问时优先级：先访问构造函数中(自身)拥有的 ，没有 后在原型对象中查找。\n")])]),t._v(" "),n("h2",{attrs:{id:"验证属性是构造函数-自身-的，还是原型对象的。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#验证属性是构造函数-自身-的，还是原型对象的。"}},[t._v("#")]),t._v(" 验证属性是构造函数(自身)的，还是原型对象的。")]),t._v(" "),n("h3",{attrs:{id:"_1、hasownproperty-检测属性是不是自身的：是-true-否-false"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、hasownproperty-检测属性是不是自身的：是-true-否-false"}},[t._v("#")]),t._v(" 1、hasOwnProperty()   检测属性是不是自身的：是, true; 否, false")]),t._v(" "),n("pre",[n("code",[t._v('console.log(per1.hasOwnProperty("name"));\n')])]),t._v(" "),n("h3",{attrs:{id:"_2、in-检测某个对象能否访问某个属性。不区分是否为自身的。true或false"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、in-检测某个对象能否访问某个属性。不区分是否为自身的。true或false"}},[t._v("#")]),t._v(" 2、in 检测某个对象能否访问某个属性。不区分是否为自身的。true或false")]),t._v(" "),n("pre",[n("code",[t._v('console.log("name" in person1);\n')])]),t._v(" "),n("p",[n("br"),n("br"),n("br")]),t._v(" "),n("h2",{attrs:{id:"三种继承方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三种继承方式"}},[t._v("#")]),t._v(" 三种继承方式")]),t._v(" "),n("ul",[n("li",[t._v("抽象  面向对象 三个特征: 继承   封装    多态(重载)")]),t._v(" "),n("li",[t._v("对象比函数的封装更高一级")])]),t._v(" "),n("h3",{attrs:{id:"_1、原型继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、原型继承"}},[t._v("#")]),t._v(" 1、原型继承")]),t._v(" "),n("p",[t._v("继承：原型继承(只能继承一次)")]),t._v(" "),n("p",[t._v("原型继承实现: 将上级构造函数的实例对象赋值给下级构造函数的原型。")]),t._v(" "),n("pre",[n("code",[t._v('**********************代码示例*********************************\nfunction Father(name){\n    this.name = name;\n}\nfunction Son(age){\n    this.age = age;\n}\n\nvar father = new Father("小头爸爸");\nvar son = new Son(10);\n\nSon.prototype = father;  //将父的实例对象赋值给子构造函数的原型    \nson.name = "大头儿子";   \n\nconsole.log(son);        //Son {age: 10, name: "大头儿子"}\n')])]),t._v(" "),n("p",[t._v("原型链( 指针 "),n("em",[t._v("proto")]),t._v(" )")]),t._v(" "),n("pre",[n("code",[t._v("var obj = new Object();    \nSon.prototype = father;\n\nson.__proto__     ==  Son.prototype;           //true\nfather.__proto__  ==  Father.prototype;     //true\nobj.__proto__     ==  Object.prototype;        //true\n")])]),t._v(" "),n("p",[t._v("原型链")]),t._v(" "),n("pre",[n("code",[t._v('son.__proto__     指向 Father {name: "小头爸爸"}\nfather.__proto__  指向 Object {constructor: function}\nobj.__proto__\n')])]),t._v(" "),n("h3",{attrs:{id:"_2、构造函数方式继承call-apply"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、构造函数方式继承call-apply"}},[t._v("#")]),t._v(" 2、构造函数方式继承call(),apply()")]),t._v(" "),n("p",[t._v("可以继承多个, 但不能访问原型对象中的属性")]),t._v(" "),n("pre",[n("code",[t._v('**************************** 代码示例 *****************************\nfunction GrandaFather(city,sex){\n    this.city = city;\n    this.sex = sex;\n}\n\nfunction Father(name){\n    this.name = name;\n    this.getName = function(){\n        console.log(this.name);\n    }\n}\n\nfunction Son(age,name,city,sex){\n    this.age = age;\n    Father.call(this,name);               // this 指向 创建出的实例对象\n    GrandaFather.apply(this,[city,sex]);\n\n    /*************这里有问题**************\n    Father.call(this,arguments[0]);\n    GrandaFather.apply(this,arguments);    */\n}\n\nvar son = new Son(18,"石兰","蜀国","女");\nconsole.log(son);\n\n//Son {age: 18, name: "石兰", city: "蜀国", sex: "女", getName: function}\n')])]),t._v(" "),n("h3",{attrs:{id:"_3、组合继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、组合继承"}},[t._v("#")]),t._v(" 3、组合继承")])])}),[],!1,null,null,null);e.default=r.exports}}]);