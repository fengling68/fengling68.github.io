(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{508:function(a,t,e){"use strict";e.r(t);var n=e(1),s=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"prototype原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prototype原型"}},[a._v("#")]),a._v(" prototype原型")]),a._v(" "),t("h2",{attrs:{id:"原型的基本知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型的基本知识"}},[a._v("#")]),a._v(" 原型的基本知识")]),a._v(" "),t("h3",{attrs:{id:"_1、创建构造函数-都有一个-属性-prototype-属性值-是对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、创建构造函数-都有一个-属性-prototype-属性值-是对象"}},[a._v("#")]),a._v(" 1、创建构造函数(都有一个 属性：prototype ; 属性值 : 是对象)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("function Person (name,age) {\n    this.name = name;\n    this.age = age;\n}\nconsole.log(Person.prototype);   //原型对象   Object {constructor: function}\n")])])]),t("h3",{attrs:{id:"_2、可以给原型对象添加属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、可以给原型对象添加属性"}},[a._v("#")]),a._v(" 2、可以给原型对象添加属性")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('Person.prototype.name = "姬如千泷";\nPerson.prototype.sex = "女";\nPerson.prototype.say = function () {\n    console.log("我是原型对象中的say函数");\n}\n\nconsole.log(Person);\nconsole.log(Person.prototype);\n')])])]),t("h3",{attrs:{id:"_3、实例一个对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、实例一个对象"}},[a._v("#")]),a._v(" 3、实例一个对象")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('var person1 = new Person("荆天明",29);    //结果：荆天明   优先访问构造函数\nconsole.log(person1.name);\n')])])]),t("h3",{attrs:{id:"_4、原型对象中的属性-可以为-通过构造函数创建的-实例对象所使用-共用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、原型对象中的属性-可以为-通过构造函数创建的-实例对象所使用-共用"}},[a._v("#")]),a._v(" 4、原型对象中的属性，可以为(通过构造函数创建的)实例对象所使用(共用);")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("实例对象能够访问原型对象中的属性，实例对象中并没有该属性，但可以使用。节省了空间。\n\nconsole.log(person1.sex);\nperson1.say();\n")])])]),t("h3",{attrs:{id:"_5、其他"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、其他"}},[a._v("#")]),a._v(" 5、其他")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("约定俗成：构造函数设置静态属性，原型对象设置共用的动态属性。\n属性访问时优先级：先访问构造函数中(自身)拥有的 ，没有 后在原型对象中查找。\n")])])]),t("h2",{attrs:{id:"验证属性是构造函数-自身-的-还是原型对象的。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验证属性是构造函数-自身-的-还是原型对象的。"}},[a._v("#")]),a._v(" 验证属性是构造函数(自身)的，还是原型对象的。")]),a._v(" "),t("h3",{attrs:{id:"_1、hasownproperty-检测属性是不是自身的-是-true-否-false"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、hasownproperty-检测属性是不是自身的-是-true-否-false"}},[a._v("#")]),a._v(" 1、hasOwnProperty()   检测属性是不是自身的：是, true; 否, false")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('console.log(per1.hasOwnProperty("name"));\n')])])]),t("h3",{attrs:{id:"_2、in-检测某个对象能否访问某个属性。不区分是否为自身的。true或false"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、in-检测某个对象能否访问某个属性。不区分是否为自身的。true或false"}},[a._v("#")]),a._v(" 2、in 检测某个对象能否访问某个属性。不区分是否为自身的。true或false")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('console.log("name" in person1);\n')])])]),t("p",[t("br"),t("br"),t("br")]),a._v(" "),t("h2",{attrs:{id:"三种继承方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三种继承方式"}},[a._v("#")]),a._v(" 三种继承方式")]),a._v(" "),t("ul",[t("li",[a._v("抽象  面向对象 三个特征: 继承   封装    多态(重载)")]),a._v(" "),t("li",[a._v("对象比函数的封装更高一级")])]),a._v(" "),t("h3",{attrs:{id:"_1、原型继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、原型继承"}},[a._v("#")]),a._v(" 1、原型继承")]),a._v(" "),t("p",[a._v("继承：原型继承(只能继承一次)")]),a._v(" "),t("p",[a._v("原型继承实现: 将上级构造函数的实例对象赋值给下级构造函数的原型。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('**********************代码示例*********************************\nfunction Father(name){\n    this.name = name;\n}\nfunction Son(age){\n    this.age = age;\n}\n\nvar father = new Father("小头爸爸");\nvar son = new Son(10);\n\nSon.prototype = father;  //将父的实例对象赋值给子构造函数的原型    \nson.name = "大头儿子";   \n\nconsole.log(son);        //Son {age: 10, name: "大头儿子"}\n')])])]),t("p",[a._v("原型链( 指针 "),t("em",[a._v("proto")]),a._v(" )")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("var obj = new Object();    \nSon.prototype = father;\n\nson.__proto__     ==  Son.prototype;           //true\nfather.__proto__  ==  Father.prototype;     //true\nobj.__proto__     ==  Object.prototype;        //true\n")])])]),t("p",[a._v("原型链")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('son.__proto__     指向 Father {name: "小头爸爸"}\nfather.__proto__  指向 Object {constructor: function}\nobj.__proto__\n')])])]),t("h3",{attrs:{id:"_2、构造函数方式继承call-apply"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、构造函数方式继承call-apply"}},[a._v("#")]),a._v(" 2、构造函数方式继承call(),apply()")]),a._v(" "),t("p",[a._v("可以继承多个, 但不能访问原型对象中的属性")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('**************************** 代码示例 *****************************\nfunction GrandaFather(city,sex){\n    this.city = city;\n    this.sex = sex;\n}\n\nfunction Father(name){\n    this.name = name;\n    this.getName = function(){\n        console.log(this.name);\n    }\n}\n\nfunction Son(age,name,city,sex){\n    this.age = age;\n    Father.call(this,name);               // this 指向 创建出的实例对象\n    GrandaFather.apply(this,[city,sex]);\n\n    /*************这里有问题**************\n    Father.call(this,arguments[0]);\n    GrandaFather.apply(this,arguments);    */\n}\n\nvar son = new Son(18,"石兰","蜀国","女");\nconsole.log(son);\n\n//Son {age: 18, name: "石兰", city: "蜀国", sex: "女", getName: function}\n')])])]),t("h3",{attrs:{id:"_3、组合继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、组合继承"}},[a._v("#")]),a._v(" 3、组合继承")])])}),[],!1,null,null,null);t.default=s.exports}}]);