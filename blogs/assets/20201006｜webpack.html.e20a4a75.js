import{_ as p,r,o as s,c as n,a as e,b as d,d as a,f as o}from"./app.40d45622.js";const t={},l=o('<h1 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> Webpack</h1><h2 id="配置字段" tabindex="-1"><a class="header-anchor" href="#配置字段" aria-hidden="true">#</a> 配置字段</h2><p><code>entry</code> 入口</p><p><code>output</code> 出口</p><p><code>Module</code> 模块</p><p><code>Chunk</code> 代码块</p><p><code>Loader</code> 模块转换器</p><p><code>Plugins</code> 扩展插件</p><h2 id="执行流程" tabindex="-1"><a class="header-anchor" href="#执行流程" aria-hidden="true">#</a> 执行流程</h2><p><code>初始化</code>：解析 <code>webpack</code> 配置参数，生产 <code>Compiler</code> 实例；</p><p><code>注册插件</code>：调用插件 <code>apply</code> 方法，给插件传入 <code>compiler</code> 实例的引用，插件通过 <code>compiler</code> 调用 <code>Webpack</code> 提供的 <code>API</code>，让插件可以监听后续的所有事件节点；</p><p><code>读取入口</code>：读取入口文件；</p><p><code>解析文件</code>：使用 <code>loader</code> 将文件解析成抽象语法树 <code>AST</code>；</p><p><code>生成依赖图谱</code>：找出每个文件的依赖项（遍历）；</p><p><code>输出</code>：根据转换好的代码，生成 <code>chunk</code>；</p><p><code>打包</code>：生成最后打包的文件；</p><h2 id="webpack-编译文件过大" tabindex="-1"><a class="header-anchor" href="#webpack-编译文件过大" aria-hidden="true">#</a> Webpack 编译文件过大</h2>',17),h={href:"https://juejin.im/post/5a9d17446fb9a028d374e733",target:"_blank",rel:"noopener noreferrer"},i=o('<p>1、区分开发环境和生产环境配置；</p><p>2、在 <code>prod</code> 环境下关闭 <code>source-map</code>；</p><p>3、使用 <code>extract-text-webpack-plugin</code> 插件单独打包 <code>css</code> 文件；</p><p>4、使用 <code>UglifyJSPlugin</code> 插件压缩 <code>js</code> 文件；</p><p>5、使用 <code>CommonsChunkPlugin</code> 插件提取公共依赖；</p><p>6、使用 <code>compression-webpack-plugin</code> 插件开启 <code>gzip</code> 压缩；</p><p>7、使用 <code>html-webpack-plugin</code> 插件开启html压缩，自动添加上面生成的静态资源；</p><p>8、使用 <code>webpack-bundle-analyzer</code> 插件分析并优化依赖包；</p><h2 id="webpack-编译速度慢" tabindex="-1"><a class="header-anchor" href="#webpack-编译速度慢" aria-hidden="true">#</a> Webpack 编译速度慢</h2>',9),b={href:"https://www.cnblogs.com/yangsg/p/10601604.html",target:"_blank",rel:"noopener noreferrer"},k=o('<p>1、使用 <code>webpack 4</code> 进行打包；</p><p>2、配置 <code>externals</code> 来将依赖的库指向全局变量，使 <code>webpack</code> 不再打包这个库，而是全局引入插件后使用；</p><p>3、使用 <code>CommonsChunkPlugin</code> 插件将共有的模块打包成一个文件；</p><h2 id="webpack-loader" tabindex="-1"><a class="header-anchor" href="#webpack-loader" aria-hidden="true">#</a> Webpack loader</h2>',4),_={href:"https://www.webpackjs.com/api/loaders/",target:"_blank",rel:"noopener noreferrer"},u=o("<p><code>webpack</code> 用来预处理模块的，在一个模块被引入之前，会预先使用 <code>loader</code> 处理模块的内容。</p><p>1、<code>file-loader</code>：打包图片、字体；</p><p>2、<code>url-loader</code>：打包图片，会将 base64 打包到 js 文件中；</p><p>3、<code>css-loader</code>：理清多个css文件之间的引用关系，最后合并为一个；</p><p>4、<code>style-loader</code>：将css样式挂载到head的style标签中；</p><p>5、<code>sass-loader</code>：将scss文件编译为css；</p><p>6、<code>less-loader</code>：解析 less 文件样式；</p><p>7、<code>postcss-loader</code>：为样式加上浏览器前缀；</p><p>8、<code>babel-loader</code>：让下一代的 js 文件转换成现代浏览器能够支持的 js 文件；</p>",9);function w(f,m){const c=r("ExternalLinkIcon");return s(),n("div",null,[l,e("p",null,[e("a",h,[d("webpack打包之后的文件过大的解决方法"),a(c)])]),i,e("p",null,[e("a",b,[d("webpack4提升180%编译速度"),a(c)])]),k,e("p",null,[e("a",_,[d("loader API"),a(c)])]),u])}const x=p(t,[["render",w],["__file","20201006｜webpack.html.vue"]]);export{x as default};
