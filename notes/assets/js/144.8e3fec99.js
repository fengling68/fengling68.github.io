(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{445:function(e,a,r){"use strict";r.r(a);var n=r(1),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"认识三大框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#认识三大框架"}},[e._v("#")]),e._v(" 认识三大框架")]),e._v(" "),r("h2",{attrs:{id:"框架和库的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#框架和库的区别"}},[e._v("#")]),e._v(" 框架和库的区别")]),e._v(" "),r("pre",[r("code",[e._v("库：\n    jQuery\n    Swipper\n    iScroll\n    其他依赖jQuery的插件\n\n框架：有限制\n    Bootstrap  限制：12栅格\n    Vue        限制：DOM操作无用\n    Augular    限制：使用什么, 首先引入依赖; $开头都是angular系统对象\n    react\n")])]),e._v(" "),r("h2",{attrs:{id:"一、vue框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、vue框架"}},[e._v("#")]),e._v(" 一、Vue框架")]),e._v(" "),r("h3",{attrs:{id:"_1、vue是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、vue是什么"}},[e._v("#")]),e._v(" 1、Vue是什么")]),e._v(" "),r("pre",[r("code",[e._v("Vue是前端的JS框架, 提供很多功能, 很方便实现前端页面\n\n特点: 数据驱动界面的框架\n    js 开发:  html,js添加, 数据改变, 显示新的数据\n    vue开发:  MVVM, 设计好界面, 做好界面和数据的关联, 改了数据之后, 界面自动改变\n")])]),e._v(" "),r("h3",{attrs:{id:"_2、作者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、作者"}},[e._v("#")]),e._v(" 2、作者")]),e._v(" "),r("pre",[r("code",[e._v("Vue作者:尤雨溪\n")])]),e._v(" "),r("h3",{attrs:{id:"_3、特点-——-数据驱动界面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、特点-——-数据驱动界面"}},[e._v("#")]),e._v(" 3、特点 —— 数据驱动界面")]),e._v(" "),r("pre",[r("code",[e._v("例：有个数组 , 放在ul的li标签内显示 , 删除或修改数据\n\n原来：JSfor循环拿出数据 , 拼接li , 插入到 ul 中 ; 删除数据要删除对应的li标签\n\nVue:先有数据 , 实现界面 , 绑定数据和界面\n    数据改变 , 界面自动改变\n")])]),e._v(" "),r("h2",{attrs:{id:"二、angular-框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、angular-框架"}},[e._v("#")]),e._v(" 二、Angular 框架")]),e._v(" "),r("h3",{attrs:{id:"_1、angular-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、angular-是什么"}},[e._v("#")]),e._v(" 1、Angular 是什么?")]),e._v(" "),r("pre",[r("code",[e._v("Angular是基于数据绑定和mvc设计模式的前端框架，是一个用于设计动态web应用的结构框架。不仅仅是js框架，核心其实是对HTML标签的增强。\n\n核心1: 数据绑定(数据驱动)\n    限制: 也是数据驱动, 先写好view, 设置绑定, 根据数据驱动界面\n\n核心2: mvc设计结构\n    model   界面的数据模型\n    view    界面的显示\n    controller    界面的控制器\n    \n    angular强制界面分为三个部分\n    \n    \n好处:\n    (1)数据绑定某种意义中简化界面, 修改了数据, 界面自动变化\n    (2)程序的结构十分清晰,  angular强制界面分为三个部分, \n            有利于大规模项目的实现\n")])]),e._v(" "),r("h3",{attrs:{id:"_2、作者-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、作者-2"}},[e._v("#")]),e._v(" 2、作者")]),e._v(" "),r("pre",[r("code",[e._v("angular现在是google的框架, google有团队维护这个框架\n")])]),e._v(" "),r("h3",{attrs:{id:"_3、angular版本问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、angular版本问题"}},[e._v("#")]),e._v(" 3、angular版本问题")]),e._v(" "),r("pre",[r("code",[e._v("angular1(学习, JS语言, 不需要脚手架, 引入一个库能用了)\nangular2(学习, Typescript, 需要脚手架[网络,命令行,node,webpack,npm,] )\nangular4(学习, Typescript, 需要脚手架[网络,命令行,node,webpack,npm,] )\n")])]),e._v(" "),r("h3",{attrs:{id:"_4、angular特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、angular特性"}},[e._v("#")]),e._v(" 4、angular特性")]),e._v(" "),r("pre",[r("code",[e._v("(1)双向的数据绑定        (数据绑定是DOM变化，不是字符串的连接或者innerHTML变化。)\n(2)模板module\n(3)MVC                 (ViewModel , controller , view)\n    viewmodel是一个用来提供特别数据和方法从而维护指定view的对象。是$scope的对象，只存在于AnguarJS的应用中。\n    controller负责设置初始状态和参数化$scope方法用以控制行为。controller并不保存状态也不和远程服务互动。\n    view是AngularJS解析后渲染和绑定后生成的HTML 。这个部分帮助你创建web应用的架构。\n\n    $scope只是一个简单的js对象，这个对象使用简单的API来侦测和广播状态变化。\n    $scope拥有一个针对数据的参考，controller定义行为，view处理布局和互动。\n\n(4)服务和依赖注入      (对外提供某个特定的功能)\n(5)指令                (作为标签、属性、注释和类名使用。)\n")])]),e._v(" "),r("h3",{attrs:{id:"_5、-scope-和-module-和-ng-controller"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、-scope-和-module-和-ng-controller"}},[e._v("#")]),e._v(" 5、$scope 和 module 和 ng-controller")]),e._v(" "),r("pre",[r("code",[e._v("$scope\n    $scope是一个把view（一个DOM元素）连结到controller上的对象。\n    在我们的MVC结构里，这个 $scope 将成为model，它提供一个绑定到DOM元素（及其子元素）上的excecution context。\n    $scope 实际上就是一个JavaScript对象，controller和view都可以访问它，所以我们可以利用它在两者间传递信息。\n    在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。\n    每一个Angular应用都会有一个 $rootScope。这个 $rootScope 是最顶级的scope，它对应着含有 ng-app 指令属性的那个DOM元素。\n\nmodule\n    模板,就是我们页面上的HTML代码，不需要附加任何额外的东西。在模板中可以使用各种指令来增强它的功能，这些指令可以让你把模板和数据巧妙的绑定起来。\n    在<html>标签上多了一个属性ng-app=”MyApp”，它的作用就是用来指定ng的作用域是在<html>标签以内部分。\n    在js中，我们调用angular对象的module方法来声明一个模块，模块的名字和ng-app的值对应。这样声明一下就可以让ng运行起来了。\n\nng-controller\n    要明确创建一个$scope 对象，我们就要给DOM元素安上一个controller对象，使用的是ng-controller 指令属性。\n    ng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。\n    所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父 scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。即如果controller是多层嵌套的，就会从最里面一直往外找。\n")])]),e._v(" "),r("h2",{attrs:{id:"三、react框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、react框架"}},[e._v("#")]),e._v(" 三、React框架")]),e._v(" "),r("p",[e._v("虚拟DOM机制 (可以写原生应用)")]),e._v(" "),r("h3",{attrs:{id:"_1、什么是react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是react"}},[e._v("#")]),e._v(" 1、什么是React")]),e._v(" "),r("pre",[r("code",[e._v("React是一个用于构建用户界面的Javascript框架, React主要侧重于构建View视图，采用虚拟DOM机制。\n")])]),e._v(" "),r("h3",{attrs:{id:"_2、作者-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、作者-3"}},[e._v("#")]),e._v(" 2、作者")]),e._v(" "),r("pre",[r("code",[e._v("起源于facebook, 2013年开源\n")])]),e._v(" "),r("h3",{attrs:{id:"_3、特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、特点"}},[e._v("#")]),e._v(" 3、特点")]),e._v(" "),r("pre",[r("code",[e._v("(1)侧重于view, 不是全的框架, 项目需要配合其他库去使用\n(2)开发采用虚拟dom, vitual dom机制,通过算法优化 界面改变刷新,速度在各个框架中最快\n(3)采用jsx语法, jsx语法是js的扩展\n(4)组件式开发设计思想, 都是组件套组件。写一个项目, 搭积木。\n")])]),e._v(" "),r("h3",{attrs:{id:"_4、设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、设计模式"}},[e._v("#")]),e._v(" 4、设计模式")]),e._v(" "),r("pre",[r("code",[e._v("React   ( View层的技术，其他没有限定 )\nVue     ( Model View ViewModel )\nAngular ( Model View Controller )\n")])])])}),[],!1,null,null,null);a.default=t.exports}}]);