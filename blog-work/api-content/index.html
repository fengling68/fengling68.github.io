{"posts":[{"title":"Gridea配置相关教程","content":"Gridea 博客加上Valine评论系统：https://kveln.cn/post/qE678A4ce/ Gridea 博客增加搜索功能：https://tangkaichuan.cn/search-for-gridea-blog/ 使用 instant.page预加速Gridea博客：https://kveln.cn/post/BMDxD6cBT/ ","link":"https://h8396x.coding-pages.com/post/_GhhwdueG/"},{"title":"自定义和压缩字体","content":"自定义字体 @font-face { font-family: &quot;self-font&quot;; src: url(&quot;fonts/xxx.ttf&quot;) format('truetype'); } .word { font-family: &quot;self-font&quot;; font-size:50px; } 不同格式的字体文件 format() 不一样 src: url('YourWebFontName.eot?') format('eot'); src: url('YourWebFontName.woff') format('woff'); src: url('YourWebFontName.ttf') format('truetype'); src: url('YourWebFontName.svg') format('svg'); 字体压缩工具字蛛 字蛛网：http://font-spider.org/ 1、安装字蛛 # 安装命令 npm install font-spider -g 2、添加文件和字体 &lt;!-- index.html --&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;字体压缩demo&lt;/title&gt; &lt;style&gt; /* 自定义字体 */ @font-face { font-family: &quot;self-font&quot;; src: url(&quot;./font/字体管家胖丫儿体.ttf&quot;) format('truetype'); } /* 使用自定义字体 */ .words { font-family: &quot;self-font&quot;; font-size:50px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 添加需要保留的字 --&gt; &lt;div class=&quot;words&quot;&gt; 0123456789 一二三四五六七八九十 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3、压缩字体 # 压缩命令 font-spider ./index.html 4、目录结构 . ├── [ 128] font │ ├── [ 96] .font-spider │ │ └── [4.8M] font.ttf // 字蛛压缩后保存的原字体 │ └── [8.2K] font.ttf // 字蛛压缩后的新字体 └── [ 547] index.html 字体预览 ttf字体解析预览：http://blog.luckly-mjw.cn/tool-show/iconfont-preview/index.html 使用上面的网址可以看到压缩后的字体有： ","link":"https://h8396x.coding-pages.com/post/BIwO6ZEuT/"},{"title":"Gridea添加看板猫","content":"1、下载相应模型 在github上搜索live2d或者live2dmodel可以找到很多相关的优质项目，例如： Live2D live2d-widget-models 2、放置目录 本人将所有live2d都放在了assets目录下，如果你有更好的目录或者引入方式(比如npm install方式)，可以按照你的想法来哦～ 3、配置个性化提示语 修改message.json内容可以定义自己喜欢的名言语录哦～ { &quot;mouseover&quot;: [ { &quot;selector&quot;: &quot;.inline a.menu&quot;, &quot;text&quot;: [ &quot;hi，看官，要去看看吗，很精彩哦！&quot; ] }, { &quot;selector&quot;: &quot;#searchbox&quot;, &quot;text&quot;: [ &quot;在找什么东西呢，需要帮忙吗？&quot; ] } ], &quot;click&quot;: [ { &quot;selector&quot;: &quot;#landlord #live2d&quot;, &quot;text&quot;: [ &quot;是不是累了！快放松一下吧~~&quot;, &quot;我是不是很萌很可爱！&quot;, &quot;我们一起学猫叫，一起喵喵喵喵喵！&quot;, &quot;在你面前撒个娇，哎呦喵喵喵喵喵！&quot;, &quot;天青色等烟雨，而我在等你&quot;, &quot;哈哈哈哈哈哈哈哈哈&quot; ] } ] } 4、添加cat.ejs文件 &lt;!-- 看板白猫 --&gt; &lt;div id=&quot;landlord&quot;&gt; &lt;div class=&quot;message&quot; style=&quot;opacity:0&quot;&gt;&lt;/div&gt; &lt;canvas id=&quot;live2d&quot; width=&quot;280&quot; height=&quot;250&quot; class=&quot;live2d&quot;&gt;&lt;/canvas&gt; &lt;div class=&quot;hide-button&quot;&gt;隐藏&lt;/div&gt; &lt;/div&gt; &lt;!-- 看板白猫 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function loadScript(url, callback) { let script = document.createElement('script'); if (script.readyState) { // IE script.onreadystatechange = function () { if (script.readyState === 'loaded' || script.readyState === 'complete') { script.onreadystatechange = null; callback(); } } } else { // 其他浏览器 script.onload = function () { callback(); } } script.src = url; document.body.appendChild(script); } var ua = window.navigator.userAgent.toLowerCase(); var inWindow = !(/android|ipad|iphone|iPod/i.test(ua)); // 电脑端加载并显示看板猫，移动端很容易崩溃，所以并不建议在移动端展示哦～ if (inWindow) { var message_Path = 'https://....../media/live2d/'; var link1 = &quot;https://....../media/live2d/live2d.js&quot;; var link2 = &quot;https://....../media/live2d/message.js&quot;; loadScript(link1, function(){ loadScript(link2, function(){ // 白天展示白猫，黑夜展示黑猫，嘿嘿嘿～ var hour = (new Date()).getHours(); if (hour &gt; 6 &amp;&amp; hour &lt; 18) { loadlive2d(&quot;live2d&quot;, &quot;https://....../media/live2d/modelWhiteCat/tororo.model.json&quot;); } else { loadlive2d(&quot;live2d&quot;, &quot;https://....../media/live2d/modelBlackCat/hijiki.model.json&quot;); } }) }) } &lt;/script&gt; 5、引入看板猫 先将1、2、3步骤的修改部署至静态pages后； 接下来只需要在相应的页面引入cat.ejs就可以看到看板猫哦～ &lt;%- include('./_blocks/cat') %&gt; 6、效果图 ","link":"https://h8396x.coding-pages.com/post/xiGntqoVl/"},{"title":"Gridea添加gittalk评论配置","content":"一、创建OAuth Apps 创建链接：https://github.com/settings/applications/new 二、进入OAuth Apps详情，复制Client ID和Client Secret 三、Gridea添加gittalk配置 四、添加gittalk时问题及解决 1、Not Found 解决方案： 此问题多为OAuth Apps的Homepage URL、Authorization callback URL和Gridea中的配置错误导致，细心检查配置正确链接即可。 2、需初始化创建问题 解决方案： 1、开启GitHub仓库的Issues功能； 2、检查gittalk的id配置，长度是否超出限制； 五、Gittalk git地址&amp;文档：https://github.com/gitalk/gitalk/blob/master/readme-cn.md ","link":"https://h8396x.coding-pages.com/post/NJ-nLz7Sq/"},{"title":"electron-vue入门","content":"一、安装和启动 # 安装 vue-cli和脚手架样板代码 npm install -g vue-cli vue init simulatedgreg/electron-vue electronDemo # 安装依赖并运行你的程序 cd electronDemo npm install # 或者yarn npm run dev # 或者yarn run dev 二、打包（打包文件在build目录下） (1)使用electron-packager打包 # 针对所有或各平台打包 all ：npm run build macOS：npm run build:darwin mas ：npm run build:mas linux：npm run build:linux win32：npm run build:win32 web ：npm run build:web # 清除build目录下的打包文件 npm run build:clean (2)使用electron-builder打包 # 针对所有平台打包 npm run build # 生成简单的可执行文件 npm run build:dir # 生成可在浏览器运行的web应用 npm run build:web # 清除build目录下的打包文件 npm run build:clean 三、开发出现的问题 0、其他 (1)vue中使用&lt;webview&gt;标签打开一个url (2)建立主窗口：new BrowserWindow (3)在父主(父)窗口中创建子窗口：new BrowserView 1、在electron-vue中使用vuex，无法改变vuex状态 解决：在src/main/index.js主进程加上：import '../renderer/store'; 2、设置跨域 解决：在在src/main/index.js主进程new BrowserWindow内加上 webPreferences: { webSecurity: false, }, 3、添加通知 new Notification('添加成功'); 四、main进程和web进程的通信 /********** main ***********/ import { ipcMain } from 'electron' // 接收web发送的信息 ipcMain.on('web-send-message-to-main', (event, arg) =&gt; { console.log(`mian-accept: ${arg}`); // 向web发送信息 event.sender.send('main-send-message-to-web', 'main-to-web'); }); /********** web（.vue） ***********/ // import electron from 'electron'; // const { ipcRenderer } = electron; import { ipcRenderer } from 'electron'; // 接收main发送的信息 ipcRenderer.on('main-send-message-to-web', (event, arg) =&gt; { console.log(`web-accept: ${arg}`); }); // 向main发送信息 ipcRenderer.send('web-send-message-to-main', 'web-to-main'); // ipcRenderer.sendSync('web-send-message-to-main', 'web-to-main'); 五️、dialog对话框 // 在main中引入 import { dialog } from 'electron'; // 在vue组件中引入 // eslint配置 'import/no-extraneous-dependencies': 0, import electron from 'electron'; const { dialog } = electron.remote; // 打开对话框 dialog.showOpenDialog([{ title: '打开文件', message: '打卡打开打开', filters: [ { name: 'Images', extensions: ['jpg', 'png', 'gif'] }, { name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] }, { name: 'Custom File Type', extensions: ['as'] }, { name: 'All Files', extensions: ['*'] }, ], properties: { openFile: true, // ... }, }], (filePaths) =&gt; { console.log(filePaths); }); // 保存对话框 dialog.showSaveDialog((filename) =&gt; { console.log(filename); }); // 消息对话框 dialog.showMessageBox({ title: '信息对话框', message: '北方有佳人，绝世而独立。', detail: '这是一首著名的诗', type: 'info', // &quot;none&quot;, &quot;info&quot;, &quot;error&quot;, &quot;question&quot;, &quot;warning&quot; buttons: ['确认', '取消'], }, (resIndex) =&gt; { if (resIndex === 0) { console.log('点击了确认'); } else if (resIndex === 1) { console.log('点击了取消'); } }); // 错误弹窗 dialog.showErrorBox('错误弹窗', '这是一个错误弹窗'); ","link":"https://h8396x.coding-pages.com/post/4lZXt9fE9/"},{"title":"vuedraggable拖拽库","content":"一、安装 npm i -S vuedraggable 二、引入 import draggable from 'vuedraggable'; components: { draggable, }, 三、使用(操作数据) data() { return { myArray1: [1, 2, 3, 4, 5], myArray2: [6, 7, 8, 9, 10], }; }, &lt;div&gt; &lt;draggable group=&quot;people&quot; v-model=&quot;myArray1&quot; @choose='onChoose1' @clone='onClone1' @start='onStart1' @update='onUpdate1' @change=&quot;onChange1&quot; @add='onAdd1' @remove='onRemove1' @sort='onSort1' @end='onEnd1' @filter='onFilter1' &gt; &lt;p v-for=&quot;(item, i) in myArray1&quot; v-bind:key=&quot;i&quot; &gt;draggableOne---{{item}}&lt;/p&gt; &lt;button slot=&quot;header&quot; @click=&quot;addEle&quot;&gt;draggableOne---Add&lt;/button&gt; &lt;button slot=&quot;footer&quot; @click=&quot;removeEle&quot;&gt;draggableOne---Remove&lt;/button&gt; &lt;/draggable&gt; &lt;draggable group=&quot;people&quot; v-model=&quot;myArray2&quot; @choose='onChoose2' @clone='onClone2' @start='onStart2' @update='onUpdate2' @change=&quot;onChange2&quot; @add='onAdd2' @remove='onRemove2' @sort='onSort2' @end='onEnd2' @filter='onFilter2' &gt; &lt;p v-for=&quot;(item, i) in myArray2&quot; v-bind:key=&quot;i&quot; &gt;draggableTwo---{{item}}&lt;/p&gt; &lt;/draggable&gt; &lt;/div&gt; methods: { onChoose1() { console.log('onChoose1'); }, onClone1() { console.log('onClone1'); }, onStart1() { console.log('onStart1'); }, onUpdate1() { console.log('onUpdate1'); }, onChange1() { console.log('onChange1'); }, onSort1() { console.log('onSort1'); }, onAdd1() { console.log('onAdd1'); }, onRemove1() { console.log('onRemove1'); }, onEnd1() { console.log('onEnd1'); console.log(this.myArray1); }, onFilter1() { console.log('onFilter1'); }, onChoose2() { console.log('onChoose2'); }, onClone2() { console.log('onClone2'); }, onStart2() { console.log('onStart2'); }, onUpdate2() { console.log('onUpdate2'); }, onChange2() { console.log('onChange2'); }, onAdd2() { console.log('onAdd2'); }, onRemove2() { console.log('onRemove2'); }, onSort2() { console.log('onSort2'); }, onEnd2() { console.log('onEnd2'); console.log(this.myArray2); }, onFilter2() { console.log('onFilter2'); }, addEle() { this.myArray1.push('add'); }, removeEle() { this.myArray1.pop(); }, } 四、注意事项 draggable： v-model=&quot;myArray&quot; 或者 :list=&quot;myArray&quot; draggable=&quot;.item&quot; 表示class=&quot;item&quot;的元素可拖动 dhandle=&quot;.handle&quot; 表示class=&quot;handle&quot;的元素可控制拖动 group=&quot;samegroup&quot; 如要两个以上容器间拖动添加相同的group名 draggable子元素上： :disabled=&quot;false&quot; 禁止移动 其他： 点击删除元素时只触发choose事件 添加删除元素用可以改变原数组和对象的方法 ","link":"https://h8396x.coding-pages.com/post/Sf0E-kOV_/"},{"title":"jQCloud词云插件","content":"1、添加css &lt;link href=&quot;https://cdn.bootcss.com/jqcloud/1.0.4/jqcloud.css&quot; rel=&quot;stylesheet&quot;&gt; 2、添加js &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/jqcloud/1.0.4/jqcloud-1.0.4.min.js&quot;&gt;&lt;/script&gt; 3、添加标签 &lt;div id=&quot;tagsCloud&quot; style=&quot;width: 800px; height: 400px;&quot;&gt;&lt;/div&gt; 4、添加词云代码 &lt;script type=&quot;text/javascript&quot;&gt; var word_array = [ {text: &quot;百度&quot;, weight: 10, html: {title: &quot;百度搜索引擎&quot;}}, {text: &quot;百度&quot;, weight: 9, link: &quot;http://www.baidu.com/&quot;}, {text: &quot;百度&quot;, weight: 8, link: &quot;http://www.baidu.com/&quot;}, {text: &quot;百度&quot;, weight: 7, link:&quot;http://www.baidu.com&quot;} ]; $(function() { $(&quot;#tagsCloud&quot;).jQCloud(word_array); }); &lt;/script&gt; 5、Gridea添加云标签 &lt;!-- 在tags.ejs中添加html代码 --&gt; &lt;div class=&quot;paper&quot; style=&quot;overflow: hidden&quot;&gt; &lt;div id=&quot;tagsCloud&quot; style=&quot;width: 100%;height: 600px;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 添加js代码 --&gt; &lt;script src=&quot;&lt;%= themeConfig.domain %&gt;/media/jqcloud/jqcloud-1.0.4.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; if ($('#tagsCloud')) { var cloudArr = []; // 遍历标签 var tags = JSON.parse('&lt;%= JSON.stringify(tags) %&gt;'.replace(/&amp;#34;/g, '&quot;')); tags.forEach((tag, tagIndex) =&gt; { cloudArr.push({ weight: tags.length - tagIndex, text: tag.name, link: tag.link, }) }) $('#tagsCloud').jQCloud(cloudArr); } &lt;/script&gt; 效果图 ","link":"https://h8396x.coding-pages.com/post/2QR3ZvDCx/"},{"title":"Gridea连接coding步骤","content":"一、Gridea添加配置 1、域名：静态pages应用域名 2、仓库：仓库的名字，例如：blogs 3、仓库用户名：账户名 4、token：添加在coding上设置的访问令牌 5、CNAME：添加三方域名，可不设置。 二、coding添加token配置 三、开启静态pages（coding可一键开启） ","link":"https://h8396x.coding-pages.com/post/VXnhCfkUJ/"},{"title":"认识三大框架","content":"框架和库的区别 库： jQuery Swipper iScroll 其他依赖jQuery的插件 框架：有限制 Bootstrap 限制：12栅格 Vue 限制：DOM操作无用 Augular 限制：使用什么, 首先引入依赖; $开头都是angular系统对象 react 一、Vue框架 1、Vue是什么 Vue是前端的JS框架, 提供很多功能, 很方便实现前端页面 特点: 数据驱动界面的框架 js 开发: html,js添加, 数据改变, 显示新的数据 vue开发: MVVM, 设计好界面, 做好界面和数据的关联, 改了数据之后, 界面自动改变 2、作者 Vue作者:尤雨溪 3、特点 —— 数据驱动界面 例：有个数组 , 放在ul的li标签内显示 , 删除或修改数据 原来：JSfor循环拿出数据 , 拼接li , 插入到 ul 中 ; 删除数据要删除对应的li标签 Vue:先有数据 , 实现界面 , 绑定数据和界面 数据改变 , 界面自动改变 二、Angular 框架 1、Angular 是什么? Angular是基于数据绑定和mvc设计模式的前端框架，是一个用于设计动态web应用的结构框架。不仅仅是js框架，核心其实是对HTML标签的增强。 核心1: 数据绑定(数据驱动) 限制: 也是数据驱动, 先写好view, 设置绑定, 根据数据驱动界面 核心2: mvc设计结构 model 界面的数据模型 view 界面的显示 controller 界面的控制器 angular强制界面分为三个部分 好处: (1)数据绑定某种意义中简化界面, 修改了数据, 界面自动变化 (2)程序的结构十分清晰, angular强制界面分为三个部分, 有利于大规模项目的实现 2、作者 angular现在是google的框架, google有团队维护这个框架 3、angular版本问题 angular1(学习, JS语言, 不需要脚手架, 引入一个库能用了) angular2(学习, Typescript, 需要脚手架[网络,命令行,node,webpack,npm,] ) angular4(学习, Typescript, 需要脚手架[网络,命令行,node,webpack,npm,] ) 4、angular特性 (1)双向的数据绑定 (数据绑定是DOM变化，不是字符串的连接或者innerHTML变化。) (2)模板module (3)MVC (ViewModel , controller , view) viewmodel是一个用来提供特别数据和方法从而维护指定view的对象。是$scope的对象，只存在于AnguarJS的应用中。 controller负责设置初始状态和参数化$scope方法用以控制行为。controller并不保存状态也不和远程服务互动。 view是AngularJS解析后渲染和绑定后生成的HTML 。这个部分帮助你创建web应用的架构。 $scope只是一个简单的js对象，这个对象使用简单的API来侦测和广播状态变化。 $scope拥有一个针对数据的参考，controller定义行为，view处理布局和互动。 (4)服务和依赖注入 (对外提供某个特定的功能) (5)指令 (作为标签、属性、注释和类名使用。) 5、$scope 和 module 和 ng-controller $scope $scope是一个把view（一个DOM元素）连结到controller上的对象。 在我们的MVC结构里，这个 $scope 将成为model，它提供一个绑定到DOM元素（及其子元素）上的excecution context。 $scope 实际上就是一个JavaScript对象，controller和view都可以访问它，所以我们可以利用它在两者间传递信息。 在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。 每一个Angular应用都会有一个 $rootScope。这个 $rootScope 是最顶级的scope，它对应着含有 ng-app 指令属性的那个DOM元素。 module 模板,就是我们页面上的HTML代码，不需要附加任何额外的东西。在模板中可以使用各种指令来增强它的功能，这些指令可以让你把模板和数据巧妙的绑定起来。 在&lt;html&gt;标签上多了一个属性ng-app=”MyApp”，它的作用就是用来指定ng的作用域是在&lt;html&gt;标签以内部分。 在js中，我们调用angular对象的module方法来声明一个模块，模块的名字和ng-app的值对应。这样声明一下就可以让ng运行起来了。 ng-controller 要明确创建一个$scope 对象，我们就要给DOM元素安上一个controller对象，使用的是ng-controller 指令属性。 ng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。 所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父 scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。即如果controller是多层嵌套的，就会从最里面一直往外找。 三、React框架 虚拟DOM机制 (可以写原生应用) 1、什么是React React是一个用于构建用户界面的Javascript框架, React主要侧重于构建View视图，采用虚拟DOM机制。 2、作者 起源于facebook, 2013年开源 3、特点 (1)侧重于view, 不是全的框架, 项目需要配合其他库去使用 (2)开发采用虚拟dom, vitual dom机制,通过算法优化 界面改变刷新,速度在各个框架中最快 (3)采用jsx语法, jsx语法是js的扩展 (4)组件式开发设计思想, 都是组件套组件。写一个项目, 搭积木。 4、设计模式 React ( View层的技术，其他没有限定 ) Vue ( Model View ViewModel ) Angular ( Model View Controller ) ","link":"https://h8396x.coding-pages.com/post/PtK3WSLxU/"},{"title":"MVC和MVVM设计模式","content":"一、MVC设计模式 Models模型主要关注的是业务数据，即管理一个业务应用的数据，它们既与用户界面无关也与表现层无关。 JavaScript 的视图是关于构建和操作DOM元素，视图是对我们的数据的一种可视化展现。 控制器是模型和视图之间的中介，典型的职责是当用户操作视图的时候同步更新模型。 M = Model 模型,数据模型 Person = { name age sex ... } V = View 视图,(html+css)显示数据的界面 div p span C = Controller 控制器 1、拿出数据显示到界面 2、界面有变化的时候，修改数据 JavaScript 模板解决方案（例如Handlebars.js 和 Mustache）通常用于为视图定义模板作为标记，标记中包含有模板变量。标记要么存储在外部，要么存储在脚本标签里面，使用自定义的类型例如text/template。 将模板存储在外部的时候，这样在构建大型引应用的时候可以是模板按照需要动态加载。 二、MVP设计模式 模型-视图-展示器(MVP)是MVC设计模式的一个衍生模式,它专注于提升展现逻辑。 三、MVVM设计模式 MVVM是一种基于MVC和MVP的架构模式，它试图将用户界面（UI）从业务逻辑和行为中更加清晰地分离出来。 M = Model 数据模型 V = View 视图 VM = ViewModel 数据绑定 先写好数据，再写view界面，后写viewModel绑定 核心：数据变化后，界面自动变化 四、三种设计模式的比较 MVP和MVVM都是MVC的衍生物。它和它的衍生物之间关键的不同之处在于每一层对于其它层的依赖，以及它们相互之间是如何紧密结合在一起的。 在MVC中，视图位于我们架构的顶部，其背后是控制器。模型在控制器后面，而因此我们的视图了解得到我们的控制器，而控制器了解得到模型。这里，我们的视图有对模型的直接访问。然而将整个模型完全暴露给视图可能会有安全和性能损失，这取决于我们应用程序的复杂性。MVVM则尝试去避免这些问题。 在MVP中，控制器的角色被代理器所取代，代理器和视图处于同样的地位，视图和模型的事件都被它侦听着并且接受它的调解。不同于MVVM，没有一个将视图绑定到视图模型的机制，因此我们转而依赖于每一个视图都实现一个允许代理器同视图去交互的接口。 MVVM进一步允许我们创建一个模型的特定视图子集，包含了状态和逻辑信息，避免了将模型完全暴露给视图的必要。不同于MVP的代理器，视图模型并不需要去引用一个视图。视图可以绑定到视图模型的属性上面，视图模型则去将包含在模型中的数据暴露给视图。像我们所提到过的，对视图的抽象意味着其背后的代码需要较少的逻辑。 对此的副作用之一就是视图模型和视图层之间新增的的用于翻译解释的一层会有性能损失。这种解释层的复杂度根据情况也会有所差异——它可能像复制数据一样简单，也可能会像我们希望用视图理解的一种形式去操作它们，那样复杂。由于整个模型是现成可用的，从而这种操作可以被避免掉，所以MVC没有这种问题。 ","link":"https://h8396x.coding-pages.com/post/UuZyesJkJ/"},{"title":"同时配置github、gitee、coding的ssh","content":"1、创建rsa文件 cd ~/.ssh ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; -f &quot;id_rsa_github&quot; ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; -f &quot;id_rsa_gitee&quot; ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; -f &quot;id_rsa_coding&quot; . ├── config ├── id_rsa_coding ├── id_rsa_coding.pub ├── id_rsa_gitee ├── id_rsa_gitee.pub ├── id_rsa_github └── id_rsa_github.pub 2、添加.pub内容到相应平台 cat id_rsa_github.pub cat id_rsa_gitee.pub cat id_rsa_coding.pub 3、添加config文件解决冲突 # github Host github.com HostName github.com IdentityFile /Users/yourname/.ssh/id_rsa_github PreferredAuthentications publickey # gitee Host gitee.com HostName gitee.com IdentityFile /Users/yourname/.ssh/id_rsa_gitee PreferredAuthentications publickey # coding Host git.coding.net HostName git.coding.net IdentityFile /Users/yourname/.ssh/id_rsa_coding PreferredAuthentications publickey 4、测试连接 ssh -T git@github.com ssh -T git@gitee.com ssh -T git@git.coding.net ","link":"https://h8396x.coding-pages.com/post/BeK9Br7U1/"},{"title":"window7下leanote二进制部署","content":" 教程：https://51.ruyo.net/2922.html 1、下载文件 leanote二进制版 http://leanote.org/#download MongoDB http://dl.mongodb.org/dl/win32/x86_64 leanote客户端 https://leanote.com/ Robo 3T https://robomongo.org/download 2、安装步骤 1、在 ` D:\\mongodb ` 下新建data（db , log）文件夹 2、配置环境变量 ` ;D:\\mongodb\\bin ` 3、进入 ` D:\\mongodb\\bin ` 执行 ` mongod --dbpath D:\\mongodb\\data\\db ` 4、在浏览器：http://localhost:27017 查看是否安装成功； 5、进入` D: `导入数据 ` mongorestore -h localhost -d leanote --dir ./leanote/mongodb_backup/leanote_install_data/ ` 3、修改admin密码 进入个人中心修改密码 4、修改邮箱 use leanote db.users.update({Username:&quot;admin&quot;},{$set:{Email:&quot;xxxxxx@xxx.com&quot;}}); 5、客户端连接自建服务器 http://localhost:9000 6、备份数据 mongodump -h localhost -d leanote -o D:/data 7、制作.bat快速启动文件 文件一：mongodb.bat d: cd mongodb\\bin mongod --dbpath D:\\mongodb\\data\\db 文件二：mongodb27017.bat mongo 127.0.0.1:27017 文件三：leanote.bat d: cd leanote\\bin run.bat 8、添加管理员 use admin db.createUser({user:&quot;admin&quot;,pwd:&quot;password&quot;,roles:[&quot;root&quot;]}) db.auth(&quot;admin&quot;, &quot;password&quot;) 9、添加数据库用户 use leanote db.createUser({user: &quot;admin&quot;, pwd: &quot;password&quot;, roles: [{ role: &quot;dbOwner&quot;, db: &quot;leanote&quot; }]}) db.auth(&quot;admin&quot;, &quot;password&quot;) ","link":"https://h8396x.coding-pages.com/post/gcCr8zeHn/"},{"title":"mongodb","content":"1、安装和启动 # 进入 /usr/local cd /usr/local # 下载 sudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.4.2.tgz # 解压 sudo tar -zxvf mongodb-osx-x86_64-3.4.2.tgz # 重命名为 mongodb 目录 sudo mv mongodb-osx-x86_64-3.4.2 mongodb # 添加path路径 cd ~ vim .bash_profile # 添加环境变量 export PATH=/usr/local/mongodb/bin:$PATH export PATH=${PATH}:/usr/local/mongodb/bin source .bash_profile mongod -version # 启动 sudo mongod 2、安装可视化工具adminMongo 1、克隆adminMongo git clone https://github.com/mrvautin/adminMongo cd adminMongo 2、安装 npm install 3、启动 npm start 4、访问网站 http://127.0.0.1:1234 5、MongoDB链接 mongodb://127.0.0.1:27017 3、mongodb 安装问题 mac端 sudo open -e 〜/.bash_profile 权限被拒绝： 解决：sudo chown username ~/.bash_profile mac端 mongod 启动报错：Data directory /data/db not found 解决：更改指定运行路径，mongod --dbpath '新的可访问存储路径' mac端 mongod 启动报错：Is a mongod instance already running? 解决：删除这句报错前提供路径下的 mongod.lock 文件，sudo rm /xxx/xxx/data/db/mongod.lock mac端：新开终端 mongod 命令失效 原因：电脑端使用 iterm2 作为终端工具，未加载 ~/.bash_profile 文件中的环境变量 详解：https://blog.csdn.net/Bronze5/article/details/103440877 解决方案： cd ~ vim ~/.zshrc # 解决iterm2 中zsh 模式不加载 ~/.bash_profile 文件编写的环境变量！ source $HOME/.bash_profile source ~/.zshrc ","link":"https://h8396x.coding-pages.com/post/rhVfWiVDb/"},{"title":"MySql安装","content":"一、下载安装 官网下载地址：https://dev.mysql.com/downloads/mysql/ 可视化图形工具：SQLPro Studio 当弹出一个MYSQL Installer提示框的时候一定打开备忘录复制粘贴记下弹出框的密码 系统偏好设置 ——&gt; MySql ——&gt; start mysql server 二添加环境变量 打开：vim ~/.bash_profile 添加：PATH=$PATH:/usr/local/mysql/bin 命令：source ~/.bash_profile 三、登录sql mysql -u root -p 四、常用命令 CREATE DATABASE new_database; show databases; use databases show tables 五、修改强密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; (更新用户密码 ) 六、文章教程 http://www.bubuko.com/infodetail-2065773.html ","link":"https://h8396x.coding-pages.com/post/Hej9Q0-li/"},{"title":"Lottie结合AE实时渲染动画","content":"1、lottie.vue文件 /* Lottie官网：https://www.lottiefiles.com/?page=1 1、安装vue 2、安装lottie : npm install --save vue-lottie 3、引入components : import Lottie from './lottie.vue'; 4、引入json文件 */ &lt;template&gt; &lt;div :style=&quot;style&quot; ref=&quot;lavContainer&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import lottie from 'lottie-web'; export default { props: { options: { type: Object, required: true }, height: Number, width: Number, }, data () { return { style: { width: this.width ? `${this.width}px` : '100%', height: this.height ? `${this.height}px` : '100%', overflow: 'hidden', margin: '0 auto' } } }, mounted () { this.anim = lottie.loadAnimation({ container: this.$refs.lavContainer, renderer: 'svg', loop: this.options.loop !== false, autoplay: this.options.autoplay !== false, animationData: this.options.animationData, rendererSettings: this.options.rendererSettings } ); this.$emit('animCreated', this.anim); } } &lt;/script&gt; 2、渲染一个动画 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 第一个动画 --&gt; &lt;lottie :options=&quot;defOpt1&quot; :height=&quot;300&quot; :width=&quot;300&quot; v-on:animCreated=&quot;handleAni&quot;/&gt; &lt;!-- 第二个动画 --&gt; &lt;lottie :options=&quot;defOpt2&quot; :height=&quot;200&quot; :width=&quot;200&quot; v-on:animCreated=&quot;handleAni&quot;/&gt; &lt;!-- 控制器 --&gt; &lt;div&gt; &lt;p&gt;Speed: x{{animationSpeed}}&lt;/p&gt; &lt;input type=&quot;range&quot; value=&quot;1&quot; min=&quot;0&quot; max=&quot;3&quot; step=&quot;0.5&quot; v-on:change=&quot;onSpeedChange&quot; v-model=&quot;animationSpeed&quot;&gt; &lt;/div&gt; &lt;button v-on:click=&quot;stop&quot;&gt;stop&lt;/button&gt; &lt;button v-on:click=&quot;pause&quot;&gt;pause&lt;/button&gt; &lt;button v-on:click=&quot;play&quot;&gt;play&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // lottie组件 import Lottie from './lottie.vue'; // 示例动画json文件可在lottie官网下载 import * as animate1 from '../js/animate1.json'; import * as animate2 from '../js/animate2.json'; export default { name: 'app', components: { 'lottie': Lottie }, data() { return { count: 1, defOpt1: {animationData: animate1}, defOpt2: {animationData: animate2} animationSpeed: 1 } }, methods: { handleAni: function (anim) { let aniName = &quot;anim&quot;+this.count; this[aniName] = anim; this.count++; }, stop: function () { this.anim.stop(); }, play: function () { this.anim.play(); }, pause: function () { this.anim.pause(); }, onSpeedChange: function () { this.anim.setSpeed(this.animationSpeed); } } } &lt;/script&gt; &lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot;&gt; #app{ position: absolute; width: 100%; overflow: auto; background: greenyellow; } &lt;/style&gt; ","link":"https://h8396x.coding-pages.com/post/6WDISjhT3/"},{"title":"gka帧动画生成工具","content":"1、gka地址 [gka](https://github.com/gkajs/gka) // 简单、高效的帧动画生成工具，图片处理工具。 2、安装使用 npm i gka -g gka E:\\img 3、gka参数 -d, --dir &lt;string&gt; # 图片文件夹地址 -u, --unique [boolean] # 开启相同图片复用优化 -c, --crop [boolean] # 开启空白裁剪优化 -s, --sprites [boolean] # 开启合图优化 -m, --mini [boolean] # 开启图片压缩 -p, --prefix [string] # 文件重命名前缀 -t, --template &lt;string&gt; # 生成动画文件模板 默认 css ，可选模见 Templates 模板列表 -f, --frameduration &lt;number&gt; # 每帧时长，默认 0.04 -i, --info [boolean] # 开启输出信息文件 -o, --output &lt;string&gt; # 指定生成目录地址 -a, --algorithm &lt;string&gt; # 合图布局模式 默认 left-right，可选 binary-tree | top-down .. --bgcolor &lt;string&gt; # 为图片增加背景色，可选，支持格式：'rgb(255,205,44)'、 '#ffcd2c' --count &lt;number&gt; # 生成多合图，指定几张图片合成一张合图，可选 --ratio &lt;number&gt; # 生成指定的N倍图动画，如 --ratio 2 支持retina屏幕的2倍图动画， 可选 --split [boolean] # 开启图片空白拆分优化，与 -t canvas 结合使用 --diff [boolean] # 开启图片像素差优化，与 -t canvas 结合使用 ","link":"https://h8396x.coding-pages.com/post/593EuPf6q/"},{"title":"插件-cookie本地存储","content":"一、本地存储插件Cookie &lt;!-- 本地： 数据存储在磁盘上 实例： 登录 记住用户名，保持1周登录 持久化存储/本地存储 (1) cookie (2) H5 - localStorage (sessionStorage会话存储) (3) H5 -WebSQL 浏览器中的数据库存储 (4) H5 -IndexedDb 索引数据库 --&gt; 1、根据需要写HTML和CSS样式 2、引入jQuery文件和cookie插件 注意：注意先后顺序 3、JS实例 &lt;!-- jquery.cookie.min.js 插件: 先导入jquery, 再导入这个插件 用法: 读取某个cookie值, $.cookie(&quot;username&quot;) 设置cookie值 $.cookie(&quot;username&quot;,&quot;zhangsan&quot;) 有效期-网页不关闭 $.cookie(&quot;username&quot;,&quot;zhangsan&quot;,{ path:&quot;/&quot;, expires:7 //7天有效 //date对象 }) --&gt; 二、实例：记住用户名和密码， 七天内自动登录 1、HTML和CSS &lt;div id=&quot;&quot;&gt; &lt;p&gt;导航栏&lt;/p&gt; &lt;a class=&quot;login-link&quot; href=&quot;&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;reg-link&quot; href=&quot;&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div id=&quot;&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input class=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br /&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br /&gt; &lt;div id=&quot;&quot;&gt; &lt;input class=&quot;remember&quot; type=&quot;checkbox&quot; value=&quot;&quot;/&gt;记住用户名和密码&lt;br/&gt; &lt;input type=&quot;checkbox&quot; value=&quot;&quot;/&gt;一周之内自动登录&lt;br/&gt; &lt;/div&gt; &lt;div id=&quot;&quot;&gt; &lt;button class=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; JS实现 //导入相关文件 &lt;script src=&quot;jquery-1.9.1.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.cookie.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () { //登陆后将导航栏的登录改为个人用户名 if($.cookie(&quot;isLogin&quot;) == &quot;1&quot;){ $(&quot;.login-link&quot;).html($.cookie(&quot;username&quot;)); } //判断自动登录(获取用户名、密码放入对应的input框) if($.cookie(&quot;username&quot;)){ $(&quot;.username&quot;).val($.cookie(&quot;username&quot;)) } if($.cookie(&quot;password&quot;)){ $(&quot;.password&quot;).val($.cookie(&quot;password&quot;)) } if($.cookie(&quot;isRemember&quot;) == &quot;1&quot;){ $(&quot;.remember&quot;)[0].checked = true; } //设置用户名、密码, 可与后台交互动态获取 var username = &quot;zz&quot; var password = &quot;123456&quot; //点击登录按钮的事件处理 $(&quot;.login&quot;).click(function () { //登陆时获取输入的 用户名 和 密码 var inputUsername = $(&quot;.username&quot;).val(); var inputPassword = $(&quot;.password&quot;).val(); //判断输入的用户名密码与设置的用户名密码是否相等 if(inputUsername == username&amp;&amp;inputPassword == password){ //定义了距离当前时间20 * 1000ms = 20s 的时间 var date = new Date(); date.setTime(date.getTime()+20*1000) //如果记住密码框 被选中 记住用户名和密码等 if($(&quot;.remember&quot;)[0].checked){ $.cookie(&quot;isRemember&quot;,&quot;1&quot;,{ path:&quot;/&quot;, expires:date //date对象 }) $.cookie(&quot;username&quot;,inputUsername,{ path:&quot;/&quot;, expires:date //date对象 }) $.cookie(&quot;password&quot;,inputPassword,{ path:&quot;/&quot;, expires:date //date对象 }) } $(&quot;.login-link&quot;).html($.cookie(&quot;username&quot;)) $.cookie(&quot;isLogin&quot;,&quot;1&quot;,{ path:&quot;/&quot;, expires:date //7天有效 //date对象 }) }else{ alert(&quot;登录失败&quot;) } }) }) &lt;/script&gt; ","link":"https://h8396x.coding-pages.com/post/_3_-7UicJ/"},{"title":"插件-pagination分页","content":"1、CSS部分 引入CSS样式 2、HTML部分 //注意ID名, 类名 &lt;div id=&quot;Pagination&quot; class=&quot;pagination&quot;&gt; &lt;/div&gt; 3、JS部分 (1)引入jQuery文件和分页插件的JS文件 (2)初始化及数据下载后的具体显示 $(function(){ //第几页，每页多少个数据 var page = 1; var count = 10; //回调函数 function pageselectCallback(index) { //点击之后, 修改page,重新下载 var new_page = index+1; //解决重复调用问题 还是这一页, return ； 判断两个相等, 不执行下载数据 ；当page为1, current_page是0 if(index == page-1){ return; } page = new_page; downloadListData(); } //初始化函数的参数 //参数1: 总页数total = 数据总数 / count //参数2: 对象 // current_page:当前页 // num_edge_entries:前面显示3个 // num_display_entries:后面显示3个 // callback 点击后回调 // items_per_page 每页多少数据 // prev_text 显示什么(上一页) // next_text 显示什么(下一页) //初始化函数 function pageShow( total ){ $(&quot;#Pagination&quot;).pagination(total , { current_page:page-1, num_edge_entries: 3, num_display_entries: 3, callback: pageselectCallback, items_per_page:count, prev_text:&quot;上一页&quot;, next_text:&quot;下一页&quot; }); } //数据下载函数 function downloadListData(){ //1、通过get,post等拿数据 //2、数据拿完后调用分页的初始化函数 pageShow( total ) } }) 原生JS实现分页 $(function () { //第几页 var page = 1; //每页多少个数据 var count = 10; function downloadListData () { //接口中用start var start = (page-1)*count; var url = readListUrl+&quot;&amp;start=&quot;+start+&quot;&amp;count=&quot;+count; $.getJSON(url,{},function (r) { //下载数据, 并生成dom显示 var list = r.data; var html = &quot;&quot;; for(var i=0; i&lt;list.length; i++){ var item = list[i]; } $(&quot;.section_list&quot;).html(html); //获取页数 var pageCount = Math.ceil(r.total/10); //生成分页dom, 并添加CSS样式 $(&quot;.list_pagination&quot;).html(&quot;&quot;); var html = &quot;&quot;; html += &quot;&lt;li data-page='first'&gt;首页&lt;/li&gt;&quot; html += &quot;&lt;li data-page='prev'&gt;上一页&lt;/li&gt;&quot; for(var i=0; i&lt;pageCount; i++){ if(i+1 == page){ html += &quot;&lt;li style='background-color:gray' data-page='&quot;+(i+1)+&quot;'&gt;&quot;+(i+1)+&quot;&lt;/li&gt;&quot; }else{ html += &quot;&lt;li data-page='&quot;+(i+1)+&quot;'&gt;&quot;+(i+1)+&quot;&lt;/li&gt;&quot; } } html += &quot;&lt;li data-page='next'&gt;下一页&lt;/li&gt;&quot; html += &quot;&lt;li data-page='last'&gt;最后一页&lt;/li&gt;&quot; $(&quot;.list_pagination&quot;).html(html); $(&quot;.list_pagination li&quot;).css({ &quot;padding&quot;:&quot;3px 5px&quot;, &quot;margin-left&quot;:&quot;10px&quot;, &quot;border&quot;:&quot;1px solid black&quot; }) //实现点击事件 $(&quot;.list_pagination li&quot;).on(&quot;click&quot;,function () { var click_page = $(this).attr(&quot;data-page&quot;); if(click_page == page){ //重复点击当前页 console.log(&quot;已经加载!&quot;); return; } if(click_page == &quot;first&quot;){ //第一页 page = 1; }else if(click_page == 'prev'){ //前一页 page--; if(page&lt;1){ page=1; } }else if(click_page == 'next'){ //下一页 page++; if(page&gt;pageCount){ page=pageCount; } }else if(click_page == &quot;last&quot;){ //上一页 page = pageCount; }else{ //点击了数字 重新发起请求 page = click_page; } //重新加载数据 downloadListData (); }) }) } downloadListData (); }) ","link":"https://h8396x.coding-pages.com/post/KENJDZdGY/"},{"title":"插件-Base64加密","content":"1、引入JS和Base64文件（注意先后问题） &lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;base64.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 2、加密和解密 $(function(){ var str = &quot;秦时明月之万里长城&quot;; //1、加密 var b64 = new Base64(); var str = b64.encode(&quot;你确定要进攻吗&quot;); console.log(str); //2、解密 var newStr = b64.decode(str); console.log(newStr); //3、解密密文 var newStr2 = b64.decode(&quot;5L2g56Gu5a6a6KaB6L+b5pS75ZCX&quot;); console.log(newStr2); }); ","link":"https://h8396x.coding-pages.com/post/WF0J3vp7F/"},{"title":"插件-lazyload懒加载","content":"一、懒加载的原理 懒加载：并没有全部加在完毕，只显示一部分商品（减轻服务器压力） 原理： 1、一次性把所有路径都拿过来 2、但是，并没有把路径放到src中，而是放到自定义属性中 3、当滚动到指定位置，将自定义的属性放到src中，图片才会加载出来 预加载：loading...的时候，把资源加载进来，用户响应很快，服务器压力很大 二、原生JS实现懒加载 注意：加载图片 = （图片距离页面顶端高度 &lt; 浏览器滚动距离 + 可视区域距离） var imgs = document.getElementsByTagName(&quot;img&quot;); function loadImg(){ //获取当前可视区域高度 var h1 = window.innerHeight; //浏览器滚动过的高度 var h2 = document.body.scrollTop || document.documentElement.scrollTop; for (var i = 0 ; i &lt; imgs.length ; i++) { //判断当前图片距离顶端的距离 &lt; ... if(imgs[i].offsetTop &lt; h1 + h2){ imgs[i].src = imgs[i].getAttribute(&quot;data-src&quot;); } } } loadImg(); window.onscroll = function(){ loadImg(); } 三、插件实现懒加载 //注意给img添加类名lazy , 并设置自定义属性data-original &lt;img class=&quot;lazy&quot; src=&quot;&quot; data-original=&quot;img/search1.jpg&quot; /&gt; /* JS部分 注意引入文件的顺序 */ &lt;script src=&quot;js/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.lazyload.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;.lazy&quot;).lazyload(); }) &lt;/script&gt; 四、Vue实现懒加载 // model模型-存储数据的地方 var data = { list:[], imagePrefix:imagePrefix, /*加载更多*/ start:0, count:5, /*是否加载*/ isRefresh:false } // ViewModel数据驱动界面-数据和界面绑定 var app = new Vue({ //选择id为app的选择器 el:&quot;#app&quot;, data:data, methods:{ downloadData:function(){ var url = readListUrl+&quot;&amp;start=&quot;+this.start+&quot;&amp;count=&quot;+this.count; this.$http({url:url}).then(function(response){ var list = response.data.data; //当前加载的加上之前加载的 this.list = this.list.concat(list); this.isRefresh = false; }) } }, created:function(){ this.downloadData(); var self = this; /* 加载更多的实现 */ window.onload = function(){ window.onscroll = function(){ //滚动到底部的条件 滚动条到顶部(变) + 滚动条对应的界面高度(可视高度,不变) === 整个页面的高度(不变) var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; var clientHeight = document.documentElement.clientHeight; var pageHeight = document.body.scrollHeight; if( Math.abs(scrollTop+clientHeight-pageHeight) &lt;= 6 ){ /* 加载更多 */ if(!self.isRefresh){ self.start += self.count; self.downloadData(); self.isRefresh = true; } } } } } }); ","link":"https://h8396x.coding-pages.com/post/ojNO2n5Hc/"},{"title":"插件-fullPage全屏","content":"1、CSS部分 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;js/jquery.fullPage.min.css&quot;/&gt; //不要给 #full设置样式 .page1{ background: url(../img/1.jpg) no-repeat; background-size: 100% 100%; } .page2{ background: url(../img/2.jpg) no-repeat; background-size: 100% 100%; } .page3{ background: url(../img/3.jpg) no-repeat; background-size: 100% 100%; } .page4{ background: url(../img/4.jpg) no-repeat; background-size: 100% 100%; } .page5{ background: url(../img/5.jpg) no-repeat; background-size: 100% 100%; } 2、HTML部分 &lt;!-- jQuery的插件 fullpage.js 实现全屏滚动的效果 --&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;秦时明月&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#page1&quot;&gt;百步飞剑&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#page2&quot;&gt;夜尽天明&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#page3&quot;&gt;诸子百家&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#page4&quot;&gt;万里长城&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#page5&quot;&gt;君临天下&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 开始配置 fullpage --&gt; &lt;div id=&quot;full&quot;&gt; &lt;div class=&quot;section page1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;section page2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;section page3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;section page4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;section page5&quot;&gt;&lt;/div&gt; &lt;/div&gt; 3、JS部分 &lt;script src=&quot;js/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.fullPage.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#full&quot;).fullpage({ //是否显示导航 navigation:true, //通过导航控制锚点 anchors:['page1','page2','page3','page4','page5'], //导航位置 navigationPosition:'right', //滚动速度 scrollingSpeed:1000, //是否无缝滚动 continuousVertical:true, //加载之后, 触发之前触发 afterLoad:function(anchorLink,index){ console.log(111); console.log(anchorLink); // 滚动图片的来源 pageX console.log(index); // 加载图片的索引 }, //鼠标离开之后触发 onLeave:function(index,nextIndex,direction){ console.log(222); console.log(&quot;我来自第&quot;+index+&quot;屏&quot;); //滚动前的索引 console.log(&quot;我要滚到第&quot;+nextIndex+&quot;屏&quot;); //滚动后的索引 console.log(&quot;滚动方向&quot;+direction); //要滚动的方向 up down }, //页面渲染完成后, 页面只渲染一次 afterRender:function(){ console.log(页面渲染完成后); } }) }) &lt;/script&gt; ","link":"https://h8396x.coding-pages.com/post/0jClD_z87/"},{"title":"插件-qrcode二维码","content":"在线网站：草料二维码 1、CSS部分 #qrcode2{ position: relative; } #img{ position: absolute; width: 56px; height: 56px; top: 100px; left: 100px; } 2、HTML部分 &lt;div id=&quot;qrcode1&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt; &lt;div id=&quot;qrcode2&quot;&gt; &lt;img id=&quot;img&quot; src=&quot;src/link.jpg&quot; /&gt; &lt;/div&gt; 3、JS部分 &lt;!--1、引入jQuery和二维码文件， 注意顺序问题--&gt; &lt;script src=&quot;js/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.qrcode.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ /* 对文本进行加密 */ $(&quot;#qrcode1&quot;).qrcode(&quot;this plugin is great&quot;); /* 对图片进行加密 */ $(&quot;#qrcode2&quot;).qrcode({ //默认宽 width:256, //默认高 height:256, //默认渲染模式 render:&quot;canvas&quot;, //默认背景色：#fff background:&quot;#fff&quot;, //默认二维码颜色：#000 foreground:&quot;#000&quot;, //计算模式 typeNumber:-1, //二维码内容 text:utf16to8(&quot;秦时明月之君临天下&quot;), }); /*解决中文乱码问题*/ function utf16to8(str){ var out, i, len, c; out = &quot;&quot;; len = str.length; for(i = 0; i &lt; len; i++) { c = str.charCodeAt(i); if((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) { out += str.charAt(i); }else if(c &gt; 0x07FF) { out += String.fromCharCode(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 6) &amp; 0x3F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); }else{ out += String.fromCharCode(0xC0 | ((c &gt;&gt; 6) &amp; 0x1F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); } } return out; } }); &lt;/script&gt; ","link":"https://h8396x.coding-pages.com/post/2bKqvVt3K/"},{"title":"插件-iScroll上拉刷新下拉加载","content":"1、CSS部分 2、HTML部分 &lt;div class=&quot;header&quot;&gt; 我是头部 &lt;/div&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;scroll&quot;&gt; &lt;ul&gt; &lt;li&gt;秦时明月之万里长城&lt;/li&gt; &lt;li&gt;秦时明月之万里长城&lt;/li&gt; ... ... &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; 我是底部 &lt;/div&gt; 3、JS部分 /* 1、引入文件 */ &lt;script src=&quot;swiper/iscroll.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function(){ //创建滚动对象 //参数一：滚动对象的选择器 //参数二：滚动对象的配置项 var myScroll = new IScroll(&quot;.wrapper&quot;,{ //通过鼠标控制 mouseWheel:true }) } &lt;/script&gt; 4、vue使用 // 有事需要在外层加 setTimeout() 定时器去触发该事件 this.scroller = new IScroll(&quot;.selectWelfare&quot;,{ click: true, scrollbars: true， taps: true, mouseWheel: true, preventDefault: false, probeType:2, // 可以在scroll中监听this.y bounceTime:100, // 回弹时间 bounce: false, // 启用禁止回弹 momentum: false, // 启用禁止惯性 }); // 在滚动开始时进行某些操作 this.scroller.on('scrollStart',function(){ }) // 在滚动结束时进行某些操作 this.scroller.on('scrollEnd',function(){ }) // 禁止滚动条滑动 this.scroller.disable(); // 滑动到顶部或其他位置 this.scroller.scrollTo(0,0); // 销毁滚动条 this.scroller.destroy(); // 刷新滚动条 this.$nextTick(() =&gt; { const delay = setTimeout(() =&gt; { if (this.scroller) { this.scroller.refresh(); clearTimeout(delay); } }, 0); }); ","link":"https://h8396x.coding-pages.com/post/lN_J5cVbc/"},{"title":"hilo之loader 篇","content":"LoaderQueue 下载队列 // 创建下载队列 var queue = new Hilo.LoadQueue([{ id:'hilo', src:'https://gw.alicdn.com/tfs/TB1iNtERXXXXXcBaXXXXXXXXXXX-600-600.png_200x200.jpg', crossOrigin:'Anonymous' }]).on('complete', function(e){ var bmp = new Hilo.Bitmap({ image: queue.getContent('hilo') }).addTo(stage); }); // 开启下载队列 queue.start(); // 创建下载队列 var queue = new Hilo.LoadQueue(); // 设置最大连接数 默认为2 queue.maxConnections = 1; // 添加资源 queue.add([ // 本地资源 {id:'fish', noCache:true, src:'images/fish.png'}, // 线上资源 {id:'data', type:'jsonp', callback:'weekJSONP', src:'http://img1.tbcdn.cn/L1/584/1/20.js'} ]); // css loader queue.add({id:'taobao_css', type:'css', src:'http://g.tbcdn.cn/tbc/tmsg/3.0.2/index-min.css', loader:{ load: function(data){ var link = document.createElement('link'); link.type = 'text/css'; link.rel = 'stylesheet'; if(data.id) link.id = data.id; link.addEventListener('load', this.onLoad.bind(this), false); link.addEventListener('error', this.onError.bind(this), false); link.href = data.src; document.getElementsByTagName('head')[0].appendChild(link); }, onLoad: function(e){ console.log('我在quere.on(&quot;load&quot;)前执行') return e.target; }, onError: function(e){ return e; } }}); // 给 queue 绑定事件 queue.on('load', function(e){ console.log(e.detail.src , queue.getLoaded() , queue.getTotal()); }).on('complete', function(e){ // 其他操作，比如创建静态位图 }).on('error', function(e){ console.log(e.detail.src); }); // 开启下载器 queue.start(); tween Ease 缓动函数 // ease 代表缓动的变化率 var easeTypeNames = ['Quad', 'Cubic', 'Quart', 'Quint', 'Sine', 'Expo', 'Circ', 'Elastic', 'Back', 'Bounce', 'Linear']; var easeFunctionNames = ['EaseNone', 'EaseIn', 'EaseOut', 'EaseInOut']; var easeType = Hilo.Ease[easeTypeName]; var easeFunction = easeType[easeFunctionName]; Tween ( Hilo.Ease ) 运动 // 声明 Tween 类 var Tween = Hilo.Tween; // 创建定时器 var ticker = new Hilo.Ticker(60); ticker.addTick(Tween); // 添加tween类 ticker.start(); // 创建500个小方块 var boxes = []; var total = 500; for(var i = 0; i &lt; total; i++){ var box = document.createElement('div'); box.id = 'box' + i; box.className = 'box'; gameContainer.appendChild(box); boxes[i] = box; } // 翻转方块 —— 使方块从最后一个开始运动 // boxes.reverse(); // 小方块运动 Tween.to(boxes, {y:400}, { duration: 1000, // duration 和 stagger 影响动画运动时间和幅度 stagger: 10, // stagger 错开 ease: Hilo.Ease.Elastic.EaseOut, onUpdate: function (ratio, tween) { tween.target.style.webkitTransform = 'translate(0,' + tween.target.y + 'px)'; } }); Tween ( .link ) 运动 // 提前声明 Tween var Tween = Hilo.Tween; // 创建ticker var ticker = new Hilo.Ticker(60); ticker.addTick(Tween); ticker.start(); // 创建 box ，添加起始位置 var box = document.createElement('div'); box.id = 'box'; box.className = 'box'; box.x = 0; box.y = 0; gameContainer.appendChild(box); // 添加缓动动画(运动物体，结束位置，参数) Tween.to(box, {x:50, y:50}, { duration: 500, onUpdate: boxMove, onComplete: runLink }); // 循环运动 function runLink(){ Tween.to(box, {x:50, y:150}, { duration: 500, // 运动时长 onUpdate: boxMove }).link( Tween.to(box, {x:150}, { duration: 500, onUpdate: boxMove, delay:'+0' // .link中一定要加delay属性，可为 0 }) ).link( Tween.to(box, {y:50}, { duration: 500, onUpdate: boxMove, delay:'+1000' // .link中一定要加delay属性，可为 0 }) ).link( Tween.to(box, {x:50}, { duration: 500, onUpdate: boxMove, delay:'+0', onComplete:runLink }) ) } // 运动操作的实现 function boxMove(ratio, tween){ tween.target.style.webkitTransform = 'translate(' + tween.target.x + 'px,' + tween.target.y + 'px)'; } ","link":"https://h8396x.coding-pages.com/post/vNoo2wQsM/"},{"title":"hilo之game（相机和粒子系统）","content":"1、Camera 普通相机 // 创建tween类 var Tween = Hilo.Tween; // 创建舞台 var stage = new Hilo.Stage({ renderType: 'canvas', container: document.getElementById(&quot;wrap&quot;), width: 500, height: 500 }); // 创建地图 var map = new Hilo.Container({ width: 1000, height: 1000 }).addTo(stage); var bg = window.bg = new Hilo.Bitmap({ image: 'images/map.jpg', width: 1000, height: 1000 }).addTo(map); // 创建摄像机，设置边界，deadzone var deadzone = [50,50,100,100]; var camera = new Hilo.Camera({ width:500, height:500, bounds:[0, 0, 1000, 1000], // 捕捉范围 deadzone: deadzone // 盲区 }); // 显示deadzone区域 stage.addChild(new Hilo.View({ x:camera.deadzone[0], y:camera.deadzone[1], width:camera.deadzone[2], height:camera.deadzone[3], background:&quot;rgba(255, 0, 0, 0.3)&quot; })); // 创建第一只鱼 var fish0 = new Hilo.Bitmap({ image: 'images/fish.png', rect: [0, 0, 174, 126], // 图片大小 x: 100, // 初始位置 y: 100, // 初始位置 scaleX: 0.5, // 缩小 scaleY: 0.5, // 缩小 pivotX: 174, // 鱼相对于deadzone的位置 pivotY: 55, // 鱼相对于deadzone的位置 onUpdate:function(){ this.x +=this.speed; if(this.x &gt; 950 || this.x &lt; 0){ this.speed *= -1; this.scaleX *= -1; } } }).addTo(map); fish0.speed = 2; // 创建第二只鱼 var fish1 = new Hilo.Bitmap({ image: 'images/fish.png', rect: [0, 0, 174, 126], x: 100, y: 100, scaleX: 0.5, scaleY: 0.5, pivotX: 174, pivotY: 55, rotation:90, onUpdate:function(){ this.y +=this.speed; if(this.y &gt; 950 || this.y &lt; 0){ this.speed *= -1; this.scaleX *= -1; } } }).addTo(map); fish1.speed = 2; // 开启定时器 var ticker = new Hilo.Ticker(60); ticker.addTick(stage); ticker.addTick(camera); ticker.addTick(Tween); ticker.start(); // map跟随摄像机滚动 ticker.addTick({ tick:function(){ map.x = - camera.scroll.x; map.y = - camera.scroll.y; } }); // 摄像机跟着鱼滚动 camera.follow(fish1); // 切换摄像机跟随对象 var tween; document.body.onclick = function(){ var target = camera.target == fish1?fish0:fish1; // 要跟随的鱼的坐标点 var pos = { x:camera.target.x, y:camera.target.y }; // 移除上次的跟随对象 Tween.remove(tween); // 跟随当前的鱼 tween = Tween.to(pos,{ x:target.x, y:target.y },{ duration:500, onComplete:function(){ camera.follow(target, deadzone); } }) // 鱼在运动，重新追踪一次 camera.follow(pos, null); } 2、Camera3d 3D相机 （未完成） 3、ParticleSystem粒子系统 // 粒子背景图 var img = document.getElementById(&quot;texture&quot;); // 创建粒子系统 var particleSystem = new Hilo.ParticleSystem({ x:0, y:0, emitNum:5, // 粒子个数 emitTime:1, // 时间间隔 particle:{ // 粒子 image:img, // 粒子背景图 life:22, alphaV:-.01, vxVar: 100, // x 轴方向水平散开 vyVar: 300, // y 轴方向垂直散开 axVar: 500, // z 轴水平散开 ayVar: 200, // z 轴垂直散开 scale: 0.8, // 缩小放大 rotationVar:360, // 旋转相关 rotationVVar: 10, // 旋转相关 pivotX:.5, // 中心点 pivotY:.5, frame:[ // 帧 [75, 236, 7, 11], [111, 160, 17, 46], [68, 236, 7, 11], [112, 223, 7, 17], [0, 0, 30, 99] ] } }); // 添加粒子系统 stage.addChild(particleSystem); // 开启粒子系统 particleSystem.start(); // 在定时器中设置粒子系统的随机位置 ticker.addTick({ tick:function(){ particleSystem.emitterX = Math.random() * winWidth; particleSystem.emitterY = Math.random() * winHeight; } }) ","link":"https://h8396x.coding-pages.com/post/kvOYoUCDe/"},{"title":"Hilo之view、util、event","content":"view 1、Stage 舞台 var stage = new Hilo.Stage({ renderType: 'canvas', container: document.getElementById(&quot;wrap&quot;), width: 600, height: 600 }) 2、Container 容器 var container = new Hilo.Container({ x: 0, y: 0, width: 600, height: 600, background: '#000', totation: 0, // 顺时针旋转 0 deg }).addTo(stage); 3、Bitmap 静态位图 var bmp = new Hilo.Bitmap({ image: '../../img/error/error.png', rect: [100,100,500,500], x: 0, y: 0 }).addTo(stage); 4、view（设置渐变背景色） var view = new Hilo.View({ x: 20, y: 20, width: 200, height: 200 }).addTo(container); // 只有canvas支持渐变色 if(!Hilo.isFlash &amp;&amp; stage.renderer.renderType === 'canvas'){ var gradient = stage.renderer.context.createLinearGradient(0, 0, 0, view.height); gradient.addColorStop(0, '#fc0'); gradient.addColorStop(0.5, '#ff0'); gradient.addColorStop(1.0, '#0f0'); view.background = gradient; } 5、Button 按钮(绑定事件) // DOM事件 stage.enableDOMEvent([Hilo.event.POINTER_START, Hilo.event.POINTER_MOVE, Hilo.event.POINTER_END]); // 按钮 var blueBtn = new Hilo.Button({ id: 'blueBtn', x: 0, y: 0, width: 100, height: 50, image: '', background: 'blue', upState: {rect:[0, 0, 64, 64]}, overState: {rect:[64, 0, 64, 64]}, downState: {rect:[128, 0, 64, 64]}, disabledState: {rect:[192, 0, 64, 64]} }).addTo(stage); // 按钮绑定事件 touchstart 和 touchend 事件 blueBtn.on(Hilo.event.POINTER_START, function(e){ console.log(e.type, this); }).on(Hilo.event.POINTER_END, function(e){ console.log(e.type, this); }); 6、Graphics 图形 var g = new Hilo.Graphics({ width: 100, height: 100, x: 40, y: 20 }); // 正方形 g.lineStyle(1, &quot;#009898&quot;).beginFill(&quot;#0ff&quot;).drawRect(0.5, 0.5, 99, 99).endFill().addTo(stage); // 圆角正方形 g.lineStyle(5, &quot;#009898&quot;).beginFill(&quot;#0ff&quot;).drawRoundRect(5, 5, 90, 90, 20).endFill().addTo(stage); // 圆 g.lineStyle(2, &quot;#009898&quot;).beginRadialGradientFill(50, 50, 0, 50, 50, 50, [&quot;#fff&quot;, &quot;#4ffcfc&quot;], [0, 1]).drawCircle(2, 2, 48).endFill().addTo(stage); // 椭圆 g.lineStyle(5, &quot;#009898&quot;).beginFill(&quot;#0ff&quot;).drawEllipse(5, 5, 90, 50).endFill().addTo(stage); // 带渐变色的长方形 g.lineStyle(2, &quot;#009898&quot;).beginLinearGradientFill(0, 0, 60, 0, [&quot;#fff&quot;, &quot;#4ffcfc&quot;], [0.3, 1]).drawRect(2, 2, 66, 86).endFill().addTo(stage); // svg图形 var svgPath = &quot;M53 84 C53 84 51 84 51 84 C51 89 53 94 56 94 C64 94 71 89 71 84 C71 72 64 64 56 64 C42 64 31 72 31 84 C31 100 42 114 56 114 C75 114 91 100 91 84 C91 61 75 44 56 44 C31 44 11 61 11 84 C11 111 31 134 56 134 C86 134 111 111 111 84 C111 50 86 24 56 24&quot;; g.lineStyle(4, &quot;#02d1d1&quot;).drawSVGPath(svgPath).closePath().endFill().addTo(stage); beginPath() 开始路径 lineStyle(1, &quot;#000&quot;) 边框样式(粗细，颜色) beginFill(&quot;#0ff&quot;) 开始填充颜色 beginLinearGradientFill(0, 0, 60, 0, [&quot;#fff&quot;, &quot;#4ffcfc&quot;], [0.3, 1]) 开始填充渐变色 moveTo() 移动画笔到开始位置 lineTo() 画线 drawRect(0.5, 0.5, 99, 99) 画正方形 drawRoundRect(5, 5, 90, 90, 20) 画带边角的正方形 drawCircle(2, 2, 48) 画圆 drawEllipse(5, 5, 90, 50) 画椭圆 drawSVGPath(svgPath) 画svg图 endFill() 结束填充颜色 closePath() 闭合路径 addTo() 添加到舞台或容器中 7、DOMElement dom元素封装 var content = &quot;Hello World! Hilo是一款HTML5 2D游戏引擎，欢迎使用。&quot;; var rect = new Hilo.DOMElement({ id: 'rect', element: Hilo.createElement('div', { // 创建元素 innerHTML: content, // 设置文本内容 style: { // 设置样式 backgroundColor: '#004eff', position: 'absolute' } }), width: 100, // 宽高 height: 100, x: 50, // 初始位置 y: 70 }).addTo(stage); 8、Text 简单文本 var font = &quot;14px arial&quot;; var content = &quot;Hello World! Hilo是一款HTML5 2D游戏引擎，欢迎使用。&quot;; // 添加文本 var text = new Hilo.Text({ x: 40, y: 50, width: 250, height: 100, font: font, text: content, lineSpacing: 0, }).addTo(stage); 9、Sprite 创建精灵图 /******************* 创建（一条小鱼）精灵图 *******************/ var fish = new Hilo.Sprite({ frames: atlas.getSprite('fish'), x: Math.random()*stageWidth, // 随机位置 y: Math.random()*stageHeight, interval: 6, timeBased: false, loop: false, // 是否循环，默认true alpha:1, tint:Math.random()*0xffffff, pivotX:87, pivotY:63 }).addTo(stage); /***************** 创建多条运动的小鱼 *******************/ // 小鱼运动的范围 var maxX = stageWidth + 174; var maxY = stageHeight + 126; var minX = -174; var minY = -126; var num = 1; // 创建 5 条小鱼 while(num--){ var fish = new Hilo.Sprite({ frames: atlas.getSprite('fish'), x: Math.random()*stageWidth, y: Math.random()*stageHeight, rotation: Math.random()*360, interval: 6, onUpdate: function(){ // x 轴超出范围 if(this.x &gt; maxX){ this.x = minX; } else if(this.x &lt; minX){ this.x = maxX; } // y 轴超出范围 if(this.y &gt; maxY){ this.y = minY; } else if(this.y &lt; minY){ this.y = maxY; } // 小鱼运动 this.x += this.vx; this.y += this.vy; } }).addTo(stage); var speed = 2; // &gt; 0 向下 &lt; 0 向上 fish.vy = Math.sin(fish.rotation*Math.PI/180) * speed; // &gt; 0 向右 &lt; 0 向左 fish.vx = Math.cos(fish.rotation*Math.PI/180) * speed; } util 1、TextureAtlas 初始化精灵图 // 初始化精灵图 var atlas = new Hilo.TextureAtlas({ image: 'images/fish.png', // 大背景图 width: 174, height: 1512, frames: { frameWidth: 174, // 一个小图的宽 frameHeight: 126, // 一个小图的高 numFrames: 12 // 小图的个数 }, sprites: { // 从第一张到第七张图变化 fish: {from:0, to:7} } }); 2、Ticker 定时器 var ticker = new Hilo.Ticker(60); ticker.addTick(stage); ticker.start(); 3、drag 拖拽 // 创建一只小鱼的位图 var bmp = new Hilo.Bitmap({ image: 'images/fish.png', rect: [0, 0, 174, 126], x: container.x, y: container.y }).addTo(stage); // mix让view有拖拽功能 Hilo.util.copy(bmp, Hilo.drag); // 设置推拽范围 bmp.startDrag([0, 0, 300, 300]); // 拖拽事件 bmp.on(&quot;dragStart&quot;, function(e){ console.log(&quot;dragStart&quot;, e.detail.x, e.detail.y); }); bmp.on(&quot;dragEnd&quot;, function(e){ }); bmp.on(&quot;dragMove&quot;, function(e){ }); // 阻止默认事件 document.ontouchstart = function(e){ e.preventDefault(); } event 1、mouseevent (1) 目前支持 mousemove, mouseup, mousedown, mouseover, mouseout, 支持事件冒泡; (2) 可以通过 e.eventTarget 和 e.eventCurrentTarget 获得触发鼠标事件的对象; (3) 建议使用 Hilo.event.POINTER_START, Hilo.event.POINTER_MOVE, Hilo.event.POINTER_END，它在pc上对应 mousemove, mouseup, mousedonw, 在手机上对应 touchstart, touchmove, touchend; // 定义dom事件 stage.enableDOMEvent([Hilo.event.POINTER_START, Hilo.event.POINTER_MOVE, Hilo.event.POINTER_END]); // 绑定事件 container.on(Hilo.event.POINTER_START, function(e){ console.log(&quot;target:&quot; + e.eventTarget.id, &quot;, currentTarget:&quot; + e.eventCurrentTarget.id); }); container.on(Hilo.event.POINTER_MOVE, function(e){}); container.on(&quot;mouseout&quot;, function(e){}); container.on(&quot;mouseover&quot;, function(e){}); ","link":"https://h8396x.coding-pages.com/post/vYS74lEDr/"},{"title":"Hilo属性","content":"1、align 对齐方式9种 // 创建容器 // aligin对齐方式展示 // TL T TR L C R BL B BR for(var i in Hilo.align){ var text = new Hilo.Text({ width: 40, height: 40, textAlign: 'center', background: '#ccc', font: '24px Arial', align: Hilo.align[i], text: Hilo.align[i] }).addTo(container); text.on(Hilo.event.POINTER_START, function(){ console.log(this.text); }); } 2、background 背景色 // 单一背景色 view.background = &quot;#f96&quot;; // 渐变背景色 var gradient = stage.renderer.context.createLinearGradient(0, 0, 0, view.height); gradient.addColorStop(0, '#fc0'); gradient.addColorStop(0.5, '#ff0'); gradient.addColorStop(1.0, '#0f0'); view.background = gradient; 3、blendMode 混合模式 // 创建舞台、开启定时器、添加Bitmap背景 // stage允许的事件 stage.enableDOMEvent([Hilo.event.POINTER_START, Hilo.event.POINTER_MOVE, Hilo.event.POINTER_END]); // 创建旋转的小图 var bmp = new Hilo.Bitmap({ image: 'images/fish.png', rect: [0, 0, 174, 126], x: 162, y: 113, pivotX:60, // 原心 pivotY:60, blendMode:'destination-out', // 混合模式的方向 onUpdate:function(){ this.rotation ++; } }).addTo(stage); // 创建笔刷 brush = new Hilo.Graphics({ blendMode:'destination-out' }).addTo(stage); // 笔刷样式 brush.lineStyle(30, '#fff', 1, 'round', 'round'); // 这个不懂 ? var removeFill = function(brush){ brush._actions = brush._actions.filter(function(action){ console.log( action[0] ) if(action[0] === 'stroke' || action[0] === 'fill'){ return false; } return true; }); }; // 鼠标是否按下的标志 var isDown = false; // 鼠标按下 isDown = true; 笔刷开始移动 stage.on(Hilo.event.POINTER_START, function(e){ if(!isDown){ isDown = true; brush.moveTo(e.stageX, e.stageY); // 笔刷移动到起始点 } }); // 鼠标移动、笔刷移动 stage.on(Hilo.event.POINTER_MOVE, function(e){ if(isDown){ removeFill(brush); // 消除上次的笔刷 brush.lineTo(e.stageX, e.stageY); // 笔刷画线 brush.endFill(); // 结束填充 } }); // 鼠标抬起 isDown = false; stage.on(Hilo.event.POINTER_END, function(e){ isDown = false; }); 4、crossOrigin 跨域 var bmp = new Hilo.Bitmap({ image:'https://gw.alicdn.com/tfs/TB1iNtERXXXXXcBaXXXXXXXXXXX-600-600.png_200x200.jpg', crossOrigin:'Anonymous', y:300 }).addTo(stage); `注意：WebGL渲染方式下，图片跨域需要设置crossDomain头。Loader和Bitmap都可以加crossOrigin:'Anonymous'来设置跨域头。` 5、旋转属性 rotation: 45, // 旋转45度 6、屏幕自适应 // 基本宽高 var gameWidth = 1440; var gameHeight = 900; // 创建舞台 var stage = new Hilo.Stage({ renderType:'canvas', container: document.getElementById(&quot;game-container&quot;), width: gameWidth, height: gameHeight, scaleX:innerWidth/gameWidth, scaleY:innerHeight/gameHeight }); // 创建Ticker var ticker = new Hilo.Ticker(20); ticker.addTick(stage); ticker.start(); // 创建背景图 var bmp = new Hilo.Bitmap({ image: 'images/map.jpg', }).addTo(stage); // window自适应 window.onresize = function(){ stage.scaleX = innerWidth/gameWidth; stage.scaleY = innerHeight/gameHeight; stage.resize(gameWidth, gameHeight, true); }; ","link":"https://h8396x.coding-pages.com/post/1nm-GKUWj/"},{"title":"Hilo认识","content":"Hilo是阿里开发的一款游戏框架，这是摘要啊，Hilo是阿里开发的一款游戏框架，这是摘要啊，Hilo是阿里开发的一款游戏框架，这是摘要啊，Hilo是阿里开发的一款游戏框架，这是摘要啊，Hilo是阿里开发的一款游戏框架，这是摘要啊，Hilo是阿里开发的一款游戏框架，这是摘要啊，Hilo是阿里开发的一款游戏框架，这是摘要啊。 1、简介 Hilo是阿里开发的一款游戏框架 2、版本选择 amd cmd commonjs node、ES6语法 `import Sprite from '../js/Hilo/view/Sprite';` dragonbones flash kissy physics standalone 独立版本 `&lt;script src=&quot;hilo-standalone.js&quot;&gt;&lt;/script&gt;` 3、全部分类 core 核心 Class 类的创建 Hilo hilo核心方法 event 事件 EventMixin 事件相关 game 游戏相关 Camera 摄像机 Camera3d 3D虚拟摄像机 ParticleSystem 粒子系统 geom 几何学 Matrix 转换矩阵 loader 加载 LoadQueue 队列下载工具 media 媒体 HTMLAudio 声音播放模块 WebAudio 声音播放模块 WebSound 声音播放管理器 renderer 渲染 CanvasRenderer canvas渲染器 DOMRenderer dom+css3渲染器 WebGLRenderer webGl渲染器 Renderer 基类 tween tween类 Ease 缓动函数 Tween 缓动 util 工具 TextureAtlas 将许多小图合成大图，精灵图 Ticker 定时器，按指定帧运行 browser 浏览器相关 drag 拖拽相关 util 方法集 view 视图 Bitmap 位图图像 BitmapText 位图文本，，单行 Button 按钮 CacheMixin 缓存 Container 容器 DOMElement dom元素，复杂文本显示 Drawable 可绘制图像的包装 Graphics 创建矢量图形 Sprite 动画精灵 `Stage 舞台，hilo动画从创建一个state开始` Text 简单文本显示 View 可视化对象组件的基类 4、练习时踩的坑 (1)注意 Hilo.ClassName() 每个类的第一个字母要大写，否则会报错 XXX is not a constructor； (2)一定要将创建的对象添加到舞台 .addTo(stage) 或容器 .addTo(container) 中，不然会一片空白； (3)创建 Ticker 定时器后要将其他Class，比如舞台、容器等添加到ticker中； (4)一些后面使用的Class，需要添加到 Ticker 中的类，一定要在顶部声明； (5)可以将一些公用的属性，比如宽高等定义为全局变量； ","link":"https://h8396x.coding-pages.com/post/6u4goIsNo/"},{"title":"带网格的3D运动物体","content":"index.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } #canvasdiv{ width: 100%; height: 700px; background: black; /* margin: 20px auto; */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;canvasdiv&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 引入相关文件 --&gt; &lt;script src=&quot;./js-three/three.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js-three/Stats.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js-three/Tween.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入demo文件 --&gt; &lt;script src=&quot;./js-three/demo3.js&quot;&gt;&lt;/script&gt; threeDemo.js 文件 // 开始运动 threeStart(); function threeStart() { initThree(); initCamera(); initScene(); initLight(); initObject(); initGrid(); animation(); } // 1、初始化场景 var scene; function initScene() { scene = new THREE.Scene(); } // 2、初始化相机 var camera; function initCamera() { camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000); camera.position.x = 100; camera.position.y = 300; camera.position.z = 600; camera.up.x = 0; camera.up.y = 1; camera.up.z = 0; camera.lookAt({ x: 0, y: 0, z: 0 }); } // 3、初始化渲染器 var renderer; var stats; function initThree() { width = document.getElementById('canvasdiv').clientWidth; height = document.getElementById('canvasdiv').clientHeight; renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(width, height); document.getElementById('canvasdiv').appendChild(renderer.domElement); renderer.setClearColor(0x000000, 1.0); // 左上角 FPS：游戏流畅度/屏幕刷新率 MS：网络延迟 MB： stats = new Stats(); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; document.getElementById('canvasdiv').appendChild(stats.domElement); } // 4、实时渲染——运动 function animation() { renderer.render(scene, camera); requestAnimationFrame(animation); // 运动方式1 mesh.rotation.x += 0.01; mesh.rotation.y += 0.01; mesh.rotation.z += 0.01; // 运动方式2 // mesh.rotateX(-0.01); // mesh.rotateY(-0.01); // mesh.rotateZ(-0.01); } // 5、初始化灯光 var light; function initLight() { light = new THREE.AmbientLight(0xFF0000); light.position.set(100, 100, 200); scene.add(light); } // 6、绘制网格 function initGrid() { var grid = new THREE.GridHelper(1000, 50); grid.setColors(0x0000ff, 0x808080); scene.add(grid); } // 7、初始化3d几何正方形 var cube; var mesh; function initObject() { // 创建几何体 var geometry = new THREE.BoxGeometry(100, 100, 100); for (var i = 0; i &lt; geometry.faces.length; i += 2) { var hex = Math.random() * 0xffffff; // 六个面随机颜色 geometry.faces[i].color.setHex(hex); geometry.faces[i + 1].color.setHex(hex); } // 材料 var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors }); // 几何体和材料合成 mesh = new THREE.Mesh(geometry, material); mesh.position = new THREE.Vector3(0, 0, 0); scene.add(mesh); } ","link":"https://h8396x.coding-pages.com/post/3b4-6lcb_/"},{"title":"canvas做纹理图","content":"index.html文件 &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvasdiv{ width: 80%; height: 600px; background: black; margin: 20px auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;canvasdiv&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script src=&quot;./js-three/three.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js-three/clock.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js-three/threedemo.js&quot;&gt;&lt;/script&gt; clock.js 文件 var canvas; function clock() { canvas = document.createElement('canvas'); canvas.width = 200; canvas.height = 200; var ctx = canvas.getContext('2d'); if (ctx) { var timerId; var frameRate = 60; function canvObject() { this.x = 0; this.y = 0; this.rotation = 0; this.borderWidth = 2; this.borderColor = '#000000'; this.fill = false; this.fillColor = '#ff0000'; this.update = function () { if (!this.ctx) throw new Error('你没有指定ctx对象。'); var ctx = this.ctx ctx.save(); ctx.lineWidth = this.borderWidth; ctx.strokeStyle = this.borderColor; ctx.fillStyle = this.fillColor; ctx.translate(this.x, this.y); if (this.rotation) ctx.rotate(this.rotation * Math.PI / 180); if (this.draw) this.draw(ctx); if (this.fill) ctx.fill(); ctx.stroke(); ctx.restore(); } }; function Line() {}; Line.prototype = new canvObject(); Line.prototype.fill = false; Line.prototype.start = [0, 0]; Line.prototype.end = [5, 5]; Line.prototype.draw = function (ctx) { ctx.beginPath(); ctx.moveTo.apply(ctx, this.start); ctx.lineTo.apply(ctx, this.end); ctx.closePath(); }; function Circle() {}; Circle.prototype = new canvObject(); Circle.prototype.draw = function (ctx) { ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, 2 * Math.PI, true); ctx.closePath(); }; var circle = new Circle(); circle.ctx = ctx; circle.x = 100; circle.y = 100; circle.radius = 90; circle.fill = true; circle.borderWidth = 6; circle.fillColor = '#ffffff'; var hour = new Line(); hour.ctx = ctx; hour.x = 100; hour.y = 100; hour.borderColor = &quot;#000000&quot;; hour.borderWidth = 10; hour.rotation = 0; hour.start = [0, 20]; hour.end = [0, -50]; var minute = new Line(); minute.ctx = ctx; minute.x = 100; minute.y = 100; minute.borderColor = &quot;#333333&quot;; minute.borderWidth = 7; minute.rotation = 0; minute.start = [0, 20]; minute.end = [0, -70]; var seconds = new Line(); seconds.ctx = ctx; seconds.x = 100; seconds.y = 100; seconds.borderColor = &quot;#ff0000&quot;; seconds.borderWidth = 4; seconds.rotation = 0; seconds.start = [0, 20]; seconds.end = [0, -80]; var center = new Circle(); center.ctx = ctx; center.x = 100; center.y = 100; center.radius = 5; center.fill = true; center.borderColor = 'orange'; for (var i = 0, ls = [], cache; i &lt; 12; i++) { cache = ls[i] = new Line(); cache.ctx = ctx; cache.x = 100; cache.y = 100; cache.borderColor = &quot;orange&quot;; cache.borderWidth = 2; cache.rotation = i * 30; cache.start = [0, -70]; cache.end = [0, -80]; } timerId = setInterval(function () { // 清除画布 ctx.clearRect(0, 0, 200, 200); // 填充背景色 ctx.fillStyle = 'orange'; ctx.fillRect(0, 0, 200, 200); // 表盘 circle.update(); // 刻度 for (var i = 0; cache = ls[i++];) cache.update(); // 时针 hour.rotation = (new Date()).getHours() * 30; hour.update(); // 分针 minute.rotation = (new Date()).getMinutes() * 6; minute.update(); // 秒针 seconds.rotation = (new Date()).getSeconds() * 6; seconds.update(); // 中心圆 center.update(); }, (1000 / frameRate) | 0); } else { alert('您的浏览器不支持Canvas无法预览.\\n跟我一起说：&quot;Fuck Internet Exploer!&quot;'); } } threedemo.js 文件 /* 1、初始化场景、相机、渲染器 2、实时渲染 3、canvas做纹理图 (1)在canvas上画时钟 (2)将canvas传递给Texture纹理 (3)创建几何体，并将纹理传递给材质 (4)构造THREE.Mesh */ var scene; var camera; var renderer; var width = document.getElementById('canvasdiv').clientWidth; var height = document.getElementById('canvasdiv').clientHeight; // 开始执行 threeStart(); function threeStart() { clock(); // (1)先执行canvas绘制的图片 init(); initCanvas(); animate(); } // 1、初始化场景、相机、渲染器 function init() { scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000); camera.position.z = 10; renderer = new THREE.WebGLRenderer({}); renderer.setSize(width, height); document.getElementById('canvasdiv').appendChild(renderer.domElement); } // 2、实时渲染 function animate() { renderer.render(scene, camera); requestAnimationFrame(animate); // 使物体运动 texture.needsUpdate = true; mesh.rotation.x -= 0.01; mesh.rotation.y -= 0.01; } // 3、画纹理物体 var texture; var mesh; function initCanvas() { // (2)将canvas传递给Texture纹理 texture = new THREE.Texture(canvas); texture.needsUpdate = true; // (3)创建几何体，将纹理传递给材质 var geometry = new THREE.BoxGeometry(2, 2, 2); var material = new THREE.MeshBasicMaterial({map:texture}); // (4)构造THREE.Mesh mesh = new THREE.Mesh( geometry,material ); scene.add( mesh ); } ","link":"https://h8396x.coding-pages.com/post/fwASOYUgY/"},{"title":"three.js画有纹理的物体","content":"/* 1、初始化场景 2、初始化相机 3、初始化渲染器 4、实时渲染 5、画有纹理的物体 (1)画平面，并赋予纹理坐标； (2)加载纹理； (3)将纹理用于材质； */ var scene; // 场景 var camera; // 相机 var renderer; // 渲染器 var width = document.getElementById('canvasdiv').clientWidth; var height = document.getElementById('canvasdiv').clientHeight; // 开始执行 threeStart(); function threeStart() { initScene(); // 初始化场景 initCamera(); // 初始化相机 initRender(); // 初始化渲染器 initRect(); // 加载纹理图 render(); // 循环动画 } // 1、场景 function initScene() { scene = new THREE.Scene(); } // 2、相机 function initCamera() { camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000); camera.position.x = 0; camera.position.y = 0; camera.position.z = 10; } // 3、渲染器 function initRender() { renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(width, height); document.getElementById('canvasdiv').appendChild(renderer.domElement); renderer.setClearColor(0x000000, 0.6); } // 4、实时渲染 function render() { renderer.clear(); renderer.render(scene, camera); // requestAnimationFrame(render); } // 5、画纹理物体 function initRect() { // 画平面 var geo = new THREE.PlaneGeometry(500, 400, 1, 1); // 纹理坐标 geo.vertices[0].uv = new THREE.Vector2(0,0); geo.vertices[1].uv = new THREE.Vector2(2,0); geo.vertices[2].uv = new THREE.Vector2(2,2); geo.vertices[3].uv = new THREE.Vector2(0,2); // 加载纹理 var texture = THREE.ImageUtils.loadTexture(&quot;./img/aaa.jpg&quot;, null, function (t) { // 有跨域问题 }); // 将纹理应用于材质 var material = new THREE.MeshBasicMaterial({ map: texture }) var mesh = new THREE.Mesh(geo, material); scene.add(mesh); } ","link":"https://h8396x.coding-pages.com/post/AHRCUdv2t/"},{"title":"three.js简单示例","content":"/* 使用相机将场景渲染到网页上 1、初始化场景 2、初始化相机 3、初始化渲染器 4、实时渲染 5、初始化光源 6、画正方体并在 实时渲染 中使物体运动 7、画渐变线条 实时渲染 中使物体运动 */ var scene; // 场景 var camera; // 相机 var renderer; // 渲染器 var width = document.getElementById('canvasdiv').clientWidth; var height = document.getElementById('canvasdiv').clientHeight; // 0、开始执行 threeStart(); function threeStart() { // 注意内部函数执行的顺序 initScene(); // 初始化场景 initCamera(); // 初始化相机 initRender(); // 初始化渲染器 initLight(); // 创建光源 initRect(); // 画正方形 initLine(); // 画线 render(); // 循环动画 } // 1、初始化场景————所有物体的容器 function initScene() { scene = new THREE.Scene(); } // 2、初始化相机————决定那个角度场景的展示 function initCamera() { camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000); camera.position.x = 0; // 初始X位置：负值物体偏右，正值物体偏左 camera.position.y = 0; // 初始Y位置：负值物体偏上，正值物体偏下 camera.position.z = 10; // 初始Z位置：负值物体靠前，正值物体靠后 } // 3、初始化渲染器 function initRender() { renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(width, height); // 设置渲染器的宽高、颜色、透明度，并添加到dom中 document.getElementById('canvasdiv').appendChild(renderer.domElement); renderer.setClearColor(0x000000, 0.6); } // 4、实时渲染 == 循环渲染 function render() { renderer.clear(); renderer.render(scene, camera); // 渲染(场景，相机，目标，清除上次画布内容) requestAnimationFrame(render); // 游戏循环：让浏览器去执行一次参数中的函数 // 改变物体位置，让物体运动 cube.rotation.x += 0.02; cube.rotation.y += 0.02; if( line.position.x &gt; 3 ){ line.position.x = 0.005; line.position.y = 0.005; }else{ line.position.x += 0.005; line.position.y += 0.005; } // 改变相机位置，让物体运动 // camera.position.x += 0.01; } // 5、初始化光源(基类光源+5类) var light; function initLight() { // (0)基类光 new Light() // (1)环境光 /* light = new THREE.AmbientLight(0xffff00); light.position.set(-1, -1, 2); scene.add(light); */ // (2)点光源 light = new THREE.PointLight(0xffff00); light.position.set(-1, -1, 2); scene.add(light); // (3)聚光灯 /* light = new THREE.SpotLight(0xffff00); light.position.set(-1, -1, 2); scene.add(light); */ // (4)方向光 /* light = new THREE.DirectionalLight(0xffff00); light.position.set(-1, -1, 2); scene.add(light); */ // (4)区域光 —— 有问题 /* light = new THREE.AreaLight(0xffff00); light.position.set(-1, -1, 2); scene.add(light); */ } // 6、初始化几何正方体 var cube; function initRect() { var geometry = new THREE.BoxGeometry(1, 1, 1); // 几何体的长宽高 var material = new THREE.MeshLambertMaterial({ // 属性样式 MeshBasicMaterial color: 0x00ffff }); cube = new THREE.Mesh(geometry, material); scene.add(cube); } // 7、初始化一条渐变的线条 var line; function initLine() { var geometry = new THREE.Geometry(); var material = new THREE.LineBasicMaterial({ vertexColors: true, // 是否使用顶点颜色 linewidth: 50 // 线条宽度 }); // 创建两点 var p1 = new THREE.Vector3( -2, 2, 0 ); var p2 = new THREE.Vector3( 2, -2, 0 ); geometry.vertices.push(p1); geometry.vertices.push(p2); // 创建两点颜色 var color1 = new THREE.Color( 0x0000ff ), color2 = new THREE.Color( 0xff00ff ); geometry.colors.push( color1, color2 ); // 连线 line = new THREE.Line( geometry, material, THREE.LinePieces ); scene.add(line); } ","link":"https://h8396x.coding-pages.com/post/H4FS428MO/"},{"title":"Flex布局","content":"一、基本知识点 1、px : 像素, 逻辑像素 相对单位, 抽象的单位长度 2、dp : 在参数中, 显示的是物理像素, 实际的单位长度, 设备无关像素 3、dpr: 设备像素缩放比 1px = dpr^2*dp 4、屏幕像素密度ppi: 屏幕每英寸像素数量 5、ppi = 屏幕对角线长度 / 屏幕英寸 例 iPhone5：ppi = sqrt(11361136 + 640640)/4 布局 //html &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4&lt;/div&gt; &lt;/div&gt; .container{ /* 将container变成弹性盒子 */ display: flex; } 二、容器属性（.container） 1、主轴方向 flex-direction: row（默认） 按照主轴开始位置排列 row-reverse 按照主轴结束位置排列 column 按照交叉轴开始位置排列 column-reverse 按照交叉轴结束位置排列 2、换行 flex-wrap： wrap 超过contain盒子的宽度后强制换行 nowrap 不换行 wrap-reverse 换行后翻转，第一行在下面 3、主轴方向+换行(值1:方向 值2: 换行) flex-flow: row wrap-reverse; 4、主轴对齐方式 justify-content flex-start 按照主轴开始的位置对齐 flex-end 按照主轴结束的位置对齐 center 按照主轴中心的位置对齐 space-between 按照主轴, 两端对齐 , 间隔相同 space-around 主轴方向, 每个项目的左右间隔相同 5、交叉轴对齐方式 align-items： flex-start 交叉轴开始位置对齐 flex-end 交叉轴结束位置对齐 center 交叉轴水平位置对齐 baseline 交叉轴基线位置对齐 stretch 如果没有高度或者高度自动，自动撑满整个容器 6、主轴方向+对齐方式 7、多根轴线对齐(强制换行) 盒子不换行默认一条轴线排列,不会产生第二根基线。设置多根轴线无作用 盒子换行：出现多根轴线对齐（按每一根轴线的...对齐） 三、项目属性（.box） 1、项目的顺序 —— order /*默认从左到右都是0 数越小, 越靠前*/ .box:nth-child(3){ order: 1; } .box:nth-child(2){ order: 5; } 2、项目的放大 —— flex-grow /* * 项目的放大比例 ———— flew-grow * 默认为0, 即使存在剩余空间也不会放大 * 不能设置负数 * 也不要设置小数 */ .box:nth-child(3){ flex-grow: 3; } 3、项目的缩小 —— flex-shrink /* * 项目的缩小比例 * 默认值为1, 如果剩余空间不足, 项目会缩小 * 设置为0 , 不会缩小 * 不能设置负数 * 也不要设置小数 */ .box:nth-child(2){ order: 0.5; flex-shrink: 0; } 4、项目的主轴空间大小 —— flex-basis /* * 主轴空间大小 * 定义在分配主轴空间之前，项目占据主轴空间， * 浏览器根据当前属性，计算主轴是否有多余空间 * * 宽度固定 */ .box:nth-child(3){ flex-basis: 300px; /*flex-shrink: 0;*/ } 附、一个盒子九宫格位置 .container{ width: 400px; height: 400px; border: 3px solid black; /* 将container变成弹性盒子 */ display: flex; /* 位置1 */ justify-content: flex-start; /* 位置2 主轴方向-居中对齐*/ justify-content: center; /* 位置3 主轴方向-结束位置对齐*/ justify-content: flex-end; /* 位置4 主轴方向-结束位置对齐* justify-content: flex-start; align-items: center; /* 位置5 主轴方向-结束位置对齐*/ justify-content: center; align-items: center; /* 位置6 主轴方向-结束位置对齐*/ justify-content: flex-end; align-items: center; /* 位置7 主轴方向-结束位置对齐*/ /*flex-direction: column; align-items: flex-start;*/ justify-content: flex-start; align-items: flex-end; /* 位置8 主轴方向-结束位置对齐*/ /*flex-direction: column; align-items: center;*/ justify-content: center; align-items: flex-end; /* 位置9 主轴方向-结束位置对齐*/ /*flex-direction: column; align-items: flex-end;*/ justify-content: flex-end; align-items: flex-end; } ","link":"https://h8396x.coding-pages.com/post/FG-Gnele2/"},{"title":"rem、移动端事件、html加载","content":"一、rem、em、px的关系 1、什么是rem？ css3新的单位。 @media 根据此设置可以根据屏幕宽度设置html的字体大小,从而改变其他元素的字体大小宽度高度等属性 JS设置视口宽度 ：document.documentElement.style.fontSize=&quot;20px&quot;; (html.style.fontSize) 2、三种单位 px,依赖的分辨率 em,相对长度单位,检测父级元素字体大小，依赖父级元素字体进行设置 rem,相对长度单位，检测root根元素字体大小，依赖html设置 3、rem和em的区别？ 都是相对长度 都是检测字体大小 rem 根据根元素字体大小 ( html{font-size:20px;} ) em 根据父元素字体大小 二、移动端事件 1、屏幕方向改变事件 orientationchange window.addEventListener(&quot;orientationchange&quot;,function(){ alert(&quot;我方向发生改变啦！&quot;); }) 2、窗口尺寸发生变化，触发 window.addEventListener(&quot;resize&quot;,function(){ alert(&quot;我改变啦！&quot;) }) 3、DOM节点加载完成，触发该事件 window.addEventListener(&quot;DOMContentLoaded&quot;,function(){ alert(&quot;DOM节点加载完成！&quot;); }) 4、获得视口宽度 因为在视口标签中设置了，视口宽度等于设备宽度 document.documentElement.clientWidth得到设备实际宽度 三、html加载顺序 1、解析HTML结构 2、加载外部文件 3、执行脚本代码 4、DOM树构建完成 --- DOMContentLoaded 5、加载图片等外部资源 6、页面加载完毕 --- load 四、js动态获取视口宽度,同时设置html的字体大小 功能：根据不同型号的手机，设置不同的html的font-size 设置两个形参，doc为document win为window (function(doc,win){ var remCale = function(){ //获取视口宽度 var clientWidth = doc.documentElement.clientWidth; //UI给的设计稿通常都是320px，或者640px //设置字体大小 1rem=100px 320px设计稿 doc.documentElement.style.fontSize=(clientWidth/320)*100*&quot;px&quot;; } //在文档最先加载完成的时候，触发remCale doc.addEventListener(&quot;DOMContentLoaded&quot;,remCale); //翻转手机，或改变浏览器宽度的时候，触发remCale win.addEventListener(&quot;resize&quot;,remCale); win.addEventListener(&quot;orientationchange&quot;,remCale); })(document,window) ","link":"https://h8396x.coding-pages.com/post/TX7tVZfv7/"},{"title":"video和audio","content":"一、音频(audio) 视频(video) &lt;audio src=&quot;media/loveyou.ogg&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;&lt;/audio&gt; &lt;video src=&quot;video/浮夸.mp4&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot;&gt;&lt;/video&gt; 二、video属性 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 &quot;autoplay&quot;，则忽略该属性。 height：pixels 设置视频播放器的高度。 width ：pixels 设置视频播放器的宽度。 src：url 要播放的视频的 URL。 三、方法和事件 方法 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 事件 abort 当音频/视频的加载已放弃时 canplay 当浏览器可以播放音频/视频时 canplaythrough 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange 当音频/视频的时长已更改时 emptied 当目前的播放列表为空时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 loadeddata 当浏览器已加载音频/视频的当前帧时 loadedmetadata 当浏览器已加载音频/视频的元数据时 loadstart 当浏览器开始查找音频/视频时 pause 当音频/视频已暂停时 play 当音频/视频已开始或不再暂停时 playing 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress 当浏览器正在下载音频/视频时 ","link":"https://h8396x.coding-pages.com/post/v97vQ_PM9/"},{"title":"canvas画图","content":"Canvas和SVG的区别？ 位图和矢量图的区别 位图色彩更丰富， 矢量图色彩较单一，经常做图标 &lt;!-- canvas 点击鼠标右键，出现图片另存为 --&gt; &lt;!-- canvas 只能写在标签内，不能放在CSS样式中 --&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500px&quot; height=&quot;400px&quot;&gt;&lt;/canvas&gt; 一、画线 //1、获取 canvas元素 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //2、获取上下文：简单理解，把canvas画布变成2D画板。 WebGL：3D画板 var ctx = myCanvas.getContext(&quot;2d&quot;); //3、设置样式 ctx.lineWidth = 10; ctx.strokeStyle = &quot;greenyellow&quot;; //4、移动至某一点 ctx.moveTo(100,100); //5、创建一个新点 两个操作，移动到这个点，连接前一个点 ctx.lineTo(100,200); ctx.lineTo(100,350); ctx.lineTo(300,350); ctx.lineTo(300,100); //6、画线 ctx.stroke(); //7、画另一条线 ctx.moveTo(200,300); ctx.lineTo(200,100); ctx.lineTo(200,100); ctx.lineTo(400,50); ctx.stroke(); 二、画矩形 //前两部相同 //3、x,y：矩形的起点 width,height:矩形的宽高 ctx.fillStyle = &quot;red&quot;; ctx.fillRect(50,50,100,50); ctx.rect(200,50,100,50); ctx.fillStyle = &quot;aqua&quot;; ctx.fill(); ctx.rect(50,200,100,50); ctx.stroke(); ctx.strokeStyle = &quot;blueviolet&quot;; ctx.strokeRect(200,200,100,50); 三、写字 //3、设置样式 ctx.font = &quot;50px 微软雅黑&quot;; ctx.strokeStyle = &quot;gold&quot;; //4、参数一：文字内容 参数二：文字显示的坐标 //爬虫爬取不到canvas的文本内容 ctx.fillText(&quot;秦时明月之君临天下&quot;,20,100); ctx.strokeText(&quot;秦时明月汉时关&quot;,80,200); 四、画圆 /*3、参数一二：圆心坐标 * 参数三 ：半径 * 参数四五：圆的起始和结束弧度 * 参数六 是否逆时针 ：默认 false————顺时针 * */ ctx.arc(300,300,100,0,360,false); ctx.fillStyle = &quot;chartreuse&quot;; ctx.fill(); ctx.arc(100,100,100,0,360,false); ctx.stroke(); 五、画弧线、扇形 /* * 角度和弧度的转化 2π = 360(弧度) π = 180 * Math.PI / 180 * n */ ctx.arc(300,300,80,0,3.14,false); ctx.fillStyle = &quot;chartreuse&quot;; ctx.fill(); //解决路径闭合问题：方法一：下一个圆的圆心+半径 方法二：关闭路径 ctx.moveTo(180,100); //可注释后查看效果 ctx.arc(100,100,80,0,3.14,false); ctx.stroke(); 注意：画扇形，需要moveTo(原点，原点); 六、线性渐变 //填充渐变颜色 var gradient = ctx.createLinearGradient(0,0,500,400); //参数一：颜色位置 0~1 之间； 参数二：颜色值 gradient.addColorStop(0,&quot;red&quot;); gradient.addColorStop(0.3,&quot;orange&quot;); gradient.addColorStop(1/2,&quot;green&quot;); //注意：可以是分号 gradient.addColorStop(0.8,&quot;yellow&quot;); gradient.addColorStop(1,&quot;purple&quot;); //设置样式——填充渐变色 ctx.fillStyle = gradient; //画个矩形等 ctx.fillRect(0,0,500,400); 七、经向渐变 //填充渐变颜色 var gradient = ctx.createRadialGradient(200,200,50,200,200,200); //参数一：颜色位置 0~1 之间；参数二：颜色值 gradient.addColorStop(0,&quot;red&quot;); gradient.addColorStop(0.2,&quot;orange&quot;); gradient.addColorStop(0.4,&quot;yellow&quot;); gradient.addColorStop(0.6,&quot;green&quot;); gradient.addColorStop(0.8,&quot;yellow&quot;); gradient.addColorStop(1,&quot;purple&quot;); //设置样式——填充渐变色 ctx.fillStyle = gradient; //画个矩形等 ctx.arc(200,200,200,0,360); ctx.fill(); 八、放入图片 //可以用canvas做截图 //创建图像位置 var img = new Image(); img.src = &quot;img/354279.jpg&quot;; img.onload = function(){ //参数1：放入img对象 //参数2,3：图片的开始位置 //参数4,5：图片的变形 宽度和高度 ctx.drawImage(img,10,10,480,380); } 九、路径闭合问题解决方法二 //用beginPath()和closePath()方法，开始、关闭路径 ctx.beginPath(); ctx.arc(100,100,100,0,360,false); ctx.fillStyle = &quot;red&quot;; ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.arc(300,300,100,0,360,false); ctx.fillStyle = &quot;chartreuse&quot;; ctx.fill(); ctx.closePath(); ## 十、其他应用 画太极图（遍历数组对象，拿到对应的数值做参数，画到Canvas画布上） 数据可视化 扇形（方法同上） 用百度Echarts做更多美观图表 Canvas截屏 Canvas小窗口播放视屏 //核心代码 加定时器小视屏播放；不加定时器截屏 setInterval(function(){ ctx.drawImage( $(&quot;#video&quot;)[0] , 0 , 0 , 400 , 300); },100); ","link":"https://h8396x.coding-pages.com/post/Edy0Tafct/"},{"title":"上传头像的三种方法","content":"一、form表单上传文件(原生JS) 1、HTML部分 &lt;img id=&quot;img-box&quot; style=&quot;border: 1px solid gray; width: 100px; height: 100px;&quot; src=&quot;&quot;/&gt; &lt;form action=&quot;http://192.168.0.3/project/artist-v2/api/index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;m&quot; id=&quot;m&quot; value=&quot;user&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;a&quot; id=&quot;a&quot; value=&quot;changeHeadImage&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;userId&quot; id=&quot;userId&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;newHeadImage&quot; id=&quot;newHeadImage&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; 2、JS部分 &lt;script type=&quot;text/javascript&quot;&gt; var tag = document.querySelector(&quot;#newHeadImage&quot;); tag.addEventListener(&quot;change&quot;,function(){ //1、input file类型的标签中, 所有的文件放在files属性中, 这个属性是个数组 if(tag.files.length == 0){ alert(&quot;没有选择图片&quot;) return } var uploadFile = tag.files[0]; //2、从文件对象获取本地路径src var src = window.URL.createObjectURL(uploadFile) //3、显示图片 var imgBox = document.getElementById(&quot;img-box&quot;) imgBox.src = src; }) &lt;/script&gt; 二、jQuery+post上传头像 1、HTML部分 &lt;div&gt; &lt;img id=&quot;img-box&quot; style=&quot;border: 1px solid gray; width: 100px; height: 100px;&quot; src=&quot;&quot;/&gt; &lt;input type=&quot;file&quot; name=&quot;newHeadImage&quot; id=&quot;newHeadImage&quot; value=&quot;&quot; /&gt; &lt;input class=&quot;upload-file&quot; type=&quot;button&quot; value=&quot;上传头像&quot;/&gt; &lt;/div&gt; 2、jQuery实现 &lt;!-- 引入jQuery文件 --&gt; &lt;script src=&quot;jquery-1.9.1.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- 引入接口文件 --&gt; &lt;script src=&quot;interface.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //选择图片的处理 var tag = document.querySelector(&quot;#newHeadImage&quot;); tag.addEventListener(&quot;change&quot;,function(){ //1、获取选择的文件,图片 if(tag.files.length == 0){ alert(&quot;没有选择图片&quot;) return } var uploadFile = tag.files[0]; //2、从文件对象获取本地路径src var src = window.URL.createObjectURL(uploadFile); //3、显示图片 var imgBox = document.getElementById(&quot;img-box&quot;) imgBox.src = src; }) //确认更换头像的事件处理 $(&quot;.upload-file&quot;).click(function () { //1、获取图片输入框 var tag = document.getElementById(&quot;newHeadImage&quot;); //2、获取选择的文件,图片 //input file类型的标签中, 所有的文件放在files属性中, 这个属性是个数组 if(tag.files.length == 0){ alert(&quot;没有选择图片&quot;) return } var uploadFile = tag.files[0]; //C.生成FormData. 生成了form表单 var formData = new FormData(); formData.append(&quot;m&quot;,&quot;user&quot;) formData.append(&quot;a&quot;,&quot;changeHeadImage&quot;) formData.append(&quot;userId&quot;,&quot;1&quot;) formData.append(&quot;newHeadImage&quot;,uploadFile); //D.发起post请求 vue: this.$http.post() $.ajax({ type:&quot;post&quot;, url:changeHeadImageUrl, async:true, data:formData, //processData为真, 数据转化为字符串传递 上传文件, 设置为false processData:false, contentType:false }).done(function (r) { alert(r) }); }) &lt;/script&gt; 三、vue+post上传头像 1、HTML部分 &lt;!--view--&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;img class=&quot;head-image&quot; v-bind:src=&quot;src&quot;/&gt;&lt;br&gt; &lt;input id=&quot;headImageTag&quot; type=&quot;file&quot; v-on:change=&quot;dealChange&quot; multiple=&quot;multiple&quot;/&gt; &lt;/div&gt; &lt;div&gt; &lt;button v-on:click=&quot;dealUploadImage&quot;&gt;修改头像&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 2、Vue部分 &lt;!-- 引入vue文件 --&gt; &lt;script src=&quot;vue/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue/vue-resource.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue/vue-router.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- 引入接口文件 --&gt; &lt;script src=&quot;interface.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //model var data = { src:&quot;&quot; } //ViewModel var app = new Vue({ el:&quot;#app&quot;, data:data, methods:{ dealUploadImage:function(){ //1、获取图片输入框 var tag = document.getElementById(&quot;headImageTag&quot;); //2、获取选择的文件,图片 if(tag.files.length == 0){ alert(&quot;没有选择图片&quot;) return } var uploadFile = tag.files[0]; //3、生成FormData. 生成了form表单 var formData = new FormData(); formData.append(&quot;m&quot;,&quot;user&quot;) formData.append(&quot;a&quot;,&quot;changeHeadImage&quot;) formData.append(&quot;userId&quot;,&quot;1&quot;) formData.append(&quot;newHeadImage&quot;,uploadFile); //D.发起post请求 var url = changeHeadImageUrl; this.$http.post(url,formData,function () { }).then(function (r) { var jsonObject = r.data; }) }, dealChange:function(){ //1、获取图片输入框 var tag = document.getElementById(&quot;headImageTag&quot;); //2、获取选择的文件,图片 if(tag.files.length == 0){ alert(&quot;没有选择图片&quot;) return } var uploadFile = tag.files[0]; //3、从文件对象获取本地路径src var src = window.URL.createObjectURL(uploadFile) //4、显示图片 this.src = src } } }); &lt;/script&gt; ","link":"https://h8396x.coding-pages.com/post/ztoZkzceQ/"},{"title":"JS常用API合集","content":"一、节点 1.1 节点属性 Node.nodeName //返回节点名称，只读 Node.nodeType //返回节点类型的常数值，只读 Node.nodeValue //返回Text或Comment节点的文本值，只读 Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写 Node.baseURI //返回当前网页的绝对路径 Node.ownerDocument //返回当前节点所在的顶层文档对象，即document Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点 Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点 Node.parentNode //返回当前节点的父节点 Node.parentElement //返回当前节点的父Element节点 Node.childNodes //返回当前节点的所有子节点 Node.firstChild //返回当前节点的第一个子节点 Node.lastChild //返回当前节点的最后一个子节点 //parentNode接口 Node.children //返回指定节点的所有Element子节点 Node.firstElementChild //返回当前节点的第一个Element子节点 Node.lastElementChild //返回当前节点的最后一个Element子节点 Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作 Node.appendChild(node) //向节点添加最后一个子节点 Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点 Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代) Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点 Node.removeChild(node) //删除节点，在要删除节点的父节点上操作 Node.replaceChild(newChild,oldChild) //替换节点 Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。 Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系 Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。 //ChildNode接口 Node.remove() //用于删除当前节点 Node.before() // Node.after() Node.replaceWith() 1.3 Document节点 1.3.1 Document节点的属性 document.doctype // document.documentElement //返回当前文档的根节点 document.defaultView //返回document对象所在的window对象 document.body //返回当前文档的&lt;body&gt;节点 document.head //返回当前文档的&lt;head&gt;节点 document.activeElement //返回当前文档中获得焦点的那个元素。 //节点集合属性 document.links //返回当前文档的所有a元素 document.forms //返回页面中所有表单元素 document.images //返回页面中所有图片元素 document.embeds //返回网页中所有嵌入对象 document.scripts //返回当前文档的所有脚本 document.styleSheets //返回当前网页的所有样式表 //文档信息属性 document.documentURI //表示当前文档的网址 document.URL //返回当前文档的网址 document.domain //返回当前文档的域名 document.lastModified //返回当前文档最后修改的时间戳 document.location //返回location对象，提供当前文档的URL信息 document.referrer //返回当前文档的访问来源 document.title //返回当前文档的标题 document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。 document.readyState //返回当前文档的状态 document.designMode //控制当前文档是否可编辑，可读写 document.compatMode //返回浏览器处理文档的模式 document.cookie //用来操作Cookie 1.3.2 Document节点的方法 （1）读写方法 document.open() //用于新建并打开一个文档 document.close() //不安比open方法所新建的文档 document.write() //用于向当前文档写入内容 document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。 document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。 document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素 document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素 document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等） document.getElementById(id) //返回匹配指定id属性的元素节点。 document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 （3）生成节点 document.createElement(tagName) //用来生成HTML元素节点。 document.createTextNode(text) //用来生成文本节点 document.createAttribute(name) //生成一个新的属性对象节点，并返回它。 document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用 document.addEventListener(type,listener,capture) //注册事件 document.removeEventListener(type,listener,capture) //注销事件 document.dispatchEvent(event) //触发事件 （5）其他 document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。 document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element节点 1.4.1 Element节点的属性 （1）特性属性 Element.attributes //返回当前元素节点的所有属性节点 Element.id //返回指定元素的id属性，可读写 Element.tagName //返回指定元素的大写标签名 Element.innerHTML //返回该元素包含的HTML代码，可读写 Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写 Element.className //返回当前元素的class属性，可读写 Element.classList //返回当前元素节点的所有class集合 Element.dataset //返回元素节点中所有的data-*属性。 （2）尺寸属性 Element.clientHeight //返回元素节点可见部分的高度 Element.clientWidth //返回元素节点可见部分的宽度 Element.clientLeft //返回元素节点左边框的宽度 Element.clientTop //返回元素节点顶部边框的宽度 Element.scrollHeight //返回元素节点的总高度 Element.scrollWidth //返回元素节点的总宽度 Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置 Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值 Element.offsetHeight //返回元素的垂直高度(包含border,padding) Element.offsetWidth //返回元素的水平宽度(包含border,padding) Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移 Element.offsetTop //返回水平位移 Element.style //返回元素节点的行内样式 （3）节点相关属性 Element.children //包括当前元素节点的所有子元素 Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数 Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点 Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点 Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 （1）位置方法 getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高 // top 元素上外边界距窗口最上面的距离 // right 元素右外边界距窗口最上面的距离 // bottom 元素下外边界距窗口最上面的距离 // left 元素左外边界距窗口最上面的距离 // width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。 // 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return { top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft } （2）属性方法 Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 （3）查找方法 Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() （4）事件方法 Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件 //ie8 Element.attachEvent(oneventName,listener) Element.detachEvent(oneventName,listener) // event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement; // 事件代理 ul.addEventListener('click', function(event) { if (event.target.tagName.toLowerCase() === 'li') { console.log(event.target.innerHTML) } }); （5）其他 Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域 //解析HTML字符串，然后将生成的节点插入DOM树的指定位置。 Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入 Element.remove() //用于将当前元素节点从DOM中移除 Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS操作 （1）类名操作 //ie8以下 Element.className //获取元素节点的类名 Element.className += ' ' + newClassName //新增一个类名 //判断是否有某个类名 function hasClass(element,className){ return new RegExp(className,'gi').test(element.className); } //移除class function removeClass(element,className){ element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),''); } //ie10 element.classList.add(className) //新增 element.classList.remove(className) //删除 element.classList.contains(className) //是否包含 element.classList.toggle(className) //toggle class （2）style操作 element.setAttribute('style','') element.style.backgroundColor = 'red' element.style.cssText //用来读写或删除整个style属性 element.style.setProperty(propertyName,value) //设置css属性 element.style.getPropertyValue(property) //获取css属性 element.style.removeProperty(property) //删除css属性 操作非内联样式 //ie8 element.currentStyle[attrName] //ie9+ window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName) //伪类 window.getComputedStyle(el,':after')[attrName] 三、对象 3.1 Object对象 （1）生成实例对象 var o = new Object() （2）属性 Object.prototype //返回原型对象 （3）方法 Object.keys(o) //遍历对象的可枚举属性 Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。 propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 （1）生成实例对象 var a = new Array() （2）属性 a.length //长度 （3）Array.isArray() Array.isArray(a) //用来判断一个值是否为数组 （4）Array实例的方法 a.valueof() //返回数组本身 a.toString() //返回数组的字符串形式 a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 pop() //用于删除数组的最后一个元素，并返回该元素 join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。 concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 shift() //用于删除数组的第一个元素，并返回该元素。 unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 reverse() //用于颠倒数组中元素的顺序，返回改变后的数组 slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。 splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。 map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。 forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。 filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。 reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员） reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员） indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3 Number对象 （1）生成对象 var n = new Number() （2）Number对象的属性 Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 （3）Number对象实例的方法 toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。 toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。 toPrecision() //用于将一个数转为指定位数的有效数字。 3.4 String 对象 （1）生成实例对象 var s = new String() （2）String对象的属性 s.length //返回字符串的长度 （3）方法 s.chatAt(index) //返回指定位置的字符 s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。 s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示） s.concat(s2) //用于连接两个字符串 s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。 s.trim() //用于去除字符串两端的空格，返回一个新字符串 s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。 s.toUpperCase() //全部转为大写 s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 （1）属性 Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 （2）数学方法 Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。 Math.exp()：返回e的指数，也就是常数e的参数次方。 Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 （3）三角函数方法 Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 //（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 //还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.warn() //输出信息时，在最前面加一个黄色三角，表示警告； console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈 console.table() //可以将复合类型的数据转为表格显示。 console.count() //用于计数，输出它被调用了多少次。 console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 console.dirxml() //用于以目录树的形式，显示DOM节点。 console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 //这两个方法用于计时，可以算出一个操作所花费的准确时间。 console.time() console.timeEnd() //time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。 console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。 console.profileEnd() //用来结束正在运行的性能测试器。 console.group() console.groupend() //上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace() //显示当前执行的代码在堆栈中的调用路径。 console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。 ","link":"https://h8396x.coding-pages.com/post/U6qkEG1rn/"},{"title":"jQuery中ajax","content":"ajax请求 $.get() 发起get请求(图片、html、xml、json) $.getJSON() 发起GET请求(数据必须为JSON) $.post() 发起post请求(上传头像、上传文件) $.ajax() 发起GET/POST请求 跨域时候可以使用JSONP 一、get请求 get(url,[data],[callback]) url 访问的接口地址 data:待发送 Key/value 参数。 callback:载入成功时回调函数。 var url = &quot;http://192.168.0.3/project/artist/api/public/index.php?m=main&amp;a=list&quot;; $.get(listUrl,{},function (result) { console.log(&quot;r = &quot;+result); console.log(&quot;type = &quot;+typeof(result)); //JSON解析 //把JSON字符串转化为Javascript的对象或数组 var dict = JSON.parse(result); } //也可以将参数写到对象里面 listUrl = http://192.168.0.3/project/artist/api/public/index.php; $.get(listUrl,{m:&quot;main&quot;,a:&quot;list&quot;},function (result) {} 二、getJSON请求 请求的是JSON数据不需要在进行JSON数据转化 $.getJSON(listUrl,{},function (obj) {} 请求过来的obj就是json数据转化好的对象 三、post请求 和get参数是一样的不过传递的参数要放到对象里面 post请求要比get请求安全，传递的数据不会显示出来，通过一定的加密方式进行传输 $.post(url,{&quot;m&quot;:&quot;main&quot;,&quot;a&quot;:&quot;list&quot;},function(data){} 四、ajax请求 参数较多就介绍常用的参数 url： 路径，接口 type： 请求类型 data： 参数存放 async： 同异步，true是异步，false是同步 timeout: 设置请求超时时间(毫秒) datatype： 数据类型(xml、html、script、json、jsonp、text) success：function(data,textStatus){}返回成功数据 data 可能是XMLDoc、jsonObj、html、text textStatus状态码一般可以省略 error：function(XMLHttpRequest、textStatus、errorThrown){}返回 XMLHttpRequest: 错误信息、捕获的错文对象 通常情况下textStatus、errorThrown只有一个包含信息 $.ajax({ url:listurl, type:&quot;GET&quot;, data:{ &quot;m&quot;:&quot;main&quot;, &quot;a&quot;:&quot;list&quot; }, async:true, datatype:&quot;json&quot;, success:function(data){ var obj = JSON.parse(data); var datas = obj.data; for (var i = 0; i &lt; datas.length; i++) { console.log(datas[i].title); } console.log(&quot;-------ajax--------&quot;); } }); ","link":"https://h8396x.coding-pages.com/post/Dw2UBYOY_/"},{"title":"原生Ajax","content":"Ajax异步通信 客户端与服务器端请求、发送数据 使用Ajax的步骤 1、创建XMLHttpRequest对象 2、通过ajax对象的open方法配置请求 3、通过ajax对象的send方法发送请求 4、通过ajax对象的onreadystatechange事件，监听响应的状态 5、当ajax.readyState == 4(响应就绪) &amp;&amp; ajax.status == 200(响应资源就绪), 说明响应成功。 6、通过ajax.responseText || ajax.responseXML属性获取响应数据 代码实现 window.onload = function(){ /*获取元素......*/ /************* 1、get发送请求无惨 ***********************/ getBtn.onclick = function(){ //创建 var ajax = (window.XMLHttpRequest) ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); //配置 ajax.open(&quot;get&quot;,&quot;http://.../ajaxTest&quot;); //发送 ajax.send(null); //响应事件 ajax.onreadystatechange = function(){ //响应就绪 //响应资源就绪 if(ajax.readyState == 4 &amp;&amp; ajax.status == 200){ console.log(&quot;响应已经就绪了&quot;); var re = ajax.responseText || ajax.responseXML; var data = JSON.parse(re); console.log(data); } } } /********** 2、通过get传参方式发送数据 ************/ sendDataByGet.onclick = function(){ var ajax = (window.XMLHttpRequest) ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); ajax.open(&quot;GET&quot;,&quot;http://.../ajaxGet?name=zs&amp;age=20&amp;sex=man;&quot;); ajax.send(null); //响应事件 ajax.onreadystatechange = function(){ if(ajax.readyState == 4 &amp;&amp; ajax.status == 200){ var re = ajax.responseText || ajax.responseXML; var data = JSON.parse(re); console.log(data); } } } /********** 3、通过post传参方式发送数据 ************/ sendDataByPost.onclick = function(){ var ajax = (window.XMLHttpRequest) ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); ajax.open(&quot;post&quot;,&quot;http://.../ajaxPost&quot;); //post设置请求头 ajax.setRequestHeader(&quot;Content-type&quot;,&quot;applicction/x-www-form-urlencoded&quot;); ajax.send(&quot;name=zs&amp;age=20&amp;sex=man&quot;); ajax.onreadystatechange = function(){ if(ajax.readyState == 4 &amp;&amp; ajax.status == 200){ var re = ajax.responseText || ajax.responseXML; var data = JSON.parse(re); console.log(data); } } } } get和post的区别 1、数据携带方式不同 GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连， POST把提交的数据则放置在是HTTP包的包体中。 2、携带数据量不同 GET方式提交的数据最多只能是1024字节 POST是没有大小限制的 3、安全性 POST方式的安全性高于GET方式 4、应用 GET是向服务器发索取数据的一种请求，而POST是向服务器提交数据的一种请求 5、传递方式 get数据拼接在url后, 键值对之间&amp;, 键值之间=, send()无参。 post数据单独打包发送, 设置请求头, send()传参。 Ajax的封装（两种） /** * Created by jiaoshou on 2016/1/20. */ //创建xhr的过程封装 function createXHR() { var xhr = null; if (XMLHttpRequest) { xhr = new XMLHttpRequest(); }else{ xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } return xhr; } //把异步请求封装 function ajax(type, url, data, async, success, error) { var xhr = createXHR(); type = type == &quot;get&quot;?&quot;get&quot;:&quot;post&quot;; async = async ? true : false; xhr.open(type, url, async); //3 注册状态发生改变的时间 if (type == &quot;post&quot;) { xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); } xhr.onreadystatechange = function(){ if(xhr.readyState == 4 ){ if(xhr.status == 200) { //获取服务器的数据 var data = xhr.responseText; //成功的回调 success(data); }else{ //服务器出错 error(); } } } //4 发送请求 xhr.send(data); } //传过来的data的样子 //data = {&quot;type&quot;:&quot;get&quot;,&quot;url&quot;:&quot;&quot;,data:null,async:true,fn,fn}; function ajax2(data) { var xhr,type,url,async; xhr = createXHR(); type = data.type == &quot;get&quot;? &quot;get&quot;:&quot;post&quot;; if (data.url) { url = data.url; } async = data.async? true: false; xhr.open(type, url, async); //3 注册状态发生改变的时间 if (type == &quot;post&quot;) { xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); } xhr.onreadystatechange = function(){ if(xhr.readyState == 4 ){ if(xhr.status == 200) { //获取服务器的数据 var response = xhr.responseText; //成功的回调 if (typeof data.success == &quot;function&quot;) { data.success(response); } }else{ //服务器出错 if (typeof data.error == &quot;function&quot;) { data.error(); } } } } //4 发送请求 xhr.send(data.data); } ","link":"https://h8396x.coding-pages.com/post/bghyIJ1jz/"},{"title":"Ajax异步通信","content":"事件是异步的 常见服务器 IIS(微软) Kangle WebLogic Apache Tomcat Node Node.js的包管理器，是全球最大的开源生态系统。 什么是Ajax(异步的JavaScript和XML) 用Ajax技术不必刷新整个页面，只需对页面的局部进行更新。 可以节省网络带宽，提高页面的加载速度，缩短用户等待时间，改善用户体验。 同步和异步 同步：发送请求——&gt;等待响应，期间浏览器不可以做其他的事情 异步：发送请求——&gt;等待响应，期间浏览器可以做其他事情 ajax异步通信 1、创建XMLHttpRequest对象 XMLHttpRequest对象(IE5和IE6使用ActiveXObject)是ajax异步通信 实现的核心,用于在前端与服务器端交换数据。 /************ IE5、IE6兼容 ******************** var ajax = null; if(XMLHttpRequest){ ajax = new XMLHttpRequest(); }else{ ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } var ajax = (window.XMLHttpRequest) ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); ********************************************/ 2、open(method,url);初始化请求 /*open(method,url,true);配置http请求 (1)参数一：请求方法method : get : 获取数据,也可以提交数据量小安全性低的数据 post : 提交数据,提交数据量大,安全 (2)参数二：url请求资源的路径(后端开发人员会提供) (3)参数三：是否异步，true默认*/ /****** 例:告诉http，用get方式访问资源********/ ajax.open(&quot;get&quot;,&quot;http://...//ajaxTest&quot;); 3、send(data);真正的向服务器发送请求 data:发送给服务器的数据，post方式传参, get方式不传参。 /*********** 1、get方式不传参 *****************/ ajax.open(&quot;GET&quot;,&quot;http://.../ajaxGet&quot;); ajax.send(null); /*********** 2、get方式传参 —— ?传参 **********/ http协议发送参数的语法url ? 名值对1 &amp; 名值对2 &amp; 名值对3 ... ajax.open(&quot;GET&quot;,&quot;http://.../ajaxGet?name=zs&amp;age=20&amp;sex=man;&quot;); ajax.send(null); /*********** 3、post方式传参 —— 字符串 ********/ post发送数据先设置请求头，告诉http协议，发送post请求 ajax.setRequestHeader(&quot;Content-type&quot;,&quot;applicction/x-www-form-urlencoded&quot;); ajax.send(&quot;name=zs&amp;age=20&amp;sex=man&quot;); 4、onreadystatechange响应状态改变事件，监听响应状态 ajax.readyState == 4; 响应就绪 ajax.status == 200; 响应资源就绪 ajax.responseText || ajax.responseXML; 响应数据 获取响应数据(服务器发送给客户端的数据) 1、onreadystatechange : 响应事件 响应状态改变事件，监听响应状态。 监听数据是否就绪; 若响应，通知浏览器处理响应 2、readystate : 响应状态 (1) 0 ：请求未初始化,仅创建通信对象 (2) 1 : 请求初始化,服务器连接已建立 (3) 2 : 请求已接受 (4) 3 : 请求处理中 (5) 4 : 请求已完成，且响应已就绪 (所有浏览器都有第四个状态) 3、state ：响应资源是否就绪 (1) 200 : OK (2) 404 : 请求失败 4、responseText : 获取响应数据json格式 responseText: json格式 responseXML: XML格式 综合测试 右击文件夹 点击open terminal here，出现窗口命令 输入：npm start 若在本地访问，打开server.js 将app.listen(3000,&quot;192.268.0.3&quot;)改为app.listen(3000); 访问 (1)http://192.168.0.3:3000/ajaxTest (2)localhost:3000 ","link":"https://h8396x.coding-pages.com/post/gRfwryrqp/"},{"title":"JSONP跨域请求","content":"同源策略(同域策略) 同源/同域：指URL地址的协议、IP地址、端口号相同。 同源/同域策略：不同域的系统是无法相互访问的，为了保护系统。 /**********这是三个不同的域************/ http://192.168.0.3:2000 http://192.168.0.3:3000 https://192.168.0.3:3000 jsonp 做跨域访问 1、json和jsonp json: 一种数据的保存格式，就是一种数据 jsonp: 是传递数据的方式，非官方跨域交互协议。 2、哪个标签具有跨域的能力 link img iframe:框架 .css布局 script （src具有跨域的能力，但不安全） 用js实现跨域——&gt;使用script标签 3、script标签的作用 加载远程js文件, 加载完成后立刻执行这个代码 script标签不管js是本地还是跨域，只要能加载，就能执行 script加载的不一定是js文件，只要是js代码就行 4、用服务器的代码，执行客户端的js函数。 服务器代码，在调用本地js函数的时候，将数据传递给这个函数的参数。 jsonp跨域的具体实现 1、定义一个全局函数，函数名任意，但必须有一个参数，用于接收服务器端返回的数据。 2、通过DOM操作创建一个script元素 3、给script元素添加src属性，这个属性值为后端提供URL接口，这个URL需要一个参数：callback = handleData; 4、将script元素添加到body的最后 5、具体如何调用函数，由后台实现。 //全局函数 function handleData(data){ console.log(data); } window.onload = function(){ var jsonp = document.getElementById(&quot;btn&quot;); jsonp.onclick = function(){ //创建一个script标签 var script = document.createElement(&quot;script&quot;); //把接口地址绑定给src script.src = &quot;http://192.168.0.3:3000/jsonp?callback=handleData&quot;; //把创建的srcipt标签插入页面 document.body.appendChild(script); } } window.onload = function(){ //创建一个script标签 var srcipt = document.createElement('script'); //把接口地址绑定给src srcipt.src = &quot;class_91.json?callback=jsonpCallback&quot;; //把创建的srcipt标签插入页面 document.boay.appendChild(srcipt); } //监听回调函数 function jsonpCallback(resp){ if(resp.result == 1){ //for in循环对象 渲染页面 for(var item in data){ ...... } } } ","link":"https://h8396x.coding-pages.com/post/V8Upb51L-/"},{"title":"JSON基础","content":"JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，广泛的用于互联网数据的传输。 保存数据的媒介，是JavaScript中的一种数据类型。 值：数字、字符串、布尔、特殊、数组、对象 JSON的构成 (名值对) 1、简单值：数字，字符串，布尔类型，特殊类型 2、对象：{名值对或数组} 3、数组：[] /*********** JSON格式 对象键名必须有引号 **************/ var person = { &quot;name&quot; : &quot;姬如千泷&quot;, &quot;age&quot; : 23, &quot;sex&quot; : &quot;女&quot;, &quot;family&quot; : [&quot;爸爸&quot;,&quot;妈妈&quot;] }; 获取和设置JSON的属性值 var perName = person.name; 改变属性值 person.age = 18; 定义json数组：跟js的数组使用方式相同。 /******* 一般json的数组中，存放json对象,用来存放多个数据 ******/ var meeting = [ { &quot;name&quot;: &quot;荆天明&quot;, &quot;age&quot;: 18 }, { &quot;name&quot;: &quot;姬如千泷&quot;, &quot;age&quot;: 18 }, ]; 遍历数组并输出到页面 window.onload = function(){ for(var i = 0 ; i &lt; meeting.length ; i++){ var per = meeting[i]; h1.innerHTML += &quot;姓名:&quot; + per.name + &quot;年龄:&quot; + per.age; } } 用json可做 1、会定义各种json（普通对象 ， 数组描述多个事物） 例：新闻构成(title,time,content,author,class) 2、使用json，获取json中保存的数据。 json解析和序列化 json解析：将字符串转换成json数据。 json序列化：将json数据转换为字符串。 全局对象JSON对json进行解析以及序列化 var json = '{&quot;name&quot;:&quot;zhangsan&quot;}'; 1、eval()方法 var jsonObj = eval( &quot; ( &quot; + json + &quot; ) &quot; ); ()告诉eval方法，传递给方法的参数是json字符串，要将其解析为json数据 2、parse()解析方法————将json字符串转换为json数据 var jsonObj = JSON.parse(json); console.log(jsonObj); 3、stringify()序列化方法————将json数据转换为json字符串 var jsonStr = JSON.stringify(jsonObj); console.log(jsonStr); 早期浏览器不支持JSON，使用第三方插件：json2.js ","link":"https://h8396x.coding-pages.com/post/ytUZdp3nr/"},{"title":"cookie","content":"HTTP协议 超文本传输协议, 是一个应用层的协议，由请求和响应构成。 1、客户端与服务器端数据交互的协议。 2、客户端与服务器端交互的模型。 3、HTTP是无状态的协议，不会保存请求和响应的任何数据。 为了保存交互过程中的数据，引入了Cookie的概念，保存用户客户端和服务器端的交互数据。 url组成 协议名 + 主机名 + 端口号 + 文件路径 + 锚点(#后) + 参数(?后) http://192.168.0.3:8080/test/index.html?id=123&amp;name=abc#page1 cookie的组成 1、Cookie的组成(键值对) (1)name = value; 数据必须有，其他可选 (2)expires = 数据失效的时间; (3)path = 数据保存的路径; (4)domain = 域名; (5)secure = 是否使用安全的https协议; 2、Cookie浏览器支持 一般需要服务器端的支持，主流浏览器都支持cookie，除了chrome，其他浏览器都可以直接在非服务器的环境下使用，chrome中的cookie需要服务器的支持。 cookie的使用 1、添加cookie document.cookie = &quot;user = 姬如千泷&quot;; 2、获取cookie var cookieString = document.cookie; window.onload = function(){ var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; h1.innerHTML = cookieString; } 3、expires失效时间 默认cookie的过期时间，会话结束即关闭浏览器时 //手动设置cookie的失效时间 var date = new Date(); //当前时间 var curDate = new Date(); date.setDate(curDate + 7); //产生7天后的时间 document.cookie = &quot;user = 姬如千泷; expires = &quot; + date; 4、网络传输时, 会出现中文乱码问题, 一般保存在Cookie中的数据都要进行编码。 encodeURI(); decodeURL(); encodeURIComponent(); decodeURLComponent(); 对cookie编码 var uname = encodeURIComponent(&quot;荆天明&quot;); document.cookie = &quot;user = &quot; + uname + &quot;;expires = &quot; + date; 对cookie解码 h1.innerHTML = decodeURIComponent(cookieString); 5、设置path属性 只有path下的资源，才有权访问这个cookie 6、删除cookie 将cookie的过期时间设置为当前时间之前的时间 btn.onclick = function(){ 方式一 date = new Date(); date.setDate(date.getDate() - 1); 方式二 date = new Date(0); document.cookie = &quot;user = 姬如千泷; expires = &quot; + date; } cookie局限性 1、每个特定域名下最多生成20个cookie，不同浏览器个数不同。 2、cookie最大约4k，为了兼容性，不能超过4k。 3、cookie安全性不高，密码等不要放。 cookie的封装 1、添加cookie函数封装 function addCookie(name,value,expires,path){ var cookieString = name + &quot;=&quot; + value; if(expires){ cookieString += &quot;;expires&quot; + expires; } if(path){ cookieString += &quot;;path&quot; + path; } document.cookie = cookieString; } 测试： var date1 = new Date(); date1.setDate(date1.getDate() + 7); var path = &quot;/coding/test&quot; addCookie(&quot;userName&quot;,&quot;姬如千泷&quot;,date1,path); 2、获得cookie函数封装 function getCookie(name){ var value = null; var cookieString = document.cookie; if(cookieString.indexOf(&quot;;&quot;) != -1){ //有多个cookie var cookies = cookieString.split(&quot;;&quot;); for(var i = 0 ; i &lt; cookies.length ; i++){ var c = cookies[i]; if(c.indexOf(name) != -1){ var index = c.indexOf(&quot;=&quot;); value = c.substring(index + 1); break; } } }else if(cookieString.indexOf(nsme) != -1){ //单个cookie var index = c.indexOf(&quot;=&quot;); value = c.substring(index + 1); }else{ value = null; } return value; } 测试： var val = getCookie(&quot;userName&quot;); alert(val); ","link":"https://h8396x.coding-pages.com/post/g8qarysBN/"},{"title":"原型和闭包","content":"每个函数(对象)都有prototype属性，是对象属性的集合，默认只有constructor属性； 每个函数(对象)都有_proto_属性，隐世原型，它指向创建该对象的函数的prototype。 1、作用域 语句执行的环境 全局作用域、函数作用域、eval作用域 2、变量对象 定义的所有变量和函数 3、执行环境 定义了变量和函数有权访问的其他数据 ` 1、执行环境中所有代码执行完毕后就会被该环境销毁，保存在其中的所有变量和函数也随之被销毁。` ` 2、每个函数都有自己的执行环境，当执行流进入函数中时，函数的环境就会被推入到一个环境栈中；而在函数执行完后，栈将其弹出，把控制权返回之前的执行环境。` 4、作用域链 保证对执行环境有权访问的所有变量和函数的访问。 全局函数的变量对象始终都是作用域链中的最后一个对象。 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象。 5、原型链 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 _proto_ 这条链向上找，这就是原型链。 6、继承 因为所有对象的原型链都会找到Object.prototype，因此所有对象都有Object.prototype方法，这就是继承。 7、闭包 闭包是指有权访问另一个函数作用域中变量和方法的函数。 常见的创建方式是在一个函数内部创建另一个函数。 闭包使用不合理，会造成空间浪费、内存泄漏、性能消耗等问题。 `闭包实现封装，只有通过对象的特定方法才能访问其属性。` 8、关系 ` 函数被创建，有了作用域； ————&gt; 语句执行的环境 函数被调用，有了作用域链； ————&gt; 指向变量对象的指针列表 函数被继承时，有了原型链； ————&gt; 利用原型让一个引用类型继承另一个引用类型的属性和方法 当需要获取作用域链或原型链上的变量或值时，有了闭包。 ————&gt; 闭包会沿着作用域链找到开发者想要的变量 ` 9、Instanceof的判断规则 (1)沿着 A 的 _proto_ 这条线找 (2)沿着 B 的 _proto_ 这条线找 (3)如果两条线找到同一个引用，即同一个对象，返回true; (4)如果找到重点还未重合，返回false。 10、如何区分一个属性时基本属性还是原型链中的属性 function Foo(){ } var f1 = new Foo(); f1.a = 10; Foo.prototype.a = 100; Foo.prototype.b = 200; var item; for(item in f1){ if(f1.hasOwnProperty(item)){ console.log(item); // 结果为：a } console.log(item); // 结果为：a , b } 11、JS运行前的准备 (1)变量生命，默认undefined； (2)this赋值 (3)函数生命赋值 函数在定义时就确定了函数体内部自由变量的作用域； 函数每次调用，都会产生一个新的执行上下文环境。 ","link":"https://h8396x.coding-pages.com/post/WQI_1WZZA/"},{"title":"prototype：原型","content":"原型的基本知识 1、创建构造函数(都有一个 属性：prototype ; 属性值 : 是对象) function Person (name,age) { this.name = name; this.age = age; } console.log(Person.prototype); //原型对象 Object {constructor: function} 2、可以给原型对象添加属性 Person.prototype.name = &quot;姬如千泷&quot;; Person.prototype.sex = &quot;女&quot;; Person.prototype.say = function () { console.log(&quot;我是原型对象中的say函数&quot;); } console.log(Person); console.log(Person.prototype); 3、实例一个对象 var person1 = new Person(&quot;荆天明&quot;,29); //结果：荆天明 优先访问构造函数 console.log(person1.name); 4、原型对象中的属性，可以为(通过构造函数创建的)实例对象所使用(共用); 实例对象能够访问原型对象中的属性，实例对象中并没有该属性，但可以使用。节省了空间。 console.log(person1.sex); person1.say(); 5、其他 约定俗成：构造函数设置静态属性，原型对象设置共用的动态属性。 属性访问时优先级：先访问构造函数中(自身)拥有的 ，没有 后在原型对象中查找。 验证属性是构造函数(自身)的，还是原型对象的。 1、hasOwnProperty() 检测属性是不是自身的：是, true; 否, false console.log(per1.hasOwnProperty(&quot;name&quot;)); 2、in 检测某个对象能否访问某个属性。不区分是否为自身的。true或false console.log(&quot;name&quot; in person1); 三种继承方式 抽象 面向对象 三个特征: 继承 封装 多态(重载) 对象比函数的封装更高一级 1、原型继承 继承：原型继承(只能继承一次) 原型继承实现: 将上级构造函数的实例对象赋值给下级构造函数的原型。 **********************代码示例********************************* function Father(name){ this.name = name; } function Son(age){ this.age = age; } var father = new Father(&quot;小头爸爸&quot;); var son = new Son(10); Son.prototype = father; //将父的实例对象赋值给子构造函数的原型 son.name = &quot;大头儿子&quot;; console.log(son); //Son {age: 10, name: &quot;大头儿子&quot;} 原型链( 指针 proto ) var obj = new Object(); Son.prototype = father; son.__proto__ == Son.prototype; //true father.__proto__ == Father.prototype; //true obj.__proto__ == Object.prototype; //true 原型链 son.__proto__ 指向 Father {name: &quot;小头爸爸&quot;} father.__proto__ 指向 Object {constructor: function} obj.__proto__ 2、构造函数方式继承call(),apply() 可以继承多个, 但不能访问原型对象中的属性 **************************** 代码示例 ***************************** function GrandaFather(city,sex){ this.city = city; this.sex = sex; } function Father(name){ this.name = name; this.getName = function(){ console.log(this.name); } } function Son(age,name,city,sex){ this.age = age; Father.call(this,name); // this 指向 创建出的实例对象 GrandaFather.apply(this,[city,sex]); /*************这里有问题************** Father.call(this,arguments[0]); GrandaFather.apply(this,arguments); */ } var son = new Son(18,&quot;石兰&quot;,&quot;蜀国&quot;,&quot;女&quot;); console.log(son); //Son {age: 18, name: &quot;石兰&quot;, city: &quot;蜀国&quot;, sex: &quot;女&quot;, getName: function} 3、组合继承 ","link":"https://h8396x.coding-pages.com/post/xZUkSaAie/"},{"title":"对象","content":"OO(object oriented) 面向对象 OOP(object oriented programming) 面向对象编程 面向对象实质: 面向对象是对面向过程的封装 对象是一个独立的命名空间，不受外界影响。 键值对 key:value; 对象是一系列无序属性构成 属性名称:属性值; 对象的创建 //(1)字面量方式 var obj = { name:'荆天明', age:18, sex:'男', say:function(){ console.log(&quot;秦时明月-&quot; + this.name); } }; //(2)工厂方式 function factory(name,price){ var obj = {}; //空对象 obj.name = name; obj.price = price; return obj; } var bmw = factory(&quot;宝马&quot;,&quot;25万&quot;); console.log(bmw); //Object {name: &quot;宝马&quot;, price: &quot;25万&quot;} //(3)高级方式( new + 构造函数 方式) var obj = new Object(); 属性的访问 //(1)增加属性 obj.height = &quot;180cm&quot;; //(2)删除属性 delete obj.sex; delete obj[&quot;sex&quot;]; //(3)修改属性 obj.name = &quot;盖聂&quot;; //(4)访问属性或方法 console.log(obj.name); console.log(obj[&quot;name&quot;]); obj.say(); obj[&quot;say&quot;](); //(5)遍历对象 对象只能用for in遍历(拿到的是每个属性) for(var key in obj){ console.log(key); //每个属性 console.log(obj[key]); //每个属性值, 只能用中括号方式访问 } 抓错语句(不会阻止下面的代码运行) try{ //尝试处理的代码 console.log(height); }catch(e){ //抓取错误信息 console.log(e); } 给对象obj添加对象属性 var car = { name:'变形金刚', color:'yellow', price:100000, say:function(){ console.log(&quot;我是变形金刚&quot;); }, run:function(){ console.log(&quot;我要跑了&quot;); } }; obj.car = car; console.log(car); //访问obj的car属性中的name值 console.log(obj.car.name); console.log(obj[&quot;car&quot;][&quot;name&quot;]); 访问对象不存在的属性, 结果为undefine, 弱类型的体现 new + 构造函数 new String() new Array() new Date() new RegExp() new Map() //(1)创建构造函数 function Animal(name,color){ this.name = name; this.color = color; this.say = function(){ console.log(&quot;我是&quot;+this.name); } } //(2)创建对象 var cat = new Animal(&quot;加菲猫&quot;,&quot;白色&quot;); //(3)属性访问 console.log(cat); cat.say(); 构造函数：首字母大写 一个构造函数，可以创建多个实例对象 一对多 检测数据类型 (1)typeof: 能检测类型，但不能细化 (2)instanceof: 检测某个实例对象与构造函数的关系(实例对象 instanceof 构造函数) (3)object.prototype.toString.call(); object String object Array object Function object.prototype.toString.call(obj).slice(8,-1) === &quot;Array&quot; ********************* 示例1 ************************************ function Person(name,age){ this.name = name; this.age = age; } var person1 = new Person(&quot;姬如千泷&quot;,18); console.log(typeof person1); // Object console.log(person1 instanceof Person); // true ******************** 示例2 ************************************* var arr = [1,2,3]; console.log(typeof arr); // Object console.log(arr instanceof Array); // true ******************** 示例3 ************************************* function fn(){ console.log(123); } console.log(typeof Person); //function特殊的数据类型 console.log(typeof fn); //function特殊的数据类型 console.log(fn instanceof Function); //true ","link":"https://h8396x.coding-pages.com/post/EyfYcUmcb/"},{"title":"this关键字","content":"this对象：每个函数中都会有this对象。 context:上下文对象 this总是指向调用该函数的对象。 this一般存在于函数中，this指向的是该函数存在的对象。 this应用场景 1、console.log(this); //全局下指window 2、事件响应函数中使用this , 指代事件源。 onclick = &quot;fn(this)&quot; //HTML方式要传参 function fn(this){} btn.onclick = function(){ //DOM0级事件直接使用即可 alert(this.value); } 3、字面量方式创建简单对象中使用 , 指代当前对象 var obj = { name:'荆天明', say:function(){ console.log(&quot;秦时明月-&quot; + this.name); } }; 4、构造函数中使用 , 指代创建的对象实例 function Person(name,age){ this.name = name; this.age = age; } var per = new Person(&quot;abc&quot;,20); 没有实例的时候，this指代window。 5、call()和apply()可以改变this的指向 var obj1 = { verson:&quot;#1.0&quot; }; var obj2 = { getVerson:function(){ console.log(this.verson); } } obj2.getVerson(); //this指obj2 , undefined obj2.getVerson.call(obj1); //this指obj1 , #1.0 6、call()和apply()的相同与不同 ***********************相同(使用方法和指向)************************* 书写规范： (1)函数体(函数名)调用call(); (2)参数:对象,调用者 ******************************************************************** function fn(){ console.log(&quot;我叫&quot; + this.name); //this指window } var person = { name : &quot;荆天明&quot;, age : 18 }; fn.call(person); //this指向person fn.apply(person); //this指向person **********************不同(传参不同)******************************* apply规定最多有两个参数(放入数组，自动一一匹配) ******************************************************************* function sum(c,d){ console.log(this.a + this.b + c + d); } var obj = { a:20, b:20 }; sum.call( obj , 30 , 40 ); sum.apply( obj , [30 , 40] ); ","link":"https://h8396x.coding-pages.com/post/6bJ2MvEhA/"},{"title":"正则表达式","content":" 正则表达式：一种模式，一种标准。检索一段文本是否符合要求。 强大的字符匹配工具 正则表达式具有贪婪模式：优先匹配最多的 1、字面量方式 var reg1 = /字符/gi; 2、高级方式 var reg2 = new RegExp(&quot;字符&quot;,&quot;gi&quot;); g : 全局检 i : 忽略大小写 m : 多行匹配 正则表达式常用方法 1、test() 正则表达式.test(str); 返回值：true || false var reg1 = /box/gi; var str1 = &quot;this is a box.Box,Box&quot;; 检索文本 var result1 = reg1.test(str1); console.log(result1); //true 第二次检索，从第一次检索位置之后继续检索 result1 = reg1.test(str1); console.log(result1); //false 2、exec() 返回值：找到了,匹配正则表达式的指定字符信息 对应的下标存入数组；没找到,null var reg2 = /bmw/gi; var str2 = &quot;I own a car of BMW,bmw,BMw&quot;; var result2 = reg2.exec(str2); console.log(result2); //[&quot;BMW&quot;, index: 15, input: &quot;I own a car of BMW,bmw,BMw&quot;] 若多次查找上次为null，下次继续从新开始查找 3、compile(); 修改正则表达式 参数一：修改后的模式 参数二：模式修饰符(根据需要g,i) var reg3 = /abc/; var str3 = &quot;I am abc&quot;; console.log(reg3.test(str3)); // true reg3.compile(&quot;def&quot;,&quot;gi&quot;); console.log(reg3); // /def/gi console.log(reg3.test(str3)); // false 字符串中使用正则表达式 1、replace(); 替换，原字符不发生改变 参数一 old,参数二,new var reg1 = /mbh/gi; var res1 = str1.replace(reg1,&quot;BYD&quot;); console.log(res1); //I need a car of BYD,BYD,BYD console.log(str1); //I need a car of mbh,mbh,MBH 2、match() 匹配 返回值：查找到，返回下标;全局查找将找到的所有字符存入数组。 未找到，null var reg2 = /kai/gi; var res2 = str2.match(reg2); console.log(res2); //[&quot;kai&quot;, &quot;kai&quot;, &quot;KAI&quot;] 3、search() 搜查g i未起到作用 返回值：查找到，字符对应的下标；未找到，返回 -1 ar reg3 = /is/gi; var res3 = str3.search(reg3); console.log(res3); // 7 4、split() 字符转数组 var str4 = &quot;1,2,3&quot;; var reg4 = /,/; var arr = str4.split(reg4); console.log(arr); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 过滤敏感词汇 btn.onclick = function(){ var reg1 = new RegExp(txt.value,&quot;g&quot;); textArea.value = textArea.value.replace(reg1,&quot;***&quot;); } 正则表达式模式 ^$模式 用于表单验证，规定输入的内容规则。 非^$模式 用于匹配字符串 ","link":"https://h8396x.coding-pages.com/post/PXlr3jeaG/"},{"title":"懒加载和滚动加载","content":"懒加载 /******************* 懒加载 lazyLoad ********************/ 一、懒加载优点 1、节省网络资源 2、对用户体验, 使用友好 3、对服务器而言, 负载压力减少 二、实现原理 1、可视区域内的资源显示给用户看 三、功能实现 1、把一张图片默认为占位图，真正图片放在自定义属性中 2、滚动时把自定义属性中的地址给src，替换成真正的地址 四、需要参数 1、小图距离顶部的高度 2、当前窗口的高度 3、滚动条的高度 窗口高度 + 滚动条高度 &gt; 小图距离顶部的高度 $(function(){ lazyLoad(); }) $(window).on('scroll',function(){ lazyLoad(); }) function lazyLoad(){ //获取所有的图片集合 var $pictureItem = $(&quot;.commodity-list img&quot;); //窗口高度 var $winHeight = $(window).height(); //滚动条高度 var $scrollHeight = $(window).scrollTop(); $pictureItem.each(function(index,ele){ if($(ele).offset().top &lt; ($winHeight+$scrollHeight) ){ setTimeout(function(){ if($(ele).attr('src') == &quot;images/placeholder.jpg&quot;){ $(ele).attr('src', $(ele).attr('data-src')); } },2000) } }) } 滚动加载 /******************* 滚动加载 ********************/ ES6在PC端有很多不兼容, ES6转ES5 。 一、滚动加载原理 滚动到底部，发送ajax请求，将拿到的数据追加到页面后。 二、需要参数 1、文档的高度 2、滚动条的高度 3、窗口的高度 三、问题 滑到底部再向上滑，会出现反复请求数据问题？ 解决方法：添加一个 “正在加载...”的提示, 判断如果有正在加载的样式话, 不再重复请求数据。先隐藏、显示、再隐藏 $(window).on('scroll',function(){ //文档高度 var $documentHeight = $(document).height(); //窗口高度 var $winHeight = $(window).height(); //滚动条高度 var $scrollHeight = $(window).scrollTop(); if(($winHeight+$scrollHeight) &gt;= $documentHeight){ if($(&quot;#J_loadingData&quot;).css('display') == &quot;none&quot;){ $(&quot;#J_loadingData&quot;).show(); setTimeout(function(){ $.get('data/index.json',function(resp){ var data = resp.data.commodityList; var liHTML = &quot;&quot;; data.forEach(function(obj,ele){ liHTML += '&lt;li&gt;' +'&lt;div class=&quot;left-picture&quot;&gt;' +'&lt;img src=&quot;images/placeholder.jpg&quot; data-src='+obj.commodityImg+' /&gt;' +'&lt;/div&gt;' +'&lt;div class=&quot;right-info&quot;&gt;' +'&lt;span class=&quot;commodity-title&quot;&gt;'+obj.commodityInfo+'&lt;/span&gt;' +'&lt;span class=&quot;market-price&quot;&gt;市场价：￥'+obj.marketPrice+'.00&lt;/span&gt;' +'&lt;span class=&quot;sc-price&quot;&gt;森巢价：￥'+obj.scPrice+'.00&lt;/span&gt;' +'&lt;/div&gt;' +'&lt;/li&gt;'; }) $(&quot;.commodity-list&quot;).html( $(&quot;.commodity-list&quot;).html() + liHTML ); $(&quot;#J_loadingData&quot;).hide(); }) },2000) } } }) ","link":"https://h8396x.coding-pages.com/post/Ctho-9te1/"},{"title":"时间流和事件冒泡","content":"事件流 指网页中事件传播顺序，当我们对页面进行操作的时候，都会产生事件流。这个事件流在传播过程中，就会查找跟事件流事件类型相同的元素。 点击时，会产生点击事件流。 在传播的过程中，只要发现有元素绑定了和事件流相同类型的事件，就触发此事件。 两种事件流模型 1、冒泡事件流模型：从里往外 现代浏览器，默认都是冒泡 认为事件流，从触发事件的元素开始传递，传播到根节点结束。 2、捕获事件流模型：从外往里 NetScape , 很少用 认为事件流从根节点产生开始传播，传播到当前元素结束。 阻止冒泡：阻止事件的传播 1、W3C方式 事件对象.stopPropagation(); 调用这个方法 event.stopPropagation(); 2、IE方式(IE8以下) 事件对象.cancelBubble = true; 3、兼容IE浏览器//阻止事件冒泡的函数 function stopPro(event){ //var e = evt || window.event; //window.event ? e.cancelBubble = true : e.stopPropagation(); if(event.stopPropagation){ event.stoppagation(); //非IE浏览器 }else{ event.cancelBubble = true; //IE浏览器 } } 修改事件的默认行为 例：img a submit 例：表单中type是submit，点击后在事件传播完成后会自动提交表单 例：input的keydown事件发生并处理后，浏览器会将用户键入的字符自动追加到input元素的值中。 //(1)IE function someHandle(){ window.event.returnValue = false; } //(2)W3C function someHandle(event){ event.preventDefault(); } //(3)兼容性处理 function preventDefault(e){ if(e.preventDefault){ e.preventDefault(); }else{ e.returnValue = false; } } DOM2模型 1、绑定事件 (1)W3C标准： addEventListener(&quot;eventType&quot;,handler,true | false); 参数一：事件类型(不加 on) 事件属性 = on + 事件类型 参数二：处理函数 参数三：指定是否在捕获阶段进行处理，false&lt;=&gt;IE function clickOne(){ alert(&quot;订单安全验证&quot;); } function clickTwo(){ alert(&quot;订单提交&quot;); } btn.addEventListener(&quot;click&quot;,clickOne,false); btn.addEventListener(&quot;click&quot;,clickTwo,false); (2)IE7 / IE8:(只能用冒泡) attachEvent(&quot;eventType&quot;,handler); 参数一：事件类型(加 on) 参数二：事件处理函数 attachEvent(&quot;onclick&quot;,clickOne); attachEvent(&quot;onclick&quot;,clickTwo); (3)DOM2绑定事件兼容性处理 function addEvent(ele,eventType,handler,isCapture){ //isCapture 是否冒泡 if(ele.addEventListener){ ele.addEventListener(eventType,handler,isCapture); }else{ ele.attachEvent(&quot;on&quot;+eventType,handler); } } 2、移出事件 (1)W3C方式 removeEventListener( &quot;eventType&quot;,handler,true||false ); 参数一：不加on (2)IE方式 detachEvent(eventType,handler); 参数二：加on (3)DOM2解除事件兼容性处理 function removeEvent(ele,eventType,handler,isCapture){ if(ele.removeEventListener){ //isCapture未传参，则是undefined ele.removeEventListener(eventType,handler,isCapture); }else{ ele.detachEvent(&quot;on&quot;+eventType,handler); } } 事件委托 本该子元素做的事情，委托给父元素来做。实质：冒泡事件 监听到的实际的事件源 标准浏览器target : ul IE浏览器srcElement : ul 代码示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;我是li标签1&lt;/li&gt; &lt;li&gt;我是li标签2&lt;/li&gt; &lt;li&gt;我是li标签3&lt;/li&gt; &lt;li&gt;我是li标签4&lt;/li&gt; &lt;p&gt;我是p标签&lt;/p&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/javascript&quot;&gt; var ul = document.getElementsByTagName(&quot;ul&quot;)[0]; ul.onclick = function(event){ var e = event || window.event; console.log(e); console.log(e.target || e.srcElement); var tar = e.target || e.srcElement; //节点名称nodeName都是大写的 if(tar.nodeName.toLowerCase() == &quot;li&quot;){ alert(123); } } &lt;/script&gt; ","link":"https://h8396x.coding-pages.com/post/j5GAcuYwR/"},{"title":"JS事件对象","content":"事件对象 信息库：该事件的所有信息属性和方法，如鼠标位置或键盘键码 每个事件都有一个事件对象。 如何获取事件对象 1、W3C规范的浏览器：浏览器在处理事件时，会自动的将事件对象通过参数的方式，传递给事件处理函数。 Btn.onclick = function(evt){} evt:事件对象 2、IE8以下：将事件对象放在window.event 3、兼容性处理 var e = evt || window.event; 若event = undefined,那么返回window.event 若evt存在，返回evt 事件对象常用属性(client和screen常用，所有浏览器都支持) 1、clientX: 触发点相对 可视窗口 的位置，不随页面滚动改变。 2、clientY: 触发点相对 可视窗口 的位置，不随页面滚动改变。 3、screenX：触发点相对 显示器 屏幕左上角距离，不随页面滚动改变。 4、screenY：触发点相对 显示器 屏幕左上角距离，不随页面滚动改变。 5、offsetX：触发点相对 事件元素 的X坐标，只有IE有 6、offsetY：触发点相对 事件元素 的Y坐标，只有IE有 7、pageX: 触发点相对 文档区域 左上角的距离，会随页面滚动改变。 8、pageY: 触发点相对 文档区域 左上角的距离，会随页面滚动改变。 可视区+滚动距离 9、keyCode：键盘键码 window.onkeydown = function(evt){ var event = evt || window.event; var keyCode = event.keyCode; console.log(&quot;键码是：&quot;+keyCode); }; 10、which: 鼠标键码 (左键1 滚轮2 右键3) window.ommousedown = function(evt){ var event = evt || window.event; console.log(event.which); //获取鼠标的键码 } ","link":"https://h8396x.coding-pages.com/post/lMrpM2Tr7/"},{"title":"JS事件","content":"什么是事件 用户或浏览器执行的某个动作 1、主要用于监听网页行为(鼠标、键盘)，根据不同行为给予不同的响应(对网页的操作) 2、好莱坞法则：don not call me , I will call you. 3、函数：由开发者调用；添加事件后：函数由用户调用。 事件三要素 1、事件源：触发事件的源头 按钮 2、事件：点击 3、事件处理程序：响应的函数 事件书写格式 1、内联模式：通过标签中的属性添加事件(很少用) 2、脚本模式：后面的事件会覆盖前面的事件 3、DOM2模式： 1、HTML事件处理格式 this,传参 2、DOM0级事件处理格式 获取标签 btn.onclick = function(){}; 获取标签 btn.onclick = fn; function fn(){} 给一个元素节点多次绑定同一事件，后者会覆盖前面的。 与绑定事件相对应的，有一个删除绑定事件。 btn.onclick = null; 3、DOM2级事件处理格式(H5新增,有兼容) 1、标准浏览器 绑定事件：元素节点.addEventListener(&quot;事件&quot;,事件处理程序,布尔值); 参数一: 事件前不加on 参数二：函数名或匿名函数 参数三：true捕获事件流；false冒泡排序(默认) 删除事件：元素节点.removeEventListener(事件,函数名,布尔值); 参数二：必须是函数名 2、IE浏览器 绑定事件：元素节点.attachEvent(&quot;事件&quot;,事件处理程序); 参数一：事件前加on 参数二：函数名或匿名函数 删除事件：元素节点.detachEvent(事件,事件处理程序); 参数二：必须是函数名 常用事件 鼠标在页面任意移动，事件源:document 1、UI事件(事件源:window) onload: 页面加载事件 先加载页面中的html,css,音频，视频等多媒体资源后，在执行响应函数。 onscroll：页面滚动事件 获取监听水平垂直方向的滚动距离。 window.scrollTo(x,y);返回到指定位置 onresize：页面大小改变事件 2、鼠标事件 onclick:点击事件 ondblclick:鼠标双击事件 onmouseover:鼠标移入事件 //触发多次,进入子元素节点会触发事件 onmouseout:鼠标移出事件 onmouseenter:鼠标移入 //触发一次,进入子元素节点不会触发事件 onmouseleave:鼠标移出 onmousedown:鼠标按下事件 onmousemove:鼠标移动事件 onmouseup:鼠标抬起事件 3、键盘事件 (设置快捷键；做游戏) onkeydown: 当键盘被按下时触发 onkeyup: 当键盘抬起的时候触发 onkeypress: 键盘按压(只能识别字符键) 4、焦点事件 (用户表单验证) onfocus: 获取焦点 onblur: 失去焦点 5、表单提交事件 onsubmit: 表单提交事件 (事件源：form表单) onchange:内容改变时触发 (事件源: 下拉列表select) 按键 altkey:是否按下alt shiftkey:是否按下shift ctrlkey:是否按下ctrl JS和jQuery的入口函数 jQuery:入口函数 $(document).ready() JS : 入口函数 window.onload = function(){} ","link":"https://h8396x.coding-pages.com/post/IP3rQhSul/"},{"title":"JS运动函数及封装","content":"图片滚动 var timer; btn.onclick = function(){ setInterval(function(){ div.style.left = div.offsetLeft + 10 + &quot;px&quot;; if(div.offsetLeft &gt; 200){ clearInterval(timer); div.style.left = &quot;200px&quot;; } },100); } //元素当前位置：元素.offsetLeft/offsetTop + &quot;px&quot;; 运动公式 (1)匀速运动公式 元素.style.top/left = 元素.offsetLeft/offsetTop +/- 10 + &quot;px&quot;; (2)缓速运动公式 元素.style.top/left = 元素.offsetLeft/offsetTop + (target-当前位置) / 10 + &quot;px&quot;; 匀速运动函数 var timer; function animate(ele,target){ clearInterval(ele.timer); //归属者ele var speed = (target &gt; ele.offsetLeft) ? 10 : -10; ele.timer = setInterval(function(){ var result = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + &quot;px&quot;; if( Math.abs(result) &lt;= 10 ){ clearInterval(ele.timer); ele.style.left = target + &quot;px&quot;; } },100); } 缓速运动函数 var timer; function animate(obj,target){ clearInterval(obj.timer); //归属者obj obj.timer = setInterval(function(){ var speed = (target - obj.offsetLeft) / 10; speed = (speed &gt; 0) ? Math.ceil(speed) : Math.floor(speed); obj.style.left = obj.offsetLeft + speed + &quot;px&quot;; if(target == obj.offsetLeft){ clearInterval(obj.timer); obj.style.left = target + &quot;px&quot;; } },20); } ","link":"https://h8396x.coding-pages.com/post/8NM52ocTQ/"},{"title":"DOM样式和屏幕尺寸","content":"CSS样式操作 在JS中，如果样式名称有连字符，去掉连字符，驼峰命名 获取CSS样式 1、内联样式(行内样式) 元素节点.style.样式名称; 元素节点.style[&quot;样式名称&quot;]; div.style.color; p.style.width; ...... 2、非内联样式 IE浏览器： (1)元素节点.currentStyle.样式名称 (2)元素节点.currentStyle[&quot;样式名称&quot;] 非IE浏览器： (1)window.getComputedStyle(元素节点 , null).样式名称; (2)window.getComputedStyle(元素节点 , null)[&quot;样式名称&quot;]; 3、兼容性处理(非内联样式) function getStyle(ele,attr){ if(ele.currentStyle){ return ele.currentStyle[attr]; }else{ return window.getComputedStyle(ele,null)[attr]; } } console.log(getStyle(div1,&quot;border&quot;)); 设置样式 1、设置内联样式 元素节点.style.样式名称 = &quot;&quot;; DOM各种屏幕尺寸 1、offsetWidth 元素实际宽度(不带单位) 2、offsetHeight 元素实际高度(不带单位) var myDiv = document.getElementsByTagName(&quot;div&quot;)[0]; console.log(myDiv.offsetWidth); console.log(myDiv.offsetHeight); 3、 offsetParent 距离当前元素节点最近的有定位的父元素节点；如果都没定位，则是body。 4、 offsetLeft ——left 有定位时：水平方向的偏移量(不带单位)；没有定位时：监听到body的偏移量 5、 offsetTop ——top 有定位时：垂直方向的偏移量(不带单位)；没有定位时：监听到body的偏移量 网页尺寸 //offsetHeight :不包括滚动条 //scrollHeight :包括滚动条 function getSize(){ var width = document.body.offsetWidth || document.documentElement.offsetWidth; var height = document.body.offsetHeight || document.documentElement.offsetHeight; alert(width +&quot;,&quot;+height) } getSize(); innerHTML 1、设置文本内容 d.innerHTML = &quot;我今年&quot;+i+&quot;岁了&quot;; 2、识别标签 d.innerHTML = &quot;&lt;a href='javascript:;'&gt;我是a标签&lt;/a&gt;&quot;; ","link":"https://h8396x.coding-pages.com/post/yuSv9-LgP/"},{"title":"DOM元素操作","content":"DOM元素操作 元素节点的操作：创建、添加、插入、删除、替换、复制 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;createElement&quot; onclick=&quot;createElementFn()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;createTextNode&quot; onclick=&quot;createTextNodeFn()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;appendChild&quot; onclick=&quot;appendChildFn()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;insertBefore&quot; onclick=&quot;insertBeforeFn()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;removeChild&quot; onclick=&quot;removeChildFn()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;replaceChild&quot; onclick=&quot;replaceChildFn()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;cloneNode&quot; onclick=&quot;cloneNodeFn()&quot;/&gt; SSS &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/javascript&quot;&gt; //元素节点的操作：创建、添加、插入、删除、替换、复制 //1、创建元素节点createElement() function createElementFn(){ var div = document.createElement(&quot;div&quot;); console.log(div); } //2、创建文本节点createTextNode() function createTextNodeFn(){ var divText = document.createTextNode(&quot;我是新来的&quot;); console.log(divText); } //3、添加子节点 父节点.appendChild(子节点); function appendChildFn(){ //1、创建P标签 var p = document.createElement(&quot;p&quot;); //2、创建文本：我是P标签 var pText = document.createTextNode(&quot;我是P标签&quot;); //3、给P标签添加文本节点 p.appendChild(pText); //4、将p标签显示在页面父节点body //添加到body的最后，类似push document.body.appendChild(p); } //4、插入子节点 父节点.insertBefore(new，old); //参数1：new-要插入的节点 参数2：old-参照节点 function insertBeforeFn(){ //1、创建P标签 var p = document.createElement(&quot;p&quot;); //2、创建文本：我是P标签 var pText = document.createTextNode(&quot;我是P标签&quot;); //3、给P标签添加文本节点 p.appendChild(pText); //4、将p标签插入到第一个按钮前 var btn1 = document.getElementsByTagName(&quot;input&quot;)[0]; document.body.insertBefore(p,btn1); } //5、删除子节点 父节点.removeChild(子节点); function removeChildFn(){ var btn3 = document.getElementsByTagName(&quot;input&quot;)[2]; document.body.removeChild(btn3); } //6、替换子节点 父节点.replaceChild(替换成new，被替换old ); function replaceChildFn(){ //1、创建a标签 var aEle = document.createElement(&quot;a&quot;); //2、设置href属性 aEle.href = &quot;01非表单元素内容.html&quot;; //3、创建文本节点 var aTxt = document.createTextNode(&quot;点我跳转&quot;); //4、把文本添加到标签 aEle.appendChild(aTxt); //5、替换掉第一个按钮 var btn1 = document.getElementsByTagName(&quot;input&quot;)[0]; document.body.replaceChild(aEle,btn1); } //7、复制节点 元素节点.cloneNode(); //false : 复制标签自身 浅复制 默认 //true : 复制标签+内容 深复制 function cloneNodeFn(){ var aEle = document.createElement(&quot;a&quot;); aEle.href = &quot;01非表单元素内容.html&quot;; var aTxt = document.createTextNode(&quot;点我跳转&quot;); aEle.appendChild(aTxt); console.log(aEle); //有文本内容 console.log(aEle.cloneNode(false)); //没有文本 console.log(aEle.cloneNode(true)); //有文本内容 } &lt;/script&gt; ","link":"https://h8396x.coding-pages.com/post/OApdRGSU0/"},{"title":"DOM层级关系","content":"表单元素 输入框内容，按钮内容，文本域内容，input，file 元素节点.value; 非表单元素 innerHTML(文本+标签) innerText(设置纯文本) 1、获取文本内容 var myDiv = document.getElementsByTagName(&quot;div&quot;)[0]; console.log(myDiv.innerHTML); //开始标签到结束标签之间的部分 console.log(myDiv.outerHTML); //开始标签到结束标签之间的部分+标签自身 console.log(myDiv.innerText); 2、设置文本内容 myDiv.innerHTML = &quot;我是div &lt;p&gt;我是p标签&lt;/p&gt;&quot; myDiv.innerText = &quot;我只能设置纯文本&quot;; DOM节点层级关系 1、parentNode 父节点 var son1 = document.getElementsByClassName(&quot;son1&quot;)[0]; console.log(son1.parentNode); 2、childNodes 所有子节点(但实际只操作元素节点) console.log(son1.parentNode.childNodes); 3、children 直接拿到元素子节点 var arrEle = son1.parentNode.children; //所有子元素节点 var arrEle = son1.parentNode.children[2]; //第三个子元素节点 4、firstChild 第一个子节点 //与childNodes对应 5、lastChild 最后一个子节点 6、firstElementChild 第一个元素子节点 //与children对应 7、lastElementChild 最后一个元素子节点 console.log(son1.parentNode.firstChild); console.log(son1.parentNode.lastChild); console.log(son1.parentNode.firstElementChild); console.log(son1.parentNode.lastElementChild); 8、nextSibling 下一个兄弟节点 //与childNodes对应 9、previousSibling 上一个兄弟节点 10、nextElementSibling 下一个元素兄弟节点 //与children对应 11、previousElementSibling 上一个元素兄弟节点 console.log(son1.nextSibling); console.log(son1.previousSibling); console.log(son1.previousElementSibling); console.log(son1.nextElementSibling); 每个节点都有三个属性 1、三个节点属性 元素属性：nodeType 所有元素节点的类型都是 1 ; 元素名称：nodeName 元素值： nodeValue var myDiv = document.getElementById(&quot;myDiv&quot;); console.log(myDiv.nodeType); //结果 ：1 console.log(myDiv.nodeName); //结果 ：DIV console.log(myDiv.nodeValue); //结果 ：null 2、删选元素节点 var arr = son1.parentNode.childNodes; var newArr = []; for(var i = 0 ; i &lt; arr.length ; i++){ if(arr[i].nodeType == 1){ newArr[newArr.length] = arr[i]; } } 总结 parentNode 父节点 childNodes 所有子节点 firstChild 第一个子节点 //与 childNodes 对应 lastChild 最后一个子节点 nextSibling 下一个兄弟节点 previousSibling 上一个兄弟节点 children 直接拿到元素子节点 firstElementChild 第一个元素子节点 //与 children 对应 lastElementChild 最后一个元素子节点 nextElementSibling 下一个元素兄弟节点 previousElementSibling 上一个元素兄弟节点 ","link":"https://h8396x.coding-pages.com/post/3DJ_Qk2p3/"},{"title":"DOM文档对象模型","content":"DOM节点 HTML的所有内容都是节点 文档节点 元素节点 属性节点 文本节点 父节点(parent) 子节点(child) 兄弟节点(sibling) 根节点(root) 获取DOM元素节点(标签) (任何元素都可以自定义属性name，在IE中只识别form表单中的name) 1、getElementById(); 通过id来获取元素节点; 唯一 2、getElementsByTagName(); 通过标签名称获取元素节点; 伪数组(不享有数组的方法) 3、getElementsByClassName(); 通过类名获取元素节点; 伪数组(IE低版本有兼容性问题) 4、getElementsByName(); 通过name属性值获取元素节点。 5、document.querySelector();多种选择器获得元素节点，默认只选择第一个 var dom1 = document.querySelector(&quot;.myUl&quot;); //选择第一个类 var dom2 = document.querySelector(&quot;#my_div&quot;); //选择唯一的id var dom3 = document.querySelector(&quot;input&quot;); //选择第一个元素标签 6、document.querySelectorAll();通过多种选择器获取页面中的所有元素节点。 操作元素节点 获取/访问属性节点 1、控制台输出 按钮-类型type var inps = document.getElementsByTagName(&quot;input&quot;); console.log(inps[0].type); 2、输出按钮的内容 console.log(inps[0].value); 3、在控制台输出div的类名 class不能用,用className var divs = document.getElementsByTagName(&quot;div&quot;); console.log(divs[0].className); 设置属性节点方式一( . 语法) 1、给div重设类名 divs[0].className = &quot;div&quot;; 2、给图片设置路径 var imgs = document.getElementsByTagName(&quot;img&quot;); imgs[0].src = &quot;429902.jpg&quot;; 3、单选框、复选框。是通过布尔值设置默认选中 var inps = document.getElementsByTagName(&quot;input&quot;); inps[1].checked = true; 4、option，通过布尔值设置为默认选中 var opts = document.getElementsByTagName(&quot;option&quot;); opts[1].selected = true; 设置属性节点方式二(自带属性 || 自定义属性) setAttribute(); 参数：属性，属性值 getAttribute(); 1、给按钮设置属性 var inps = document.getElementsByTagName(&quot;input&quot;); inps[0].setAttribute(&quot;onclick&quot;,&quot;fn()&quot;); function fn(){alert(123);} 2、获取属性 var divs = document.getElementsByClassName(&quot;my_div&quot;); console.log(divs[0].getAttribute(&quot;class&quot;)); 排它思想 var btns = document.getElementsByTagName(&quot;input&quot;); for(var i = 0 ; i &lt; btns.length ; i ++){ btns[i].onclick = function(){ //排他思想：在操作当前元素之前，先清除之前其他的样式 for(var j = 0 ; j &lt; btns.length ; j++){ //btns[j].className = &quot;old&quot;; btns[j].setAttribute(&quot;class&quot;,&quot;old&quot;); } //this.style.backgroundColor = &quot;red&quot;; //this.className = &quot;current&quot;; this.setAttribute(&quot;class&quot;,&quot;current&quot;); } } ","link":"https://h8396x.coding-pages.com/post/SBnRMi0ft/"},{"title":"BOM浏览器模型","content":"JS三大模块 ECMAScript：变量、表达式、运算符、选择、循环、函数、数组、字符串、Math、Date BOM：browser object model 浏览器对象模型——JS操作浏览器 DOM：文档对象模型 JS控制浏览器 window对象 工具包 function fn(){} fn(); 在全局声明的函数，属于window window常用方法 alert() confirm() prompt() setTimeout clearTimeout setInterval clearInterval 1、open(); 打开新页面-简单使用 window.open(&quot;url&quot;); 打开新页面-复杂使用 window.open(&quot;url&quot;,&quot;_blank&quot;,&quot;width=300,height=300px,left=100,top=100,fullscreen=no&quot;); Location对象常用属性 window.location 1、href 路径导航 window.location.href = &quot;02BOM-window.html&quot;; 2、protocol 协议名（http:） console.log(window.location.port); 3、hostname 主机名 4、port 端口 5、host 主机（主机名+端口号） 6、origin （协议名+主机名+端口号） 7、search （?后面的传值） 8、reload();对当前页面刷新 window.location.reload(); history对象 1、window.history.back(); 历史记录的上一页 2、window.history.forword(); 历史记录的下一页 3、window.history.go(num); &gt; 0 跳转到当前页面之后的第num条记录 &lt; 0 跳转到当前页面之前的第num条记录 ","link":"https://h8396x.coding-pages.com/post/_yxgPIzqc/"},{"title":"Date日期和时间","content":"创建日期 var date1 = new Date(); console.log(date1); 设置日期 var date2 = new Date(&quot;2017/8/30 17:30&quot;); console.log(date2); 倒计时：2个时间节点 当前时间、结束时间； 差值：转换成时分秒，var milli = date1 - date2; 获取时间 在获得的date1中拿到具体的需要的时间 1、获取年份 date1.getFullYear(); 2、获取月份(比实际月份小 1 ) date1.getMonth()+1; 3、获取日 date1.getDate(); 4、获取星期(返回值：0~6) date1.getDay(); 5、获取小时(24小时制0~23) date1.getHours(); 6、获取分钟 date1.getMinutes(); 7、获取秒数 date1.getSeconds(); 8、获取毫秒(1s = 1000ms) date1.getMilliseconds(); 9、getTime();获取时间方法 getTime():距离1970/1/1 0:0:0 累积的毫秒数 10、date1.toLocaleTimeString(); //时分秒 11、date1.toLocateDateString(); //年月日 设置时间 1、设置年 date1.setFullYear(2018); 2、设置月( month-1 ) date1.setMonth(2-1); //设置二月 3、设置日 date1.setDate(21); 4、设置时 date1.setHours(17); 5、设置分 date1.setMinutes(30); 6、设置秒 date1.setSeconds(10); 星期数转换 用date得到的星期是 0 ~ 6之间的数字，将其转化为对应的星期数。 function dayFn(num){ var days = ['星期天','星期一','星期二','星期三','星期四','星期五','星期六']; return days[num]; } ","link":"https://h8396x.coding-pages.com/post/EWs9oYfnL/"},{"title":"定时器","content":"setTimeout() setTimeout设置为0，代表立即插入队列，但不是立即执行。setTimeout并不能保证执行的时间，是否执行取决于JavaScript的线程是拥挤还是空闲。 1、延迟一定时间，执行某个函数 2、参数1：匿名函数(函数名) 参数2：延时时间：ms 1s = 1000ms //表现形式一 setTimeout(function(){ console.log(789); },5000); //表现形式二 setTimeout(fn,5000); function fn(){ console.log(789); } clearTimeout() 关闭定时器 参数：对应的定时器名称 setInterval() 1、每隔一定时间，重复执行某个函数 2、参数1：匿名函数(函数名) 参数2：间隔时间：ms 1s = 1000ms //使用方式同setTimeout var i = 0; setInterval(function(){ i++; document.write(&quot;&lt;p&gt;我今年&quot;+i+&quot;岁了&lt;/p&gt;&quot;); } , 1000); clearInterval() 关闭定时器 参数：对应的定时器名称 var timer = setInterval(function(){},1000); clearInterval(timer); ","link":"https://h8396x.coding-pages.com/post/fu_4-rHXU/"},{"title":"Math数学方法","content":"Math.random() 随机数：0 - 1 （不包括1） 自定义区间范围，输出该区间内的随机整数 Math.ceil() 向上取整 console.log(Math.ceil(1.3)); // 结果 2 console.log(Math.ceil(-1.3)); // 结果 -1 console.log(Math.ceil(&quot;1.3&quot;)); // 结果 2 Math.floor() 向下取整 console.log(Math.floor(1.8)); // 结果 1 console.log(Math.floor(-1.8)); // 结果 -2 console.log(Math.floor(&quot;1.8&quot;)); // 结果 1 &lt;=&gt; parseInt Math.round() 四舍五入 console.log(Math.round(1.8)); // 结果 2 console.log(Math.round(1.3)); // 结果 1 console.log(Math.round(-1.8)); // 结果 -2 console.log(Math.round(&quot;-1.3&quot;)); // 结果 -1 其他 .toFixed(3) // 保留3位小数 Math.sqrt() // 平方根 Math.abs() // 绝对值 Math.max() // 最大值 Math.min() // 最小值 Math.pow(2,3); // 求n的m次方，求2的3次方 ","link":"https://h8396x.coding-pages.com/post/VKM43uHGW/"},{"title":"字符串方法","content":"字符串的创建方式 1、字面量方式 var str1 = &quot;123abc&quot;; console.log(str1); //123456 console.log(str1.length); //结果为6 console.log(typeof str1); //数据类型：string 2、高级方式 var str2 = new String('456'); console.log(str2); //String{0:&quot;4&quot; , 1:&quot;5&quot; , 2:&quot;6&quot; , length:6 , ...} console.log(str2.length); //结果为3 console.log(typeof str2); //数据类型：object 小写字母和大写字母ASCII码 a:97 A:65 charAt(index) 1、检索指定位置上的字符 2、返回值：对应位置上的字符 ; 查找不到：结果为空 var str = &quot;123,abc&quot;; console.log(str.charAt(1)); //结果2 console.log(str.charAt(10)); //结果空 逐一输出每个字符 for(var i = 0 ; i &lt; str.length ; i++){ console.log( str.charAt(i) ); //1 2 3 , 4 5 6 } charCodeAt() 1、检索指定位置上字符的ASCII编码 2、返回值：对应字符的ASCII编码 var str = &quot;123,abc&quot;; console.log(str.charCodeAt(4)); //下标4对应的字符a结果：97 String.fromCharCode() 1、通过ASCII编码找到对应字符 2、返回值：查找到的字符 console.log(String.fromCharCode(97)); //结果97对应的字符a indexOf() 1、从前向后查找指定字符的下标 2、返回值：找到返回下标 ; 找不到返回 -1。 3、参数1：查找的指定字符 参数2：开始查找的位置(包含) var str2 = '123,456,abc'; console.log(str2.indexOf(&quot;3&quot;)); //结果：下标2 console.log(str2.indexOf(&quot;3&quot;,3)); //结果：-1 lastIndexOf() 1、从后向前查找指定字符下标(索引是固定的) 2、参数1：查找的指定字符 参数2：开始查找的位置(包含) 3、返回值：找到返回下标 ; 找不到返回 -1。 var str2 = '123,456,abc'; console.log(str2.indexOf(&quot;3&quot;)); //结果：下标2 console.log(str2.indexOf(&quot;3&quot;,3)); //结果：-1 replace() 1、替换字符 2、参数一：被替换的旧字符 参数二：替换后的新字符 3、返回值：替换后的新字符串 var str = &quot;abcdef&quot;; console.log(str.replace('a' , 'A')); //结果 Abcdef console.log(str); //结果 abcdef toUpperCase() 1、把小写英文转换成大写英文 2、返回值：转换之后的新字符串 3、原字符串未发生改变 var str = 'abcdef'; console.log(str.toUpperCase()); //结果 ABCDEF console.log(str); //结果 abcdef var s = str.charAt(5); console.log(s.toUpperCase()); //结果 F toLowerCase() 1、把大写英文转换成小写英文 2、返回值：转换之后的新字符串 3、原字符串未发生改变 var str = 'ABCDEF'; console.log(str.toLowerCase()); //结果 abcdef console.log(str); //结果 ABCDEF trim() IE不支持 1、去除前后空格 2、返回值：去除空格后的新字符串 3、原字符串未发生变化 var str = ' abc '; //5个字符 console.log(str.length); console.log(str.trim()); //abc console.log(str); //abc split() 1、把字符串转成数组 2、参数：分隔符（字符串中的某一字符或多个字符） 3、原字符串未发生改变 var str = &quot;I#am#Mr#TianMr&quot;; console.log(str.split(&quot;#&quot;)); //结果[&quot;I&quot; , &quot;am&quot; , &quot;Mr&quot; , &quot;Tian&quot;] console.log(str); //结果 I#am#Mr#TianMr console.log(str.split(&quot;Mr&quot;)); //结果[&quot;I#am#&quot; , &quot;#Tian&quot; , &quot;&quot;] substr() 1、截取字符串 2、只有参数一：从开始截取到最后 参数一：开始截取的位置(包含) 参数二：截取的个数(长度) 3、返回值：截取的新字符串 var str = '123abcdef'; console.log(str.substr(2)); //结果：3abcdef console.log(str.substr(2,4)); //结果：3abc console.log(str); //结果：123abcdef substring() ---slice 1、截取字符串 2、只有参数一：从开始截取到最后 参数一：开始截取的位置(包含) 参数二：结束的位置(不包含) 3、返回值：截取的新字符串 var str = '123abcdef'; console.log(str.substring(2)); //结果：3abcdef console.log(str.substring(2,4)); //结果：3a console.log(str); //结果：123abcdef 汇总 charAt(i); 指定位置字符 charCodeAt(); 指定位置字符的ASCII编码 String.fromCharCode(); 通过ASCII编码找到对应字符 indexOf(); 从前向后查找指定字符的下标 lastIndexOf(); 从后向前查找指定字符的下标 replace(); 替换字符 toUpperCase(); 小写转大写 toLowerCase(); 大写转小写 trim(); 去除前后空格 split(); 字符串转数组 substr(); 截取字符串：参数2，截取个数 substring(); 截取字符串：参数2，结束位置 ","link":"https://h8396x.coding-pages.com/post/LlSq30j_o/"},{"title":"数组常用方法—数组元素操作","content":"var arr = [10,'hello',true, [20 , 30 , 40] ]; //二维数组 push()方法 1、在末尾追加数组元素 arr.push(20 , '姬如千泷'); 2、返回值：返回新数组的长度 3、原数组发生改变 pop()方法 1、删除数组的最后一个元素 arr.pop(); 2、返回值：删除的元素 3、原数组发生改变 shift()方法 1、删除数组的第一个元素 arr.shift(); 2、返回值：删除的元素 3、原数组发生改变 unshift()方法 1、在开头添加元素 arr.unshift(20 , '荆天明'); 2、返回值：新数组的长度 3、原数组发生改变 索引下标是固定的从前向后，0 开始 indexOf()方法 1、从左向右查找指定元素的下标 arr.indexOf(30); 2、返回值：下标 ; 若查找不到返回值为 -1 ; 3、原数组不发生改变 lastIndexOf()方法 1、从右向左查找指定元素的下标 arr.lastIndexOf(30); 2、返回值：下标 ; 若查找不到返回值为 -1 ; 3、原数组不发生改变 //数组去重，并放入新的数组 var arr = [1,3,5,7,9,10,3,4,5,3,7]; var newArr = []; for(var i = 0 ; i &lt; arr.length ; i++){ if(newArr.indexOf(arr[i]) == -1){ newArr.push(arr[i]); } } console.log(newArr); join()方法 1、连接：把数组转换为字符串 arr1.join(&quot;-&quot;); //用 - 连接 2、返回值：新的字符串 3、原数组不发生改变 concat()方法 1、拼接合并数组 arr1.concat(arr2); //arr1在前，arr2在后 2、返回值：数组1 + 数组2 新的数组 3、原数组不发生改变 reverse()方法 1、倒置数组 arr.reverse(); 2、返回倒置后的新数组 3、原数组发生改变 slice()方法 参数一：开始位置下标，包含起始位置元素 参数二：结束位置下标，不包含结束位置元素 1、截取数组元素arr.slice(2); 从下标2截取到最后 arr.slice(2,5);从下标2截取到下标5之前 2、返回截取元素构成的新数组 3、原数组不发生改变 splice()方法 参数一：开始位置下标，包含起始位置元素 参数二：截取的长度 ; 若 &gt; 0 , 则删除元素 ; 若 = 0 , 则添加(多个)元素 1、截取数组元素 2、返回截取元素构成的新数组 3、原数组发生改变 var arr = [10,20,30,40,50]; console.log(arr.splice(1,3)); //结果：[20,30,40] console.log(arr.splice(1,0,true,'abc')); //截取个数为0 //结果：空数组 arr.splice(1 , 0 , 'abc' , true); //结果：[10, 'abc' , true ,20,30,40,50] sort() 数组元素的排序:转换为字符来进行比较排序(ASCII码比较) var arr1 = ['a','b','ef','cd']; console.log(arr1.sort()); // a ,b ,cd ,ef var arr2 = [31,21,13,9,52,11]; console.log(arr2.sort()); //11,13,21,32,52,9 //元素从小到大排序 var arr3 = [31,21,13,9,52,11]; arr3.sort(function(a,b){ console.log(arr3); console.log(a); console.log(b); return a - b; //从小到大 }); function rule(a,b){ return a-b; } arr.sort(rule); console.log(arr3); 总结 改变原数组： shift：将第一个元素删除并且返回删除元素，空即为undefined unshift：向数组开头添加元素，并返回新的长度 pop：删除最后一个并返回删除的元素 push：向数组末尾添加元素，并返回新的长度 reverse：颠倒数组顺序 sort：对数组排序 splice(start,length,item)：删，增，替换数组元素，返回被删除数组，无删除则不返回 不改变原数组： concat：连接多个数组，返回新的数组 join：将数组中所有元素以参数作为分隔符放入一个字符 slice(start,end)：返回选定元素 map,filter,some,every等：不改变原数组 冒泡排序 //要求对该数组中元素从小到大顺序排列 var = [10,2,30,3,5,7,34,13]; for(var i=0 ; i &lt; arr.length ; i++){ //比较的趟数 for(var j=0 ; j &lt; arr.length-i ; j++){ //每趟比较的次数 if(arr[j] &gt; arr[j+1]){ var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } console.log(arr); ","link":"https://h8396x.coding-pages.com/post/Ms_ZoPvZd/"},{"title":"数组基础","content":"数组 数组Array：值的有序集合 数组中的数据————元素 元素之间,隔开 数组中数据类型没有限制，弱类型的体现 数组(Array)创建方式 1、字面量方式 var arr = [];//空数组 var arr = [20 , 'abc' , '荆天明' , true , undefined]; 2、高级方式（new关键字） var arr = new Array(); //空数组 var arr = new Array(10 , 'abc' , true); //注意：如果括号里只有一个正整数，代表的数组长度 var arr = new Array(5); //手动设置数组长度为5，但未赋值 数组元素的操作（增删改查） 索引值/下标：从 0 ~ (length-1) var arr = [10 , 20 , 30]; 1、增、新增数组的元素 arr[4] = &quot;荆天明&quot;; //此时数组长度为5，其中arr[4]为undefined 2、删、删除数组的元素 arr.length = 3; //硬性的固定长度数组,长度的灵活性 3、改、修改数组中的元素 arr[0] = true; 4、查、访问数组中的元素 数组名[下标] arr[i] var arr = []; for(var i = 0 ; i &lt; 10 ; i++){ arr[arr.length] = i + 1; } console.log(arr); 数组的遍历/循环 arr.length 能自动监听的自动监听 1、for循环 for(var i = 0 ; i &lt; arr.length ; i++){ } 2、for in 循环 for(var i in arr){ console.log(arr[i]); } 3、ECMAScript5.0新增的 for(var ele of arr){ //of 无法监听数组下标 console.log(ele); //直接拿到数组中的每个元素 } 4、forEach()方法，可以遍历多维数组。 jQuery中有一个each()方法，只能遍历一维数组 //匿名函数作为实参 arr.forEach(function(ele,index){ //参数一：拿到的是每个元素 console.log(ele); //参数二：拿到的是数组下标 console.log(index); }); JS的应用一（给div设置背景色） 1、 函数的做法 var divArr = document.getElementsByTagName(&quot;div&quot;); function colorDiv(i,color){ divArr[i].style.backgroundColor = color; } colorDiv(0,&quot;red&quot;); colorDiv(1,&quot;yellow&quot;); colorDiv(2,&quot;green&quot;); colorDiv(3,&quot;blue&quot;); 2、for循环 var colorArr = ['red' , 'yellow' , 'blue' , 'pink']; var divArr = document.getElementsByTagName(&quot;div&quot;); for(var i = 0 ; i &lt; divArr.length ; i++){ divArr[i].style.backgroundColor = colorArr[i]; } JS 的应用二（设置奇偶行颜色不同） 1、获取标签 2、设置样式 var colorArr = ['red' , 'green']; var divArr = document.getElementsByTagName(&quot;div&quot;); for(var i = 0 ; i &lt; divArr.length ; i++){ if(i%2 == 0){ divArr[i].style.backgroundColor = colorArr[0]; }else{ divArr[i].style.backgroundColor = colorArr[1]; } } var divArr = document.getElementsByTagName(&quot;div&quot;); for(var i = 0 ; i &lt; divArr.length ; i++){ if(i%2 == 0){ divArr[i].style.backgroundColor = &quot;red&quot;; }else{ divArr[i].style.backgroundColor = &quot;green&quot;; } } 4、 随机生成背景颜色——2种方法 //rgb方式 var divs = document.getElementsByTagName(&quot;div&quot;); for(var i = 0 ; i &lt; divs.length ; i++){ var ran1 = parseInt(Math.random()*256); var ran2 = parseInt(Math.random()*256); var ran3 = parseInt(Math.random()*256); divs[i].style.backgroundColor = &quot;rgb(&quot;+ran1+&quot;,&quot;+ran2+&quot;,&quot;+ran3+&quot;)&quot;; } //十六进制的方式 var colorArr = [0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e','f']; // 16个数字 var p = document.getElementsByTagName(&quot;p&quot;); for(var i = 0 ; i &lt; p.length ; i++){ var ran = []; var str = &quot;&quot;; for(var j = 0 ; j &lt; 6 ; j++){ ran[i] = colorArr[parseInt(Math.random()*colorArr.length)]; str = str+ran[i]; } p[i].style.backgroundColor = &quot;#&quot; + str + &quot;&quot;; } arguments记录实参 函数内部，监听实参 function fn(){ console.log(arguments); //可以访问实参的值 console.log(arguments[0]); console.log(arguments[1]); } fn(10,20); //用arguments算三个数中的最大值 function fn(){ var max = arguments[0]; for(var i = 0 ; i &lt; arguments.length ; i++){ if(max &lt; arguments[i]){ max = arguments[i]; } } return max; } alert(&quot;最大值是：&quot;+fn(60,40,77)); ","link":"https://h8396x.coding-pages.com/post/ji6AD_Tgc/"},{"title":"匿名函数","content":"匿名函数 引用数据类型(3种)：对象，数组，对象 匿名函数 又名，拉姆达函数 匿名函数应用场景：事件，定时器(参数)，对象(属性值), 函数中作为返回值 创建方式 1、匿名函数()表示执行 (function(a,b){ return a+b; }); 2、变量接收执行 var add = function(a,b){ return a+b; }; console.log(add(2,3)); 3、自执行，自己创建并执行。在匿名函数后加()执行。 var add = function(a,b){ return a+b; }(2,3); 回调函数 callback 一个主体函数中，有另一个函数作为参数。只有当主体函数达到某种条件后，才有可能会执行的函数-回调函数 自执行函数 自执行函数：自己就执行 框架 插件 应用比较多 jq 自执行函数书写之前，为了防止上面代码对该函数造成影响，习惯性会在自执行函数之前加分号，进行分隔 function fn () { console.log(123); } console.log(fn); //自执行函数书写格式： //第一种 var a = 10; ;(function(val) { console.log(&quot;我是&quot; + val); })(&quot;自执行函数1&quot;); //第二种方式 (function(val) { console.log(&quot;我是&quot; + val); }(&quot;自执行函数2&quot;)); //第三种格式 标点符号 ! + - !function(val) { console.log(&quot;我是&quot; + val); }(&quot;自执行函数3&quot;); +function(val) { console.log(&quot;我是&quot; + val); }(&quot;自执行函数4&quot;); JS的执行顺序 1、预编译，将全局定义的函数和全局定义的变量提前。匿名函数不能提前，只是一个普通的语句。 2、JS从上到下逐行执行 3、在加载HTML和CSS时，只要碰到JS都要停止，先执行JS在执行其他的代码 JS代码放在最后或者使用onload事件 外部JS文件必须放在body的后面，避免由于网络问题阻塞html界面的显示。 函数创建方式(补充) 1、普通方式 2、匿名函数创建方式 3、原始方式，new的方式，底层常用 ","link":"https://h8396x.coding-pages.com/post/Lr_2bdZJ2/"},{"title":"JS函数","content":"函数是一等公民 函数命名规则标识符 命名规则 驼峰命名 语义化 可以$开头命名 函数名称不要大写, 大写的是构造函数。 什么是函数 函数：具有特定功能的代码块 功能：根据实际需要，声明对应功能函数 优势：减少代码量，复用性高 规则：函数不调用不执行 函数分类 系统函数：alert() parseInt() prompt() 自定义函数： 自定义函数声明和调用 function 函数名(){} //定义函数 函数名(); //调用函数 参数分类：形参、实参 形参：函数声明时，函数后面括号里的参数―变量名称。 实参：函数调用时，函数后面括号里的参数 `实参的实质：调用时实参对形参赋值` 实参与形参个数一一匹配（个数、顺序） 实参少于形参：不匹配的结果为undefined 实参多于形参：结果为无 有实参无形参：报错 记录监听实参的 arguments function fn(){ console.log( arguments[0] ); //第一个实参实参 console.log( arguments.length ); //实参的个数 console.log( fn.length ); //形参的个数 console.log( fn.callee.length ); //形参的个数 } fn(a,b,c); 函数关键字return 终止、结束程序 返回值：字符串，数值，布尔值，变量，函数等 无return关键字，但默认最后会执行return;结束函数，结果为undefined 函数重载（JS中没有重载的概念） 1. 同一个脚本中，出现了同名函数，后者会覆盖掉前者。 2. 声明函数和调用函数顺序可以不同，一个函数内可以调用另一个函数。 匿名函数：没有名字的函数 //JS高阶里面最常用 var fn = function(){ console.log(123); } fn(); 作用域：变量和函数起作用的区域或范围。 全局作用域：当前整个JS脚本 全局变量 局部作用域(函数作用域)：函数内部，函数能限制作用域 局部变量 `局部作用域下可以访问全局变量；全局作用域下不能访问局部变量。` 作用域链规则：从本作用域链查找，没有向上一级作用域查找，最后找到全局作用域。还未查找到，not define报错。 var a = 10; function fn1(){ var b = 20; console.log(b); function fn2(){ var c = 30; console.log(a); //可以调用 a , b ,c console.log(b); console.log(c); } console.log(a); //可以调用 a , b ，不能调用c console.log(b); } console.log(a); //可以调用 a ，不能调用 b , c fn1(); //只能调用fn1,通过fn1调用fn2 JS执行解析代码 顺序结构：从上到下逐行解析 选择结构：选择分支，有选择性的解析执行 循环结构：for,while,do-while 1. JS解析：默认情况下，顺序执行。 2. 预编译模式：优先抓取关键字var，把变量声明提前到逻辑最顶层，（不包括赋值） 3. 块级作用域：{} ，for if 都不能起到限制作用域的作用 for(var i = 1 ; i &lt;= 10 ; i++ ){ //i 是全局变量 console.log(i); //打印结果1~10 } console.log(i); //结果为 11 4. 在函数内部，声明变量时，没有var,该变量隐式的成为了全局变量 function fn(){ d = 10; console.log(d); //结果为10 } console.log(d); //结果为10 函数作用域问题 1、例题1 var aa = 10; function test () { var aa = 20; } test(); console.log(aa); //结果为10 在全局作用域下找到 aa = 10 2、例题2 var num = 2; function fn1() { var num = 5; console.log(num); } fn1(); //结果为5 在函数作用域下找到 num = 5 3、例题3 var num = 2; function fn2() { //var num; //预编译先把var num;提到函数作用域最上方 console.log(num); //结果为 undefined var num = 5; console.log(num); //结果为 5 } fn2(); 4、例题4 var num = 2; fn3(); //结果为undefined 声明函数和调用函数顺序可以不同 function fn3() { var num; console.log(num); num = 5; } fn3(); //结果为undefined 5、例题5 var a = 10; function fn4 () { var b = 9; console.log(a); //结果 a = undefind console.log(b); //结果 b = 9 var a = 30; } fn4(); 递归函数 函数内调用函数-调用自身，类似循环 慎用递归，易死循环 1、用户任意输入数字，控制台一次递减1输出，输出到1结束 function printNum(num){ if(num == 0){ //临界断点 return; } alert(num); num--; printNum(sum); } printNum(5); 2、打印5的阶乘 function fn(num){ if(num == 1){ return 1; } return num*fn(num-1) } console.log(fn(5)); 函数扩充 1、直接打印函数名，输出的结果是函数名 var fn = function(){ console.log(123); }; fn(); console.log(fn); //fn是变量名称 function fn1(){ console.log(456); } console.log(fn1); ","link":"https://h8396x.coding-pages.com/post/q6c8cVWqC/"},{"title":"JS基础","content":"特点 1. 解释型脚本语言（在运行过程中逐行解释，边解释边运行） 2. 基于对象 3. 简单 （采用弱类型的变量类型，对数据未做严格要求） 4. 动态性 （采用事件驱动，不经过Web服务器就可以对用户输入作出响应） 5. 跨平台型 （不依赖于操作系统，只需浏览器支持） JavaScript组成 1. 核心（ECMAScript） 2. 文档对象模型（DOM） 3. 浏览器对象模型（BOM） ECMAScript和JS的区别 1. ECMAScript：语言标准，简称ES 2. JS：是实现了ECMAScript语言标准的编程语言 浏览器的两个引擎 1. 排版引擎（HTML、CSS用） 2. JavaScript引擎 JS文件引入 1. 外部引入 2. 放在HTML中的任意位置 变量 1. 声明赋值 2. 命名规范 字母、下划线、$字符、数字 3. 关键字保留字 数据类型 1. 数字类型 Number 最基本 2. 字符串类型 String 3. 布尔类型 Boolean true/false 1/0 4. 变量未初始化 undefined 声明变量未赋值 5. 空类型 Null 清除资源使用、初始化 6. NaN 不是一个数字 isNaN(x); 7. Infinity 无穷大 var num = 7/0; 在JS中，isNaN是唯一一个不等于自己的变量 运算符 1. 算数运算符 + - * / % 2. 关系运算符 &gt; &gt;= &lt; &lt;= == != === !== 全等比较大小和类型 3. 逻辑运算符 &amp;&amp; || ！ 4. 复合运算符 ++ -- += -= /= *= %= 5. 运算符优先级 ()最高 赋值 = 和 ，最低 数据类型转换 1. 字符串转数字 强制转整数 parseInt Number 字符串首字母是数字，可提取数字；不能转数字，结果为NaN；强制转小数 parseFloat 2. 数字转字符串 String 3. 其他类型转布尔 Boolean `if(true){ console.log(&quot;123&quot;); } //这句话正确，且能输出` ","link":"https://h8396x.coding-pages.com/post/LQFnfROAU/"},{"title":"Sass语法基础","content":"0、sass和scss区别 sass不允许出现 {} ， scss可以像css一样使用 {} //sass书写方式 body font-size: 12px background: #000 //scss书写方式 body{ font-size: 12px; background: #000; } 1、定义变量 $ $float: left; 2、使用变量 #或$ // 变量做属性名 #{$float}: left; // 变量做属性值 float: $left; 3、选择器嵌套和属性嵌套 body{ div{ font:{ weight:bold; size:23px; } } } 4、父选择器 &amp; div{ width:100px; height:100px &amp;:after{ content:''; background:red; width:200px; height:200px; } &amp;-child{ // 编译后为 div-child } } 5、定义重用代码块 @mixin // 居中显示 @mixin center($t, $b, $l, $r){ position: absolute; margin: auto; top: rpx($t); bottom: rpx($b); left: rpx($l); right: rpx($r); } @include center(0, 0, 0, 0); 6、调用重用代码块 @include .box{ @include bg_dom('../img.png',30%,40%) } 7、选择器继承 @extend .father { border: 1px solid red; background-color: #fdd; } .son { @extend .father; border-width: 3px; } 8、数据类型运算 所有: == , != 数字: +, -, *, /, %, &lt;, &gt;, &lt;=, &gt;= 字符: + #{} 颜色: +, * 布尔: and, or, not 空值: 数组: maps: 9、内置函数 image-width() 获取图片的宽度 image-height() 获取图片的高度 unit() 获取一个值所使用的单位 lighten(red,10%) 使颜色变淡 darken(red,20%) 使颜色变深 inline_image('../img.png') 将图片转换成base64格式 ... (1)字符串函数 unquote($string) ：删除字符串中的引号； quote($string) ：给字符串添加引号； str-length($string) : 返回字符串长度； str-insert($string, $insert, $index) : 在$string中的第$insert中插入字符串$insert； str-index($string, $substring) : 查找字符串$substring并返回其下标； str-slice($string, $start-at, [$end-at]) : 截取字符串（开始位置、结束位置）； to-upper-case($string) : 转为大写字母； to-lower-case($string) : 转为小写字母。 (2)数字函数 percentage($value) ：将一个不带单位的数转换成百分比值； round($value) ：将数值四舍五入，转换成一个最接近的整数； ceil($value) ：将大于自己的小数转换成下一位整数； floor($value) ：将一个数去除他的小数部分； abs($value) ：返回一个数的绝对值； min($numbers…) ：找出几个数值之间的最小值； max($numbers…) ：找出几个数值之间的最大值； random() ：生成一个随机数。 (3)list函数 length($list) ：返回一个列表的长度值； nth($list, $n) ：返回一个列表中指定的某个标签值 join($list1, $list2, [$separator]) ：将两个列给连接在一起，变成一个列表； append($list1, $val, [$separator]) ：将某个值放在列表的最后； zip($lists…) ：将几个列表结合成一个多维的列表； index($list, $value) ：返回一个值在列表中的位置值； list-separator($list) : 是否有分隔符； is-bracketed($list) : 是否有方括号[]。 (4)map函数 map-get($map,$key) ：根据$key返回对应的map值； map-merge($map1,$map2) ：合并map1和map2； map-remove($map,$key) ：返回删除$key值后的新map； map-keys($map) ：返回map中的所有key； map-values($map) ：返回map中的所有value； map-has-key($map,$key) ：map中是否有改key； keywords($args) ： Returns the keywords passed to a function that takes variable arguments. (5)Introspection函数 feature-exists($feature) ：某属性是否在当前sass中； variable-exists($name) ：某变量是否在当前sass中； global-variable-exists($name) ：某变量是否在全局环境中； function-exists($name) ：某函数是否存在； mixin-exists($name) ：某mixin是否存在； content-exists() ：当前的mixin是否通过了一个内容块； type-of($value) ：返回一个值的类型； unit($number) ：返回一个值的单位； unitless($number) ：判断一个值是否有带位； comparable($number-1, $number-2) ：判断两个值是否可以做加、减和合并； call($function, $args…) ：动态绑定get-function返回的函数； get-function($name, $css: false) ：查找给定名称的函数； inspect($value) : Returns the string representation of a value as it would be represented in Sass. (6)颜色函数 rgb($red, $green, $blue) ：创建颜色； rgba($red, $green, $blue, $alpha) ：创建颜色包含透明度； red($color) ：获取颜色中的红色分量； green() ：获取颜色中的绿色分量； blue() ：获取颜色中的蓝色分量； Mix() ：将两种颜色混合在一起。 &lt;!-- 其他三种较复杂参数 --&gt; adjust-color($color, [$red], [$green], [$blue], [$hue], [$saturation], [$lightness], [$alpha]) scale-color($color, [$red], [$green], [$blue], [$saturation], [$lightness], [$alpha]) change-color($color, [$red], [$green], [$blue], [$hue], [$saturation], [$lightness], [$alpha]) (7)透明函数 alpha($color) ：获得颜色的透明度； rgba($color, $alpha) ：设置颜色的透明度； opacify($color, $amout) ：使颜色变得不透明； fade-out($color, $amount) ：使颜色更透明； transparent($color, $amount) ：使颜色更透明； (8)HSL函数 hsl($hue, $saturation, $lightness) ：从色调、饱和度、亮度创建一个颜色； hsla($hue, $saturation, $lightness, $alpha) ：从色调、饱和度、亮度、透明度创建一个颜色； hue($color) ：获取颜色的hue值; saturation($color) ：获取颜色的饱和度值； lightness($color) ：获取颜色的亮度； adjust-hue($color, $degrees) ：改变颜色的色调； lighten($color, $amount) ：使颜色变亮； darken($color, $amount) ：使颜色变暗； saturate($color, $amount) ：增加饱和度； desaturate($color, $amount) ：减小饱和度； grayscale() ：将颜色转成灰度； complement($color) ：返回颜色的互补色； invert($color, [$weight]) ：范湖颜色的对立色 (9)选择器函数 selector-nest($selectors…) ：将选择器嵌套在另一个下面； selector-append($selectors…) ：追加选择器(无空格)； selector-extend($selector, $extendee, $extender) ：在 $selector中用$extender继承$extendee； selector-replace($selector, $original, $replacement) ：在$selector中用$replacement替换$original； selector-unify($selector1, $selector2) ：统一选择器； is-superselector($super, $sub) ：$super是否匹配所有的$sub； simple-selectors($selector) ：返回包含复合选择器的简单选择器； selector-parse($selector) ：将选择器解析为＆返回的格式。 (10)其他 if($condition, $if-true, $if-false) ：根据条件$condition返回true和false； unique-id() ：返回css唯一标识。 10、自定义函数 //项目中用到的计算rem值得函数 @function func($t) { @if (unit($t)==1) { @return $t*10; } @else if (unit($t)==2) { @return $t*100; } @else { @return $t; } } &lt;!-- 使用 --&gt; width: func(1); 11、控制指令 (1)控制指令 —— @if @else $type: y; @if $type == x{ color: red } @else if $type == y{ color: yellow } @else{ color: green } (2)控制指令 —— @for // through : [1,3] @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } // to : [1,3) @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } (3)控制指令 —— @each &lt;!-- 应用一：数组 --&gt; @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); } } &lt;!-- 应用二：多个数组 --&gt; @each $animal, $color, $cursor in (name1, black, default), (name2, blue, pointer), (name3, white, move) { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); border: 2px solid $color; cursor: $cursor; } } &lt;!-- 应用三：对象 --&gt; @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; } } (4)控制指令 —— @while $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } 12、规则 @import @media @extend @at-root 跳出嵌套 @debug @warn @error 13、导入 .scss 文件 &lt;!-- 导入并编译 --&gt; @import &quot;base.scss&quot;, &quot;header.scss&quot;; &lt;!-- 导入但不编译 --&gt; @import &quot;_base.scss&quot;, &quot;_header.scss&quot;; &lt;!-- 嵌套到样式内 --&gt; #main { @import &quot;example.scss&quot;; } 14、四种输出格式 :nested 嵌套 :expanded 选择器不缩进 :compact 每条CSS规则占一行 :compressed 压缩 ","link":"https://h8396x.coding-pages.com/post/3arofct8Y/"},{"title":"Less基础","content":"三种使用方式 1、引入less文件，将写好的less文件，编译为CSS文件 ———— 基本不用 2、在本地进行编译, 使用 koala 3、在本地进行编译,使用npm安装less install less -p koala使用方法 目标：把less文件，编译成css文件 自动编译功能：修改less文件（koala 必须开启） 1、把包含less文件的文件夹，拖放到koala目录下 2、把需要编译的文件，进行编译 3、在对应的目录中，即可输出需要的CSS文件 4、引入css文件 less变量 //定义变量 @bgy: greenyellow; @w: 400px; .box{ width: @w; height: @h; background-color: @bgy; font-size: @fs; } 如果 类名 要作为变量使用，前后要加 { } @b: .box2; @{b} { width: @w; height: @h; background-color: @bgp; font-size: @fs; } 内置函数（数学函数） .box{ background-color: #00BFFF; //abs 绝对值 width: abs(-100px); //sqrt 开方 width: sqrt(10000px); //ceil 向上取整 height: ceil(99.6px); //pow 次幂 font-size: pow(5px , 2); //min 最小值 max 最大值 font-size: min(100px , 200px , 20px); //随机数 } less嵌套 .wrap{ width: 100%; margin: 0px auto; .top,.bottom{ width: 100%; height: 200px; text-align: center; background-color: #00BFFF; } .center{ width: 100%; height: 600px; .left{ ... } .right{ ... } .middle{ h3{ color: red; } } } } 父元素（&amp;） a{ font-size:40px; &amp;:hover{ color: greenyellow; } } .box{ width: 200px; height: 200px; background-color: #00BFFF; cursor:pointer; &amp;:hover{ background-color: #FFC0CB; } &amp;{ color: red; font-size: 28px; } } less混合 像操作函数一样操作 CSS 样式 .style{ width: 100%; height: 250px; background-color: darkviolet; } .box{ .style(); font-size: 30px; } 可以传参 @bgb: #00BFFF; .style2(@bgb){ width: 100%; height: 250px; background-color: @bgb; margin-top: 20px; } .box2{ font-size: 40px; .style2( @bgb ); } less继承 .grandFather{ width: 100%; height: 100px; background-color: gainsboro; font-size: 20px; text-align: center; } .father:extend(.grandFather){ background-color: deepskyblue; } .son:extend(.father){ font-size: 50px; background-color: #FFC0CB; } ","link":"https://h8396x.coding-pages.com/post/Xh3zdTJo2/"},{"title":"常见居中问题","content":"文字水平居中 //适用于文字、链接、inline、inline-block、inline-table和inline-flex的元素。 #outer{ text-align:center; } 块级元素水平居中 #inner{ margin: 0px auto; } 多个块级元素水平居中 1、text-align 和 display #outer{ text-align:center; } #inner{ display:inline-block; } 2、flexbox实现（默认块级元素） #outer{ display:flex; /* 按照主轴中心的位置对齐 */ justify-content:center; } 未知宽高行内块元素（input , img）水平垂直居中 .outerBox{ float: left; width: 300px; height: 300px; background-color: black; /*核心*/ display: table-cell; text-align: center; vertical-align: middle; } .innerImg{ width: 100px; height: 80px; background-color: white; } div(块级元素)水平垂直居中 1、需要知道宽高，top,left设为 50% 在用margin拉回宽高的一半。 .outer1{ float: left; width: 300px; height: 300px; background-color: greenyellow; /*核心*/ position: relative; } .inner1{ width: 100px; height: 80px; background-color: palevioletred; /*核心*/ position: absolute; top: 50%; left: 50%; margin: -40px 0 0 -50px; } 2、未知宽高，绝对定位+margin（好用） .outer2{ float: left; width: 300px; height: 300px; background-color: plum; /*核心*/ position: relative; } .inner2{ width: 100px; height: 80px; background-color: cornflowerblue; /*核心*/ position: absolute; margin: auto; top: 0; bottom: 0; left: 0; right: 0; } 3、未知宽高，transform实现 .outer3{ float: left; width: 300px; height: 300px; background-color: purple; /*核心*/ position: relative; } .inner3{ width: 100px; height: 80px; background-color: cornflowerblue; /*核心*/ position: absolute; top: 50%; left: 50%; transform: translate(-50% , -50%); } 4、flex布局实现 #container{ display:flex; /* 按照主轴中心的位置对齐 */ justify-content:center; /* 交叉轴水平位置对齐 */ align-items: center; } 总结 transform和flexbox需要考虑兼容问题 ","link":"https://h8396x.coding-pages.com/post/zQCvn79Aa/"},{"title":"CSS3-3D","content":"属性perspective 单位：px； 设置假定人眼到平面的距离，只影响3D元素。 数越大，物体越远；数越小，物体越近。 位置：加在父元素上，设置好后子元素就可以完成3D转换。 属性transform-style transform-style:preserve-3d; //使被转换的子元素保留其3D转换 3D-transform 1、3D位移 transform:translateZ(100px); //改变元素在Z轴上的距离,正负值 transform:translate3d(x,y,z); //元素在X,Y,Z轴都发生变化 2、3D旋转 transform:rotateX(deg); //3D旋转必须设置具体方向 transform:rotateY(deg); transform:rotateZ(deg); 先旋转在移动，物体在旋转的过程中，坐标也会改变。 可以先移动在旋转。 过渡和四要素 过渡：元素从一个状态到另一个状态的平滑变换过程。 属性：transition 触发：过渡效果由用户的行为进行触发（点击、鼠标悬停） 过渡属性 transition-property:none/all/property; 例：transition-property:background; 过渡时间 transition-duration:s/ms; 过渡函数 transition-timing-function:linear/ease/ease-in/ease-out/ease-in-out; 匀速/慢快慢/慢开始/慢结束/慢开始结束 过渡延迟 transition-delay:s/ms; 统一设置过渡：transition:属性 时间 函数 延迟; 移入移出都需要过渡放在div里，只有移入需要放在hover里。 动画 过渡，实现简单的动态效果； 动画，实现复杂的动态效果。注意浏览器兼容。 声明动画 @keyframes name{ from{ background-color:red; } 50%{ background-color:yellow; } to{ background-color:blue; } } 调用动画 animation:name,s/ms,ease,infinite,alternate; /*名称: 时长: 单位s/ms 速度: linear ease ease-in ease-out ease-in-out 延迟: 单位s/ms 次数: 数值 infinite,无数次播放 方向: normal alternate,交替轮流*/ 播放方向 alternate：奇数次from-to,偶数次to-from。 动画播放之前和之后的效果 none:默认 forwards:动画完成后，保持最后一个状态； backwards:动画显示之前，保持在第一个状态； both:动画完成后，动画显示前，都保持着相应的状态。 动画播放状态，用于播放过程中暂停动画。 animation-play-state: ; paused：暂停 running：播放 ","link":"https://h8396x.coding-pages.com/post/JAFE17PO0/"},{"title":"CSS3-2D","content":"转换是使元素改变形状、尺寸和位置的一种效果。 移动、缩放、旋转、拉伸倾斜 转换属性 transform: none; none 不转换，默认值 translate() 位移 rotate() 旋转 scale() 缩放 skew() 倾斜 转换原点 transform-origin:0px 0px ; 数值 transform-origin:50% 50% ; 百分比 transform-origin:right top ; 关键字 一个值：X轴 两个值：X轴 Y轴 三个值：X轴 Y轴 Z轴 2D转换——位移translate transform:translate(x); 一个值X轴的移动 transform:translate(x,y); 两个值Y轴的移动 transform:transformX(50px); 只在X轴移动 transform:transformY(50px); 只在Y轴移动 2D转换——缩放scale transform:scale(0.5); 一个值水平垂直方向都缩放相同比例 transform:scale(1.5,1.5); 缩放比例分别为x,y transform:scaleX(0.5); 横向缩放 transform:scaleY(1.5); 纵向缩放 缩小 0~1之间 默认值 1 放大 &gt;1 2D转换——旋转rotate transform:rotate(45deg); 正：顺时针 负：逆时针 2D转换——倾斜skew() transform:skewX(40deg); 水平方向倾斜 transform:skewY(40deg); 垂直方向倾斜 transform:skewY(40deg,40deg); ","link":"https://h8396x.coding-pages.com/post/oB57PlAY8/"},{"title":"CSS3多列、hack、优化","content":"多列 column-count:3; &lt;!-- 元素被分隔的列数 --&gt; column-gap:10px; &lt;!-- 列与列之间的间隔 --&gt; column-rule:2px solid red; &lt;!-- 列规则，列间隔符的宽度、样式、颜色。 --&gt; :before :after的高级用法 利用:before和:after不仅可以向元素前面或后面添加文字和图片，还可以添加元素。 默认添加的元素是行内元素，应该转化为块级元素再设置宽高，否则无效。 CSS Hack 浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果，这就是CSS Hack。 Chrome:Blink内核 Firefox:gecko内核 IE:trident内核 Opera:以前presto,现在Blink内核 Safari:webkit内核 1、条件注释法 条件注释法还可以应用在页面头部，该样式能被IE浏览器解析 条件注释写法&lt;!--[if ...]&gt; &lt;![endif]--&gt; &lt;!--[if IE]&gt; 用于 IE &lt;![endif]--&gt; &lt;!--[if IE 6]&gt; 用于 IE6 &lt;![endif]--&gt; &lt;!--[if IE 7]&gt; 用于 IE7 &lt;![endif]--&gt; &lt;!--[if IE 8]&gt; 用于 IE8 &lt;![endif]--&gt; &lt;!--[if gt IE 6]&gt; 用于 IE6 以上版本 &lt;![endif]--&gt; &lt;!--[if lte IE 7]&gt; 用于 IE7及以下版本 &lt;![endif]--&gt; &lt;!--[if gte IE 8]&gt; 用于 IE8 及以上版本 &lt;![endif]--&gt; &lt;!--[if lt IE 9]&gt; 用于 IE9 以下版本 &lt;![endif]--&gt; &lt;!--[if ! IE 6]&gt; --&gt; 用于非 IE 6版本 &lt;!-- &lt;![endif]--&gt; 2、属性前缀法 属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。 添加在属性后： \\9 IE6~10 background-color:red\\9; \\0 IE8~11 \\9\\0 IE9，10 添加在属性前(常用)： !important IE7~IE10 IE6浏览器识别但不认!important的优先级 * IE6，IE7 * background-color:red; + IE6，IE7 # IE6，IE7 - IE6 _ IE6 3、选择器前缀法 针对一些页面表现不一致或者需要特殊对待的浏览器，在选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack *html *前缀只对IE6生效 *+html *+前缀只对IE7生效 @media screen\\9{ 只对IE6/7生效 div{...} } @media \\0screen { 只对IE8有效 body { background: red; } } @media \\0screen\\,screen\\9{ 只对IE6/7/8有效 body { background: blue; } } @media screen\\0 { 只对IE8/9/10有效 body { background: green; } } CSS优化 我们写CSS代码时，不仅仅只是完成页面设计的效果，还应该让CSS代码易于管理，维护。我们对CSS代码重构主要有以下目的： 1.提高页面加载性能 2.提高代码的可维护性 3.减轻服务器压力，缩短服务器响应时间，提高用户体验度 优化方法： 1.尽量将样式写在单独的css文件里面，在head元素中引用; 2.CSS sprites：合并多个背景图像到一个单独图像，然后通过background-image和background-position进行调整; 3.减少样式重写; 4.使用工具压缩css代码，如yuicompressor，尽量不要在HTML中缩放图像，避免空的src和href; 5.避免使用复杂的选择器，层级越少越好; (不要超过3个) 6.利用CSS继承减少代码量; 7.不乱用CSS reset; 8.尽量使用最具体的类别、避免后代选择器。（div p span） 为什么要CSS重置： 在不同的浏览器中默认标签的默认样式是不一样的。 注意：不能使用通用选择器*{margin 0px;} ","link":"https://h8396x.coding-pages.com/post/lmMg6czvv/"},{"title":"CSS3选择器","content":"通用兄弟选择器 selector1~selector2{} 可以不相邻 例：div~p{ } 为所有相同的父元素中位于 div 元素之后的所有 p 元素设置样式 &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; 属性选择器 1、元素[属性^=值] ^ 以值开头的class 例：div[class^=test]设置 class 属性值以 &quot;test&quot; 开头的所有 div 元素的样式 2、元素[属性*=值] *包含该值的class 例：div[class*=test]设置 class 属性值包含 &quot;test&quot; 的所有 div 元素的样式 3、元素[属性$=值] $以该值结尾的class 例：div[class$=test]设置 class 属性值以 &quot;test&quot; 结尾的所有 div 元素的样式 伪类选择器：元素状态伪类 结构伪类 目标伪类 否定伪类 元素状态伪类选择器 1、:enabled选择器匹配每个已启用的元素（大多用在表单元素上） input[type=&quot;text&quot;]:enabled为所有 type=&quot;text&quot; 的已启用的 input 元素设置样式 2、:disabled选择器匹配每个被禁用的元素（大多用在表单元素上） input[type=&quot;text&quot;]:disabled为所有 type=&quot;text&quot; 的被禁用的 input 元素设置样式 3、:checked选择器匹配每个已被选中的input元素（只用于单选按钮和复选框） input:checked{}为所有被选中的 input 元素设置样式 目前只有Opera浏览器支持。 4、::selection选择器匹配被用户选区的部分，只能向::selection选择器应用少量CSS属性，color、background、cursor、outline。 div::selection{ background-color:red; } 结构伪类选择器 1、:first-of-type 选择器匹配属于其父元素的特定类型的首个子元素的每个元素。 div p:first-of-type{color:red;} 2、:last-of-type 选择器匹配属于其父元素的特定类型的最后一个子元素的每个元素。 div p:last-of-type{color:red;} 3、:only-of-type 选择器匹配属于其父元素的特定类型的唯一子元素的每个元素。 div p:only-of-type{color:red;} 4、:nth-of-type(n) 选择器匹配属于父元素的特定类型的第n个子元素的每个元素。 p:nth-of-type(3){color:red;} 5、:nth-last-of-type(n) 选择器匹配属于父元素的特定类型的第n个子元素的每个元素，从最后一个子元素开始计数。 p:nth-last-of-type(3){color:red;} 6、:only-child 选择器匹配属于其父元素的唯一子元素的每个元素。 div p:only-child{color:red;} 7、:nth-child(n)选择器匹配属于其父元素的第n个子元素，不论元素的类型。 ul li:nth-child(2){color:red;} ul li:nth-child(odd){color:red;} 匹配下标是奇数的子元素 ul li:nth-child(even){color:red;} 匹配下标是偶数的子元素 8、:nth-last-child(n)选择器匹配属于其元素的第n个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。 ul li:nth-last-child(2){color:red;} 9、:last-child选择器匹配属于其父元素的最后一个子元素的每个元素。 p:last-child{color:red;} 10、:root选择器匹配文档根元素 :root是CSS3的选择器，因此我们可以通过次选择器判断浏览器是否支持CSS3。 11、:empty选择器匹配没有子元素（包括文本节点）的每个元素。 div:empty{} 目标伪类选择器 URL后面跟有锚名称#，指向文档内某个具体的元素。这个被链接的元素就是目标元素。 :target选择器可用于选取当前活动的目标元素。 &lt;a href=&quot;d1&quot;&gt;&lt;/a&gt; &lt;div id=&quot;d1&quot;&gt;&lt;/div&gt; 否定伪类选择器 :not()选择器匹配非指定元素/选择器的每个元素。 :not(p)设置非&lt;p&gt;元素的所有元素的样式。 ul&gt;li:not(:last-child){color:red;} ","link":"https://h8396x.coding-pages.com/post/Jfwoptl3r/"},{"title":"CSS使用小技巧","content":"内外阴影box-shadow box-shadow: 5px 5px 20px #ed0000;设置外阴影 box-shadow: 5px 5px 20px #ed0000 inset;设置内阴影 多重边框 .div1 { box-shadow: 0 0 0 6px red, 0 0 0 12px blue, 0 0 0 18px green, 0 0 0 24px purple; height: 200px; margin: 50px auto; width: 400px } 设置隐藏显示div 滑动门原理 css代码恶作剧 *{ cursor: none!important; } 设置模糊文字 color: transparent; text-shadow: #111 0 0 5px; 设置长宽比固定元素，响应式页面很常用 通过设置父级窗口的padding-bottom可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形 &lt;div style=&quot;width: 100%; position: relative; padding-bottom: 20%;&quot;&gt; &lt;div style=&quot;position: absolute; left: 0; top: 0; right: 0; bottom: 0;background-color:yellow;&quot;&gt; this content will have a constant aspect ratio that varies based on the width. &lt;/div&gt; &lt;/div&gt; 实时编辑css（仅仅装x使用，仅对body生效） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;style style=&quot;display:block&quot; contentEditable&gt; body { color: blue } &lt;/style&gt; &lt;/body&gt; &lt;/html&gt; 设置选中文字的颜色 ::selection伪元素 触发背景变淡 .spectiveBlur{ position: absolute; top: 50%;left: 50%; width: 220px;line-height:160px; transform: translate(-50%, -50%); border-radius:10px; overflow:hidden; background:#E91E63; color:#fff; font-size:200%; text-align:center; cursor:pointer; transition: transform .2s; } .spectiveBlur:hover{ box-shadow:0 0 0 1920px rgba(0,0,0,.7); transform: translate(-50%, -50%) scale(2); } 颜色渐变的高级应用 `radial-gradient(#000 12.5px, transparent 12.5px)` 表示颜色从半径多少开始变化，变化到半径多少为止。 `linear-gradient(#000 100px, #fff 100px)` 表示颜色从那个位置开始变化，变化到那个位置结束。 ps：当设置background-image为渐变色的时候，配合background-position能实现意想不到的神奇效果 background-image: radial-gradient(#000 12.5px, transparent 12.5px), radial-gradient(#fff 12.5px, transparent 12.5px), radial-gradient(#fff 50px, transparent 50px), radial-gradient(#000 50px, transparent 50px), linear-gradient(90deg，#000 100px, #fff 100px); 指明上述四个半径变化的圆心在哪。 background-position:center 50px,center -50px,center 50px,center -50px,0 0; ","link":"https://h8396x.coding-pages.com/post/imP81JgMY/"},{"title":"CSS浮动和定位","content":"定位分类 定位：元素在网页中出现的位置 (1)普通流定位 (2)浮动定位 float (3)相对定位 relative (4)绝对定位 absolute (5)固定定位 fixed 定位属性 static 默认，静态定位(普通流定位) relative:相对定位 absolute:绝对定位 fixed:固定定位 偏移属性：top bottom left right 堆叠属性z-index：当修改了元素的定位方式后，产生重叠的效果，谁在前谁在后。值越大越靠近用户。 relative、absolute、fixed都可以通过z-index进行层次分级。 普通流定位（网页默认定位） 块级元素，从上到下排列；行级元素，从左到右排列。 浮动定位 1、什么是浮动定位 将元素排除在普通流之外,元素在网页上是不占用空间的； 浮动元素会放在包含框的左边或右边，但依然在包含框内； 浮动元素在浮动时，可以向左或向右移动直到碰到包含框或其他浮动元素位置。 float:none/left/right; none:无浮动(默认) 注意：在一个容器内，如果有浮动元素的话，那么尽可能的让该容器中所有的元素都浮动起来。如果有想在下一行内显示的内容（不浮动的）单独使用容器来承装。 2、浮动定位的特点 浮动元素外边缘不会超过父元素的边框； 浮动元素默认不会重叠； (重叠只发生在浮动和不浮动元素之间) 浮动只能左右浮动，不能上下浮动； 所有行内元素设置为浮动元素的话，默认将转换为块级元素(可以设置宽高)。 浮动是脱离文档流的,在需要设置多个块级元素同行排列的情况下非常有用。 3、清除浮动 清除浮动带来的影响，定义了元素的哪个边上不允许出现浮动。 clear:left/right/both 4、浮动引发的问题及解决（6种） 包含框如果没有设置高度，内部元素被应用了float之后，包含框的高度会变为0。 解决方法： (1)给父元素设置高度 (2)父元素设置overflow:hidden; 可以让父元素自动随子元素撑开。 (3)添加一个空的div并设置clear:both; 相对定位 不脱离文档流，给元素相对定位后，元素相对初始位置(相对于自己)发生位移，但仍保留初始位置。 使用场合:鼠标移入，实现元素位置的微妙变化; 配合绝对定位使用，弹出菜单。 绝对定位 脱离文档流，参考物为该元素外层的非static(relative,absolute,fixed)定位的元素，如果向上逐级未找到非static定位的元素，最终参考物为body。 使用场合:多数使用在弹出菜单上。 固定位置 固定位置所固定的是可视化窗口而非body或是父级元素。 将元素固定在网页的某个位置处，不随滚动条发生滚动，多数都相对body实现固定定位。 使用场合：小广告; 返回顶部。 ","link":"https://h8396x.coding-pages.com/post/rsSRPctdn/"},{"title":"CSS表格和列表","content":"常用样式 文本、字体格式化属性 背景属性：颜色、字体 内边距：padding 尺寸：width height 边框：border 文本垂直对齐(只有表格能用)： `vertical-align:top/middle/bottom;` 表格特有的样式属性 1、边框合并 border-collapse:separate/collapse; separate：默认，分离边框 collapse:合并边框 //内联样式：写在table内 //非内联样式： table{ border:1px solid #000; 给table添加边框 border-collapse:collapse; 合并边框 } td{ border:1px solid #000; 给表格添加边框 } 2、边框边距 border-spacing 一个值：垂直和水平间距相同 两个值：第一个值表示水平间距，第二个值表示垂直间距，空格隔开。 注意：只有当border-collapse为separate时才能设置该属性 3、表格标题位置 caption-side:top,bottom; 显示规则 显示表格单元格、行、列的算法规则。 table-layout:automatic/fixed; automatic:默认值，列宽度由单元格内容决定，自动表格布局 fixed:列宽度由单元格和列的宽度来决定，固定表格布局 固定表格布局与自动表格布局的区别 1、固定表格布局 固定表格布局与自动表格布局相比，允许浏览器更快地对表格进行布局； 在固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关； 通过使用固定表格布局，用户代理在接收到第一行后就可以显示表格。 2、自动表格布局 在自动表格布局中，列的宽度是由列单元格中没有折行的最宽的内容设定的； 此算法有时会较慢，这是由于它需要在确定最终的布局之前访问表格中所有的内容。 列表样式list-style-type: ; 1、无序列表 none:无标记 disc:默认实心圆 circle:空心圆 square:实心矩形 2、有序列表 none:无标记 decimal:默认数字 lower-roman:小写罗马字 upper-roman:大写罗马字 3、列表项图 list-style-image:url(); 4、列表项位置 list-style-position:outside/inside; &lt;li&gt;前面标识的位置 5、最常用list-style:none; 取消列表前面的标志符 ol,li{margin:0;padding:0;} ol{list-style:none;} ","link":"https://h8396x.coding-pages.com/post/eahNtreYA/"},{"title":"CSS文本格式化","content":"控制字体 1、指定字体 font-family:&quot;微软雅黑&quot;,&quot;Lantinghei&quot;; font-family:&quot;Microsoft YaHei&quot;,&quot;微软雅黑&quot;; 先设置英文，在设置中文。 2、字体大小 font-size:12px; 3、字体加粗 font-weight:normal/blod/100-900; 4、字体样式 font-style:italic; 倾斜 5、小型大写字母 font-variant:small-caps; 6、行高 font:font-size/line-height; 行高 控制文本格式 1、文本颜色 color:value; 2、文字水平排列方式 text-align:left/right/center; 3、文本线条修饰 text-decoration:none/underline/overline/line-through; 下划线/上划线/删除线 4、行高 设置行间距 line-height:20px; 特殊用法：可以控制一行文本在div中垂直居中。 height:20px; line-height:20px; 5、首行文本缩进 text-indent:40px; 6、文本阴影（和box-shadow用法一致） text-shadow:h-shadow v-shadow blur color; 水平阴影位置/垂直阴影位置/模糊距离/阴影颜色 例：text-shadow:10px 20px 5px red; 文本溢出处理 1、处理空白 while-space:normal/nowrap; normal:采用浏览器默认设置（默认换行） nowrap:不换行 2、文本溢出 text-overflow:clip/ellipsis; clip:裁剪，拦腰截断 ellipsis:用...来表示未显示的内容 3、该属性必须与 overflow:hidden 和 white-space:nowrap 联用。 // 文本溢出单行显示 .single { overflow: hidden; text-overflow:ellipsis; white-space: nowrap; } 4、文本溢出多行显示 .multiple { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } ","link":"https://h8396x.coding-pages.com/post/Egj8W-XKU/"},{"title":"CSS渐变","content":"渐变 渐变通过background-image设置 linear-gradient 线性渐变 repeating-linear-gradient 重复线性渐变 radial-gradient 径向渐变 repeating-radial-gradient 重复径向渐变 示例：background-image:repeating-radial-gradient(); 线性渐变 background-image:lineae-gradient(angle,color-point1,color-point2...); 例：background-image:linear-gradient(to right,yellow 0%,green 50%,red 100%); 1、angle:指定具体方向或具体角度 to top,to bottom,to right,to left 0deg 90deg 2、color-point:渐变颜色的开始点、中间过渡点、结束点 red 0%:从开始处显示红色 green 50%：到50%位置处，变成绿色 blue 100%: 到结尾处，变为蓝色 径向渐变 默认渐变中心是center(中心点)，渐变大小是farthest-corner(表示到最远的角落)。 background-image:radial-gradient(size at position,color-point1,color-point2...); size at position: size:放射的圆形半径 position：原点所在的坐标（left，top，bottom，right，center） 重复线性渐变 background-image:repeating-linear-gradient(red,green 20px,purple 40px); 重复径向渐变 background-image:repeating-radial-gradient(red,green 20px,purple 40px); ","link":"https://h8396x.coding-pages.com/post/fvxEelEPq/"},{"title":"CSS背景","content":"背景颜色 background-color：red; background-color不能继承 background-color：transparent; 设置背景为“透明” 背景图片(常用) 背景图片可以写文字，img不可以 background-image:url(images/logo.png); 无引号 background-image:url('images/logo.png'); 单引号 background-image:url(&quot;images/logo.png&quot;图像固定); 双引号 背景重复(常用) 背景图默认水平垂直方向都平铺。 background-repeat:repeat/repeat-x/repeat-y/no-repeat; 平铺/水平平铺/垂直平铺/不平铺 改背景图片的尺寸 background-size:100px 100px; background-size:50% 50%; 特殊1、background-size:contain; 扩大背景图像,碰到第一个边缘就停止 特殊2、background-size:cover; 扩大背景图像，使背景图完全覆盖背景区域，直到碰到最后一个边缘才停止 背景图像固定 background-attachment:scroll; 默认，滚动定位 background-attachment:fixed; 固定定位 一旦设置背景图像固定，背景图就不会随着滚轮滚动。 背景定位(常用) 背景图像在区域中的哪个位置进行显示 background-position:20px 20px; background-position:left center; &lt;!-- left,center,right --&gt; x为正，向右；x为负，向左； y为正，向下；y为负，向上； 1、块级元素抠图： （1）ps量取想要扣取的小图的宽高; （2）创建一个与要显示图标width和height宽高一致的元素; （3）引入背景图，为创建好的元素设置背景图像(大背景图); （4）background-position给负值,将图片移入到指定位置，通过开发者工具将背景图调整到div中。 div{ width:22px; height:23px; border:1px solid red; background-image:url(iconlist_1.png); background-repeat:no-repeat; background-position:-146px -143px; } 2、行内元素抠图 给行内元素添加水平方向的padding，元素会出现16px的高度，可以利用行内元素的这个特点，给行内元素添加背景图！ 但需要注意的是，行内元素添加上下的padding虽然可以“撑大”元素的高度，但是高度过大，则会出现覆盖上下元素的情况 s{ padding-left:16px; background-image:url(iconlist_1.png); background-repeat:no-repeat; background-position:-127px -170px; } &lt;s&gt;&lt;/s&gt; 背景绘制区域 指定背景可以在哪些区域显示 background-clip:border-box; 默认值，背景被裁剪到边框 background-clip:padding-box; 背景显示在padding和内容区域 background-clip:center-box; 背景显示在内容区域 背景合并 background:color url() attachment position; 根据需要合并、滚动条 和固定 CSS视频day02_06背景(2)最后3分钟，图片加载技巧 注意 background:#ccc url(images4/user.png) no-repeat 5px 5px; 背景颜色(background-color)要放在背景(background)图片之前 ","link":"https://h8396x.coding-pages.com/post/TxNjyeFyS/"},{"title":"CSS框模型","content":"盒子模型(方框模型、盒子属性) 主要设置元素的： 外边距（margin） 内边距（padding） 边框（border） 宽度 高度 元素实际宽度=左外边距+左边框+左内边距+宽度+左右边距+右边框+右外边距 元素实际高度=上外边距+上边框+上内边距+宽度+下右边距+下边框下外边距 外边距(元素边框外围) 1、四个方向设置 margin:value; 一个值四个方向 margin:value(上下) value(左右); margin:value(上) value(左右) value(下); margin:value(上) value(右) value(下) value(左); 2、单方向设置 margin-left/right/top/bottom:value; 3、设置块级元素居中 margin:20px auto 2px; auto：如果块级元素左右外边距设置为auto，那么当前元素会在他外层容器中水平居中。 4、外边距合并 当两个垂直外边距相遇时，将形成一个外边距。外边距的值，以大值为主。 margin-bottom:20px; margin-top:100px; 合并后：`margin-top:100px;` 5、使用外边距遇到的问题 内外嵌套的div元素，如果设置内层div的margin-top，默认会作用于外层的div的margin-top上。而内层无效果。 解决方法： 给外层div加边框(border:1px solid;)，但还存在小问题。 给外层div加内边距。 内边距 (边框与内容之间的空间) 1、四个方向设置 padding:value; 一个值四个方向 padding:value(上下) value(左右); padding:value(上) value(左右) value(下); padding:value(上) value(右) value(下) value(左); 2、单方向设置 padding-left/right/top/bottom:value; 3、元素设置内边距padding后，会扩大整个元素区域。 解决办法： (1)添加padding后，重新设置元素宽高(不好用) (2)给元素添加box-sizing:border-box; 元素的内边距和边框不会再增加他的宽度和高度。（会向内挤文本） CSS重写/重置 在不同浏览器，HTML中标签的默认样式有一个默认属性值，渲染出来的效果不尽相同，我们在写css页面的时候，为了避免在css中重复定义它们，我们需要重置默认样式，以方便统一，从而提高开发效率。 常见：*{margin:0px;padding:0px;} 不规范，加载速度会变慢 规范：p,ul,li,ol,h1,h2,h3,{margin:0px;padding:0px;} 将遇到的有默认属性值的标签写出来。 附 margin和padding使用效果是一样的，但有区别，可通过border验证，推荐使用padding padding:20px 0; margin:20px 0; ","link":"https://h8396x.coding-pages.com/post/sWgXKHaCt/"},{"title":"CSS属性","content":"颜色 rgb颜色(red,green,blue) rgb(0,0,0)黑色 rgb(255,255,255)白色 hex十六进制颜色 #e4393c 京东红 确切的英文名 red green rgba(x,x,x,0~1)带透明度：数越小，越透明 尺寸 单位:px像素 %百分比 cm厘米 mm毫米 pt棒 em(1em等于当前字体颜色) width min-width max-width height min-height max-height 内容溢出 overflow: overflow-x: overflow-y: visible：溢出可见(默认值，内容不会修剪，会显现在元素框之外) hidden：溢出隐藏(内容会被修剪，超出内容不可见) scroll：设置滚动条(内容会被修剪，浏览器会显示滚动以便查看其余内容) auto：自动(如果被修剪，浏览器会显示滚动以便查看其余内容) 注意：块级元素允许修改宽度和高度，行内元素不能修改宽度和高度。特殊，行内快允许改变宽高。 边框 1、四边 border:style width color; 用空格隔开，可不设置其中的某些。 style:dotted(点线) solid(实线) dashed(虚线) double(双线) 2、单独指定边框属性，单边 border-style: border-width: border-color:red green pink purple; border-left-color: border-right-style: 边框倒角 border-radius:10px; border-radius:10px 20px 30px 40; border-top-left-radius:30px; 左上角 border-top-right-radius:30px; 右上角 border-bottom-left-radius:30px; 右下角 border-bottom-left-radius:30px; 左下角 圆 border-radius:50%； 倒三角： div{ width:0; height:0; border-width:50px; border-style:solid; border-color:red transparent transparent transparent; } &lt;!-- 透明 --&gt; 边框阴影 属性：box-shadow：h-shadow v-shadow blur spread color inset h-shadow 水平阴影位置 正直向右，负值向左 v-shadow 垂直阴影位置 正直向下，负值向上 blur 可选，模糊距离 spread 可选，阴影尺寸 color 可选，阴影颜色 inset 可选值，将外部阴影改为内部阴影 注意：1、值要按顺序书写 2、阴影默认黑色 3、用内阴影直接加inset 图片边框 属性：border-image将图片规定为包围div元素的边框 值：border-image-source 图片路径 border-image-slice:26; 图片边框向内移植 &lt;!-- 切割图片,不带单位 --&gt; border-image-width 图片边框宽度 border-image-outset 边框图像区域超出边框的量（向外延伸多大） border-image-repeat 边框的平铺方式（repeat：平铺；round：铺满；stretch:拉伸） 简写：border-image:url(images/xx.png) 26 repeat; 轮廓 与border值相似,但不与边框同用。 绘制于元素周围的一条线，位于边框边缘的外围，可以起到突出元素的作用。 简写：outline:width style color; 全写：outline-width outline-style outline-color 经常在获取焦点（focus或hover）时使用。 注意：outline：none；可以去掉input默认边框 ","link":"https://h8396x.coding-pages.com/post/wNOx3pH8N/"},{"title":"CSS基础","content":"什么是CSS？ CSS：Cascading Style Sheet 层叠样式表、级联样式表、样式表 1、作用 修改页面中元素的显示样式，实现内容与表现分离，提高代码的可重用性和可维护性。 2、三种引入方式 (1)内联样式 (在元素中声明，只对该元素有效) &lt;h1 style=&quot;background-color:red;&quot;&gt;&lt;/h1&gt; (2)内部样式表 样式规则由选择器和样式声明组成。(定义在head中，只对当前页面有效，可以实现代码重用) &lt;stytle&gt; p{ 选择器：当前样式规则名；哪些元素可以使用当前规则 width: 60px; 样式声明：{}，多个属性值 heidht:60px; position:absolute; } &lt;/stytle&gt; (3)外部样式表 (将样式定义在一个外部CSS文件中，在head中引入外部样式表) &lt;head&gt; rel:规定当前文件与被链接文档之间的关系。 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;url&quot;/&gt; &lt;/head&gt; CSS样式表的特征 1、继承性 子元素可以继承父元素的样式，在CSS中以text-,font-,line-开头的属性都是可以继承的。 特例1：a标签颜色不能继承（默认蓝色），必须对a标签本身进行设置。 特例2：h标签的字体大小不能修改，必须对h标签本身进行设置。 2、层叠性 层叠性是浏览器处理冲突的一个能力，一个选择器可以被重复定义，在多个不同的定义中，不同的属性可以层叠到一起，如果属性重复，以后定义的为准 div{color:red;} div{width:60px;} 层叠 div{color:red;} div{color:green;} 层叠，颜色绿色 3、优先级(很重要)：样式冲突时，按优先级使用 优先1：浏览器缺省设置(最低，浏览器默认样式) 优先2：外部样式表或内部样式表——就近原则(link和style的前后顺序) 优先3：内联样式(高于内部样式表和外部样式表) 优先4：！important可以手动调整样式属性的优先级（最高） div{color:red !important;} CSS基础选择器 1、通用选择器 匹配页面中所有的元素，定义当前网页中最基本的显示样式，如字体、大小 *{属性:值;} 2、元素选择器 更改某个元素的默认显示样式 div{属性:值;} 3、类选择器 通过标签的class属性来引用定义好的类名，可以将多个类选择器应用于同一个元素。多个类名用空格隔开，不能以数字开头。 .red{color:red;} p.red{color:red;} div.red{color:red;} .green{background-color:green;} &lt;div class=&quot;red&quot;&gt;倩女幽魂&lt;/div&gt; &lt;p class=&quot;red green&quot;&gt;张国荣&lt;p&gt; //可以给同一个标签设多个类名 4、id选择器 t通过标签的ID属性值进行引用。一个元素只能有一个ID，同一个ID只能出现一次。 `#red{color:red;}` `&lt;div id=&quot;red&quot;&gt;倩女幽魂&lt;/div&gt;` 5、选择器分组 可以选择多个元素。 div,#red,.green{属性:值;} 6、后代选择器 通过元素的位置关系来匹配到元素并用空格隔开。 div p{属性:值；} div里的所有p元素 7、子代选择器 两元素之间只能是父子关系。 选择器1&gt;选择器2 div&gt;p&gt;span{属性:值;} 8、相邻兄弟选择器 可选择紧接在另一元素后的元素，且二者有相同的父元素。 选择器1+选择器2 div+p{属性:值;} 9、属性选择器 根据元素的属性及属性值来选择元素的。 元素[属性]{属性:值;} `input[type]{属性:值;} 拥有type属性的input元素` [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 10、伪类选择器 (1)链接伪类 :link,适用于尚未访问的链接 :visited,访问过后的链接 链接伪类a标签访问状态 未被访问 a:link{color:red;} 鼠标悬停 a:visited{color:green;} 激活状态 a:hover{color:purple;} 访问后状态 a:active{color:black;} (2)动态伪类 :hover,适用于鼠标悬停在元素时 :active,元素被激活时（按下还没释放） :focus,元素获取焦点时（多数用于文本框，密码框等表单元素） (3)目标伪类 :target (4)元素状态伪类 (5)结构伪类(常用) :first-child: 选择第一个子元素 :last-child : 选择最后一个子元素 (.div:first-child)与(.div :first-child)中间有无空格结果不同 (6)伪元素选择器 ：first-line:为某个元素的第一行文字使用样式 ：first-letter:为某个元素中的文字的首字母或第一个字使用样式 div:first-letter{color:red;} ：before:在某个元素之前插入一些内容 div:before{content:&quot;小明&quot;;} ：after: 在某个元素之后插入一些内容 p:after{content:&quot;小红&quot;;} (7)否定伪类 11、交集选择器 ul li.first{} li标签里面类名为first的元素 div.first{} 权值 !important(1000) &gt; id选择器优先级(100) &gt; 类选择器优先级(10) &gt; 元素选择器优先级(1) #red .green&gt;p&gt;span 权值：100+10+1+1=112 权值相同，就近原则；权值不同，谁权值大谁优先。 对同一个元素定义样式时，以权值高的为准。 ","link":"https://h8396x.coding-pages.com/post/jBAFsQReX/"},{"title":"HTML、CSS、JS知识点","content":"HTML 篇 1、Web语义化 和 SEO html 常规标签有 html5 新增语义化标签，header,acticle,aside,section,footer,audio,radio 等。 Web语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。 SEO是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。 搜索引擎通过爬虫技术获取的页面就是由一堆html标签组成的代码,，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器做不到。 但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰。 搜索引擎才能正确识别页面中的重要内容，并予以较高的权值。 比如h1~h6这几个标签在SEO中的权值非常高，用它们作页面的标题就是一个简单的SEO优化。 2、页面渲染机制 页面渲染就是浏览器的渲染引擎将html代码根据CSS定义的规则显示在浏览器窗口中的过程。 大致工作原理如下： 1、用户输入网址，浏览器向服务器发出请求，服务器返回html文件； 2、渲染引擎开始载入html代码，并将HTML中的标签转化为DOM节点，生成DOM树； 3、如果&lt;head&gt;中引用了外部css文件，则发出css文件请求，服务器返回该文件； 4、如果&lt;head&gt;中引用了外部js文件，则发出js文件请求，服务器返回该文件后开始运行； 5、渲染引擎继续载入html中的&lt;body&gt;部分的代码，并开始解析前面返回的css文件，然后根据css选择器计算出节点的样式，创建渲染树； 6、从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标； 7、如果body中的&lt;img&gt;引用了图片资源，则立即向服务器发出请求，此时渲染引擎不会等待图片下载完毕，而是继续渲染后面的代码； 8、服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排版，因此引擎需要回过头来重新渲染这部分代码； 9、如果此时js脚本中运行了style.display=&quot;none&quot;, 布局被改变，引擎也需要重新渲染这部分代码； 10、直到&lt;/html&gt;为止，页面渲染完毕。 3、重绘和回流 回流当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。 比如img文件加载完成后就会引起回流，每个页面至少需要一次回流，就是在页面第一次加载的时候。 重绘当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。 回流必将引起重绘，而重绘不一定会引起回流。 会引起重绘和回流的操作： 1、添加、删除元素(回流+重绘) 2、隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 3、移动元素，比如改变top,left,transform的值，或者移动元素到另外一个父元素中。(重绘+回流) 4、对style的操作(对不同的属性操作，影响不一样) 5、还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘) 4、本地存储 (1)本地存储最原始的方式就是cookie cookie 是存放在本地浏览器的一段文本，数据以键值对的形式保存，可以设置过期时间。 cookie 不适合大量数据的存储，因为每请求一次页面，cookie 都会发送给服务器，这使得 cookie 速度很慢而且效率也不高。 因此cookie的大小被限制为4k左右(不同浏览器可能不同,分HOST)，如下所示： Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。 Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。 Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。 在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。 (2)html5提供了两种在客户端存储数据的新方法 localStorage 和 sessionStorage, 它们都是以key/value 的形式来存储数据， 前者是永久存储，后者的存储期限仅限于浏览器会话(session),即当浏览器窗口关闭后，sessionStorage中的数据被清除。 localStorage的存储空间大约5M左右(不同浏览器可能不同，分 HOST)，这个相当于一个5M大小的前端页面的数据库，相比于cookie可以节约带宽， 但localStorage在浏览器隐私模式下是不可读取的，当存储数据超过了localStorage的存储空间后会抛出异常。 (3)H5还提供websql和indexedDB 允许前端以关系型数据库的方式来存储本地数据，相对来说，这个功能目前应用的场景比较少，此处不作介绍。 5、浏览器缓存机制 浏览器缓存机制 是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。 Cache-Control 用于控制文件在本地缓存有效时长。 最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。 在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。 Last-Modified是标识文件在服务器上的最新更新时间。 下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。 如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。 Cache-Control 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。 Cache-Control 还有一个同功能的字段：Expires。 Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。 Expires是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。 当Expires和Cache-Control两个字段同时出现时，Cache-Control 是高优化级的。 Etag也是和 Last-Modified 一样，对文件进行标识的字段。 不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。 没有更新回包304，有更新回包200。 Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。 另外有两种特殊的情况： 手动刷新页面（F5) 浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。 强制刷新页面（Ctrl+F5) 浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。 6、History操作 用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即history对象，点击返回就出栈，跳下一页就入栈。 它提供了以下方法来操作页面的前进和后退： (1)window.history.back() 返回到上一个页面 (2)window.history.forward() 进入到下一个页面 (3)window.history.go([delta]) 跳转到指定页面 HTML5 对History Api 进行了增强，新增了两个Api和一个事件，分别是pushState、replaceState 和 onpopstate (1)pushState**是往history对象里添加一个新的历史记录，即压栈。 (2)replaceState是替换history对象中的当前历史记录。 (3)当点击浏览器后退按钮或js调用history.back都会触发onpopstate事件。 与其类似的一个事件: onhashchange，onhashchange是老API, 浏览器支持度高, 本是用来监听hash变化的, 但可被用来做客户端前进和后退事件的监听， 而onpopstate是专门用来监听浏览器前进后退的, 不仅可以支持hash, 非hash的同源url也支持。 7、HTML5离线缓存 HTML5离线缓存 又叫Application Cache，是从浏览器的缓存中分出来的一块缓存区， 如果要在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。 manifest文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： (1)CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 (2)NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 (3)FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 离线缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 8、Canvas 和 SVG Canvas 通过 Javascript 来绘制 2D 图形。Canvas 是逐像素进行渲染的。 在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。 如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。 你可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。 如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas和SVG相比: canvas更依赖于分辨率，不支持事件处理器，文本渲染能力弱，比较适合密集型游戏，其中的许多对象会被频繁绘制。 而svg则比较适用于类似谷歌地图带有大型渲染区域的应用程序。 CSS 篇 css是用来对html进行修饰的一门语言。 1、选择器 2、定位 position 相对定位(relative)、绝对定位(absolute)、固定定位(fixed)，relative和absolute在移动端用的最多。 fixed 在移动端有兼容性问题，因此不推荐使用，在移动端替代fixed的方案是 absolute+内部滚动。 3、浮动 float 如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动 清除浮动的方法： （1）在元素末尾加空元素设置clear:both （2）给父容器设置before/after来模拟一个空元素 （3）直接设置overflow:auto/hidden。 除了浮动可以实现宫格模式，行内盒子(inline-block)和table也可以。 4、盒子模型 Box 常见的盒子模型有 块级盒子(block) 和 行内盒子(inline-block)。 盒子最关键的几个属性包括margin、border、padding和content,这几个元素可以设置盒子和盒子之间的关系以及盒子和内容之间的关系。 还有一个问题是计算盒子的大小，需要注意的是，box-sizing属性的设置会影响盒子的width和height。 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 5、弹性布局 Flex Flex布局的容器是一个伸缩容器，首先容器本身会更具容器中的元素动态设置自身大小； 然后当Flex容器被应用一个大小时（width和height），将会自动调整容器中的元素适应新大小。 Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向（横向和纵向）和是否支持元素的自动换行。 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 6、过渡 Transition 、动画 Transform 7、动画 Animation Animation首先需要设置一个动画函数，然后以这个动画的方式来改变元素的css属性之的变化，动画可以被设置为永久循环演示。 和transition相比，animation设置动画效果更灵活更丰富，二者还有一个区别是： transition只能通过主动改变元素的css值才能触发动画效果，而animation一旦被应用，就开始执行动画。 8、雪碧图 sprite 对于大型站点，为了减少http请求的次数，一般会将常用的小图标排到一个大图中， 页面加载时只需请求一次网络， 然后在css中通过设置background-position来控制显示所需要的小图标。 9、字体图标 iconfont 所谓字体图标就是将常用的图标转化为字体资源存在文件中，通过在CSS中引用该字体文件，然后可以直接通过控制字体的css属性来设置图标的样式。 字体图标的好处是其不受屏幕分辨率的影响，并且可以任意修改图标的颜色。 JAVASCRIPT 篇 1、基础语法 Javascript基础语法包括：变量定义、数据类型、循环、选择、内置对象等。 数据类型有string,number,boolean,null,undefined,object等。 其中，string,number和boolean是基础类型,null和undefined是JS中的两个特殊类型,object是引用类型。 JS常用的内置对象有Date、Array、JSON,RegExp等。 一般来讲，Date和Array用的最频繁，JSON可以对对象和数组进行序列化和反序列化，还有一个作用就是实现对象的深拷贝。 RegExp即正则表达式，是处理字符串的利器。 2、函数原型链 Javascript虽然没有继承概念，但Javascript在函数Function对象中建立了原型对象prototype，并以Function对象为主线，从上至下，在内部构建了一条原型链。 简单来说就是 建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在， 如果不存在就去该对象所在的原型连上去找，直到Object对象为止，如果都没有找到该属性才会返回undefined。 利用函数的原型机制来实现JS继承。JS原型对象和原型链 3、函数作用域 函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 在JS中没有会块级作用域，只有函数作用域，因此JS中还存在着另外一种怪异现象，那就是变量提升。 4、函数指针 this this 存在于函数中，它指向的是该函数在运行时被调用的那个对象。 Function对象还提供了call、apply和bind等方法来改变函数的this指向。 其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同。 5、构造函数 new JS中的函数即可以是构造函数又可以当作普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象， 于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。 6、闭包 闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量， 可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。 干货分享：让你分分钟学会JS闭包 7、单线程和异步队列 setTimeout和setInterval是JS内置的两个定时器，使用很简单，但这两个方法背后的原理却不简单。 JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)， 主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。 但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响， JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定， 只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。 这就是为什么setTimeout(fn,0) 始终要等到最后执行的原因。 8、异步通讯 Ajax技术 Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest,通过该对象可以创建一个Ajax请求。 为了防止XSS攻击，浏览器对Ajax做了限制，不允许Ajax跨域请求服务器,就是只能访问当前域名下的url。 当然，如果确信你的站点不存在跨域的风险，可以在服务端主动开启跨域请求。 也可以直接通过CORS或JSONP来实现。 JSONP是利用脚本(script)跨域能力来模拟Ajax请求。 CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 9、DOM对象 document document对象里保存着整个web页面dom结构，在页面上所有的元素最终都会映射为一个dom对象。 document也提供了很多api来查找特定的dom对象，比如getElementById,querySelector等等。 10、事件系统 Event 事件是用户与页面交互的基础，到目前为止，DOM事件从PC端的 鼠标事件(mouse) 发展到移动端的 触摸事件(touch) 和 手势事件(guesture) 由于DOM结构可能会多层嵌套，因此也衍生出了两种事件流：事件捕获和事件冒泡，后者最常用。利用事件冒泡机制可以实现很多功能，比如页面点击统计。 除此之外，在页面初始化、滚动、隐藏、返回等操作时分别内置了onload/onDOMContentLoaded、onscroll、onvisibility和onhashchange等事件， 如果想要捕获这些事件，需要通过addEventLisener/attachEvent来进行绑定。 11、全局对象 window 在JS中，当一段JS代码在浏览器中被加载执行，JS引擎会在内存中构建一个全局执行环境，执行环境的作用是保证所有的函数能按照正确的顺序被执行， 而window对象则是这个执行环境中的一个全局对象，window对象中内置了很多操作api和对象，document对象就是其中一个。 ","link":"https://h8396x.coding-pages.com/post/wwVrymkVj/"},{"title":"HTML基础-3","content":"结构标记 1、作用 增强标签的语义性。HTML5出来之前，我们用div来表示页面章节，但是这些div都没有实际意义。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分，适合做容器。 2、语义标签优点 更容易被搜索引擎收录； 更容易让屏幕阅读器读出网页内容； 能够更好的体现页面的主题； 兼容性更好，支持更多的网络设备。 3、H5新增语义标签 header(头部) nav(只是导航+列表) section(小结，内容具体部分) article(文章) footer(底部信息) aside(侧边栏) 旧：`&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;` 新：`&lt;header class=&quot;&quot;&gt;&lt;/header&gt;` 可以嵌套多次使用。也可以与div相互嵌套使用。 表单 1、作用 用于搜集不同类型的用户输入,用户提交表单时向服务器传输数据，从而实现用户与Web服务器的交互。 &lt;form&gt; &lt;!-- 表单元素 --&gt; &lt;/form&gt; 2、表单属性 name:表单的名称，如果未写name，服务器无法获得表单内容。 action：提交表单时，向何处发送表单数据； method：定义浏览器将表单中的数据提交给服务器的方式，默认get; 当表单中有用户信息时，将get改为post。 enctype:规定在发送到服务器之前应该如何对表单数据进行编码。 默认：application/x-www-form-urlencoded 如有文件上传：multipart/form-data 注意 name： 属性是和服务器通信时使用的名称； class： 用于CSS中 id： 属性是浏览器端使用的名称，主要是为了方便客户端编程而在css和JavaScript中使用的。 表单元素（在表单中与用户进行交互的控件） 1、input:文本框、密码框 &lt;input type=&quot;text&quot;/&gt; 文本框 &lt;input type=&quot;password&quot;&gt; 密码框 &lt;input type=&quot;radio&quot;/&gt; 单选按钮 分组name,初始值value要写 checked=&quot;checked&quot;默认 &lt;input type=&quot;checkbox&quot;&gt; 复选框 分组name,初始值value要写 checked=&quot;checked&quot;默认 &lt;input type=&quot;submit&quot;&gt; 提交按钮 无name ，写初始值 &lt;input type=&quot;reset&quot;&gt; 重置按钮 &lt;input type=&quot;button&quot;&gt; 普通按钮 &lt;input type=&quot;file&quot;&gt; 文件选择框 如有文件上传：enctype=&quot;multipart/form-data&quot; &lt;input type=&quot;hidden&quot;&gt; 隐藏域 通常用于向服务器提交不需要显示给用户的信息，用户看不到。 type:默认文本框，写什么显示什么； name:表单的名称； value:显示在控件上的初始值； maxlength:用户输入的最大字符长度； id:唯一标识； readonly:只读属性，用户不能改变控件中的value； disabled：禁用，控件会显示灰色背景，用户不能改变文本框和密码框的值。并且在提交表单时，浏览器不会将该文本框和密码框的值发送给服务器。 2、readonly与disabled的区别 readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素都有效，但是表单元素在使用了disabled后，当我们将表单提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去。 3、关联文本与表单元素文本 &lt;label&gt; 标签为 input 元素定义标签。label 元素不会向用户呈现任何特殊的样式。 不过，它为鼠标用户改善了可用性，因为如果用户点击label元素内的文本，则会切换到控件本身。 &lt;label&gt; 标签的for属性应该等于相关元素的id元素，以便将它们捆绑起来。 两种使用方法： &lt;label for=&quot;username&quot;&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt;&lt;/label&gt;建议第一种 &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt; 4、textarea:多文本输入框 属性：name cols:规定文本区可见宽度 rows：规定文本区可见行数 默认用户可更改大小,禁止：style=&quot;resize:none&quot; 5、select和option：下拉框 &lt;select name=&quot;city&quot; size=&quot;3&quot;&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;dl&quot;&gt;大连&lt;/option&gt; &lt;/select&gt; select属性：name size(大于1，从下拉列表变为滚动列表) multiple(设置多选) option属性：value selected(预选中) 表单元素——其他元素 1、浮动框架 &lt;iframe&gt;&lt;/iframe&gt; 属性：src width height frameborder(0,不带边框;1,带边框) 2、摘要与细节 将一部分内容进行展示与收缩 &lt;details&gt; &lt;summary&gt;标题&lt;/summary&gt; 显示的内容 &lt;/details&gt; 3、度量元素 &lt;meter&gt;&lt;/meter&gt; 属性：min(最小值，默认0) max(最大值，默认1) value(当前值，默认0) 4、分组元素 &lt;fieldset&gt; &lt;legend&gt;组标题&lt;/legend&gt; 内容 &lt;/fieldest&gt; 5、高亮文本显示(标记) &lt;mark&gt;&lt;/mark&gt; 五、浮动框架（iframe） 在一个浏览器中同时显示多个页面文档 &lt;iframe&gt;&lt;/iframe&gt; 属性: 1、src : 引入的网页路径(url) 2、 width : 宽度 3、 height : 高度 4、 frameborder : 边框(取值0或1) ","link":"https://h8396x.coding-pages.com/post/c5bulMJZp/"},{"title":"HTML基础-2","content":"什么是URL URL（Uniform Resource Locator）：统一资源定位器，路径 URL作用：用来标识网络中的资源位置 URL形式：绝对路径（完整地URL，很少用），相对路径 相对路径 同级目录（直接找）logo.png 子集目录（先进入）images/logo.png 父级目录（先返回）../../images/logo.png 返回上一级 图像格式 jpg、jpeg 采用有损压缩，压缩较大； gif 有损压缩，有较大失真，支持动画和透明图像； png 无损压缩，支持透明色，色彩丰富。 注意：前端切图通常保存成PNG-24 图像标签img src:图像路径（必备） alt：图像不显示时，显示的文本（必备） alt=&quot;山水画&quot; title：鼠标移入时显示的文本 width height 链接a标签 1、属性 href：链接的目的 target：指定打开新网页的方式 - _self：在当前页面打开（默认），打开的页面会覆盖当前页面。 - _blank：在新标签页中打开，不会覆盖原有页面。 name：定义锚点名称。 2、在所有浏览器中，链接的默认外观 未被访问带下划线蓝色； 已被访问带下划线紫色； 活动链接带下划线红色。 3、链接的表现形式 1. 页面间的跳转 `&lt;a href=&quot;页面路径&quot;&gt; 文本或图像 &lt;/a&gt;` 2. 页面上资源的下载 `&lt;a href=&quot;xxx.rar&quot;&gt; 点击下载 &lt;/a&gt;` 3. 返回页面顶部的空链接 `&lt;a href=&quot;#&quot;&gt;返回顶部&lt;/a&gt;` 4. 电子邮件链接，打开本机邮件客户端，向指定地址发送email邮件(如未安装邮件客户端,则没有效果)`&lt;a href=&quot;mailto:xxx@qq.com&quot;&gt;联系我们&lt;/a&gt;` 5. 链接到JavaScript单双引号嵌套`&lt;a href=&quot;javascript:window.alert('我是一个对话框')&quot;&gt;&lt;/a&gt;` 4、链接锚点 锚点：在页面的任意位置处定义一个标识，随时随地都可以跳转到这个标识上 定义锚点：&lt;a name=&quot;anchorName&quot;&gt;&lt;/a&gt; 标签内部不需要放内容 链接到本页面 &lt;a href=&quot;#anchorName&quot;&gt;文本或图像&lt;/a&gt; &lt;a name=&quot;anchorName&quot;&gt;文本或图像&lt;/a&gt; 链接到其他页面 &lt;a href=&quot;url#otherName&quot;&gt;&lt;/a&gt; &lt;a name=&quot;otherName&quot;&gt;文本或图像&lt;/a&gt; 表格 &lt;table&gt; &lt;!-- 创建表格 --&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;!-- 一行 --&gt; &lt;td&gt;&lt;/td&gt; &lt;!-- 两列 --&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 1、table的属性 width height bgcolor align(left right center) border:边框，px像素 cellpadding:内边距（单元格边框与内容之间的距离） cellspacing:外边距（单元格与单元格之间的距离） 2、tr的属性 align(left center right):设置该行内容的水平对齐方式 valign(top middle bottom):设置该行内容的垂直对齐方式 3、td的属性 align valign width height colspan:单元格跨列（向右合并单元格） rowspan:单元格跨行（向下合并单元格） 4、表格的复杂应用 根据行的不同，划分成不同的组；表格的嵌套 表头&lt;thead&gt; 表主题&lt;tbody&gt; 表尾&lt;tfoot&gt; 表头标题&lt;th&gt;&lt;/th&gt; 列表（从上到下，成列；从左到右，成行） 1、有序列表 单独成行，做导航用 &lt;ol type=&quot;A&quot; start=&quot;2&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; type列表类型：数字(默认) 小写字母 大写字母 小写罗马数字 大写罗马数字 start起始编号：一定是数字 2、无序列表 &lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; type列表类型：disc(实心圆，默认) circle(空心圆) square(实心矩形) 3、自定义列表 用于给出一类事物的解释，如名词解释。做图文混排布局。 &lt;dl&gt; &lt;dt&gt;列表内容标题&lt;/dt&gt; &lt;!-- dt和dd不是嵌套，是并列关系 --&gt; &lt;dd&gt;列表数据&lt;/dd&gt; &lt;/dl&gt; 4、列表的嵌套 ","link":"https://h8396x.coding-pages.com/post/2voORPa2i/"},{"title":"HTML基础-1","content":"万维网 前端是指页面的表现形式，浏览器负责解释html页面 万维网联盟 WWW 元素属性（元素的最完整表现） HTML文档结构 &lt;!doctype html&gt; 文档声明 &lt;html&gt; 根元素 &lt;head&gt; 头部 &lt;meta charset=&quot;UTF-8&quot;&gt; 声明元数据 &lt;title&gt;1111&lt;/title&gt; 网页标题 &lt;/head&gt; &lt;body&gt; 主体 内容 &lt;/body&gt; &lt;/html&gt; &lt;!doctype html&gt;作用 文档声明，让Web浏览器知道是使用哪个版本的HTML来解释HTML页面。 块级元素和行内元素 1、块级元素： div h1~h6 hr p... table ol...li... 默认情况下独占一行，元素前后会自动换行； 块级元素作用：布局 2、行内元素： span b s i u... 默认情况下多个元素位于同一行，不会换行； 行内元素作用：修改内部内容的样式 W3C万维网联盟 World Wide Web Consortium,简称W3C，又称W3C理事会。 W3C是Web技术领域最具权威和影响力的国际中立性技术标准机构，发布Web技术标准及实施指南。 国外主流浏览器 Google chrome浏览器，Firefox浏览器，IE浏览器，Opera浏览器，Safari浏览器 封闭标签和非封闭标签 1、封闭标签 标题元素h1~h6 超链接a （`href=&quot;http://www.baidu.com&quot;`） 段落元素p 做布局div （前三个都可以使用align属性） 文本元素加粗b 下划线u 斜体i 删除s和del 下标sub 上标sup 修改内部样式span 预格式化pre 2、非封闭标签 转义字符（&amp;nbsp; &lt; &amp;lt; &gt; &amp;gt;） 换行br 水平线hr（size、width、color、align） 图片&lt;img/&gt; meta标签作用 1. 向搜索引擎说明你的网页关键词 `&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;` 2. 告诉搜索引擎你的站点的主要内容 `&lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt;` 3. 文件或链接检索 `&lt;meta name=&quot;robots&quot; content=&quot;all|none|index|noindex|follow|nofollow&quot;/&gt;` all:文件将被检索，且页面上的链接可以被查询 index：文件将被检索 follow：页面上的链接可以被查询 none:文件将不被检索，且页面上的链接不可以被查询； noindex:文件将不被检索，但页面上的链接可以被查询； nofollow：文件将被检索，但页面上的链接不可以被查询。 4. 移动端经常使用此标签 `&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;/&gt;` 5. 定时让网页在指定的时间n内，跳转到指定页面 `&lt;meta http-equiv=&quot;refresh&quot; content=&quot;n;url=http://yourlink&quot;/&gt;` 6. Edge:始终以最新的文档模式来渲染页面 `&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge&quot;/&gt;` 元素嵌套（标签嵌套） 块级元素可以嵌套块级元素与行内元素 P标签虽然是块级元素，但只能嵌套行内元素 行内元素不能嵌套块级元素 ","link":"https://h8396x.coding-pages.com/post/LJH6qtm_H/"},{"title":"浏览器兼容问题","content":"浏览器 几种常见的浏览器：IE、Firefox、Safari、Chrome及Opera（壳浏览器） 浏览器大战：网景浏览器 VS IE浏览器 浏览器主要组件 用户界面 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分 浏览器引擎 用来查询及操作渲染引擎的接口 渲染引擎 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 网络 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 UI后端 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS解释器 用来解释执行JS代码 数据存储 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 浏览器的内核 浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。 负责对网页语法的解释（如HTML）并渲染（显示）网页。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。 不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。 不同浏览器的内核 IE: trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 什么是css Hack 由于不同厂商的浏览器，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。 haslayout 是IE渲染引擎的一个内部组成部分。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。 为了调节这两个不同的概念，渲染引擎采用了 hasLayout 的属性。 大多IE下的显示错误，就是源于 haslayout。如果它设置成了true，它就不得不去渲染它自己，因此元素不得不扩展去包含它的流出的内容。 例如浮动或者很长很长的没有截断的单词，如果haslayout没有被设置成true，那么元素得依靠某个祖先元素来渲染它。这就是很多的ie bugs诞生的地方。 当网页在 IE 中有异常表现时（IE6,7），可以尝试激发 haslayout 来看看是不是问题所在。常用的方法是给某元素 css 设定 zoom:1。 使用 zoom:1 是因为大多数情况下，它能在不影响现有环境的条件下激发元素的 haslayout。而一旦问题消失，那基本上就可以判断是haslayout 的原因。 然后就可以通过设定相应的 css 属性来对这个问题进行修正了。建议首先要考虑的是设定元素的width/height 属性，其次再考虑其他属性。 IE 常见的兼容问题 1、<!DOCTYPE HTML>文档类型的声明。 产生条件：IE6浏览器，当我们没有书写这个文档声明的时候，会触发IE6浏览器的怪异解析现象； 解决办法：书写文档声明。 2、不同浏览器当中，很多的标签的默认样式不同，如默认的外部丁内补丁。 产生条件：不同浏览器； 解决办法：利用CSS reset文件进行样式的清除，然后再根据需要进行设置。 3、横向双倍外边距 产生条件：在IE6中块元素浮动后，会出现横向双倍margin现象。 解决办法： 在float标签的样式控制中加入display：inline 4、默认行高 产生条件：IE6、IE7、遨游浏览器；设置的文字高度超出盒模型内容区域设置的高度时会影响布局。 解决办法：给超出高度的标签设置overflow：hidden；或者将文字的行高line-height设置为小于块的高度。 5、img外部的border 产生条件：img外部有a标签，即img标签有链接时 解决办法：设置img边框border:0; 6、图片默认有间距。 产生条件：img标签（每个img之后敲了回车） 解决办法：为img设置float的浮动布局方式。 7、经典3像素bug 产生条件：IE6浏览器，浮动块元素与未浮动块元素处于同一行，有默认的3px间距。 解决办法：设置非浮动元素浮动。 8、默认行高 产生条件：清除浮动的时候，有些人会采取一种清浮动的方法，使用一个空的div，然后为这个div设置{clear：both}。在大部分浏览器当中，这样做是没有任何问题的，但是在IE6浏览器当中，div即使是空的，也会存在默认行高。 解决办法：设置其高度为0，并设置overflow:hidden。{height:0;overflow:hidden;clear:both;} 9、a标签hover不适用于所有标签 产生条件：IE6浏览器中hover只支持a标签的使用，不支持一切其它标签使用； 解决办法：合理用a标签嵌套其他行内标签或者用javascript模拟a的hover效果 10、table标签当中border-color属性设置无效 产生条件：IE6中table设置属性border-color无效； 解决办法：运用CSS样式进行控制，而不是使用属性进行样式的处理。 11、png格式图片 产生条件：IE6浏览器，不支持透明； 解决办法：使用javascript进行处理；或者使用gif、jpg图像替代掉png图片的使用。 12、透明rgba与opacity 产生条件：IE6不支持此两种透明的设置方法； 解决办法：使用IE6当中的滤镜filter替代掉，如：opacity:0.6;filter:alpha(opacity=60)。 13、子选择器在IE6中不能使用 产生条件：IE6浏览器，使用E&gt;F子选择器； 解决办法：采用其他选择器或者采用后代选择器进行控制，如：div p{margin:10px;} 替代掉 div&gt;p{margin:10px;}。 14、不支持最大最小宽高 产生条件：IE6浏览器，标签的最低高度/宽度设置（min/max-height） 解决办法：为IE6单独设置hack，即_height:最小高度值；_width：最小宽度值（对于IE6，当实际宽高超出定义的宽高时，元素会自动调整宽高）。对于最大高度和最大宽度，没有必要设置兼容，当前对于开发者来说，只需要保证IE6下正常显示即可，无需在它身上花费太多功夫。 15、纵向居中，IE6不支持display:table-cell 产生条件：IE6浏览器，设置一个元素在另一个元素中垂直方向上居中对齐，不能够支持以单元格的方式来显示元素； 解决办法：如果是单行文本，采用line-height和height的配合使得文本垂直居中，如果中间是其他元素或者多行文本，采用其他方法进行居中处理 16、input 聚焦框颜色与样式不同 产生条件：各个浏览器表现不同； 处理方法：使用outline:none，清除默认样式之后再统一设置。 17、鼠标移上小手效果 产生条件：IE6，cursor:hand ：IE完全支持。但是在firefox是不支持的，没有效果。 解决办法：设置两种cursor:pointer; cursor:hand。 18、子标签无法撑开父标签的高度 产生条件：父标签内部含一个或多个子标签，父标签没有设置浮动，而子标签发生浮动； 处理方法： 方法1：在子标签最后添加清除浮动的设置&lt;div style='height:0;clear:both'&gt;&lt;/div&gt;; 方法2：为父标签添加{overflow:hidden;}的样式； 方法3：为父标签设置固定高度。 19、li的间距问题 产生条件：IE6浏览器 li标签设置宽高，且li里面的元素发生了浮动； 处理方法： 方法1：li不设置宽高； 方法2：li内部的标签不进行浮动。 20、行内元素布局混乱 产生条件：行内元素为包含框时，如果包含框包含的绝对定位元素以百分比为单位进行定位； 处理方法：在行内元素当中加入{zoom:1}，触发IE的hasLayout。 21、多显示一个字 产生条件：多个浮动元素中间夹杂HTML注释语句，浮动元素宽度设置为100%；则在下一行多显示一个上一行的最后一个字符； 处理方法：果断删掉注释！ 22、CSS优先级 ！important 产生条件：IE6当中，在同一组CSS属性中，!important不起作用； 处理方法：单独设置。 23、img图片下部高度多余5px 产生条件：IE6浏览器； 处理方法：父级设置overflow: hidden; 或 img { display: block; } 或 _margin: -5px; 24、高度不要为单数 父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免 25、position下的left，bottom错位 解决方法：为父级(relative层)设置宽高或添加zoom:1 26、在 IE6 下定位元素的父级宽高都为奇数时，那么在 IE6 下定位元素的 right和bottom都有1像素的偏差。 解决办法：设为偶数。 27、在ie67下，li本身没浮动，但是li的内容有浮动，li下边就会产生一个间隙。 解决办法：给li设置 float:left或者给li加vertical-align:top。 28、在IE6下高度小于19px的元素，高度会被当做19px来处理。 解决办法：设置font-size：0;或者overflow:hidden; 29、在IE6，7下输入类型的表单控件上下各有1px的间隙。 解决办法：给input加浮动。 30、在IE6，7下输入类型的表单控件加border:none无效。 解决办法：重置input的背景。background:#fff; 31、IE6 100% 高度 在IE6下，如果要给元素定义100%高度，必须要明确定义它的父级元素的高度，如果你需要给元素定义满屏的高度，就得先给html和body定义height:100%;。 32、IE6躲猫猫bug 在IE6和IE7下，躲猫猫bug是一个非常恼人的问题。一个撑破了容器的浮动元素，如果在他之后有不浮动的内容，并且有一些定义了:hover的链接，当鼠标移到那些链接上时，在IE6下就会触发躲猫猫。 解决方法： 1.在（那个未浮动的）内容之后添加一个&lt;span style=&quot;clear: both;&quot;&gt;&lt;/span&gt; 2.触发包含了这些链接的容器的hasLayout，一个简单的方法就是给其定义height:1%; 33、IE下z-index的bug 在IE浏览器中，定位元素的z-index层级是相对于各自的父级容器，所以会导致z-index出现错误的表现。解决方法是给其父级元素定义z-index，有些情况下还需要定义position:relative。 除以上常见的兼容问题，剩余的小细节（差几个像素）通过前缀法调节 1、IE 其他的兼容问题 如果你的页面对IE7兼容没有问题又不想大量修改现有代码，同时又能在IE8中正常使用，只需在head中添加 &lt;meta http-equiv=”x-ua-compatible” content=”ie=7”/&gt; 2、额外介绍： 这是一个，文档兼容模式的定义。 Edge 模式告诉 IE 以最高级模式渲染文档，也就是任何 IE 版本都以当前版本所支持的最高级标准模式渲染，避免版本升级造成的影响。简单的说，就是什么版本 IE 就用什么版本的标准模式渲染 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 使用以下代码强制 IE 使用 Chrome Frame 渲染 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot;&gt; 提示 IE 用户安装 Google Frame Google 官方提供了对 Google Frame 插件安装情况的检测，这里直接调用方法即可，如果检测到 IE 并未安装 Google Frame，则弹出对话框提示安装。 &lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt;CFInstall.check();&lt;/script&gt; 最佳的兼容模式方案，结合考虑以上两种： &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 3、常用的css hack方法 1、条件注释法 在head和body里面注释 2、属性前缀法 3、选择器前缀法：针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。 目前最常见的是 *html *前缀只对IE6生效 *+html *+前缀只对IE7生效 @media screen\\9{...}只对IE6/7生效 @media \\0screen {body { background: red; }}只对IE8有效 @media \\0screen\\,screen\\9{body { background: blue; }}只对IE6/7/8有效 @media screen\\0 {body { background: green; }} 只对IE8/9/10有效 ","link":"https://h8396x.coding-pages.com/post/AfxqpbVyz/"},{"title":"PS基础","content":"前端必备PS技能 量图 切图，拼合图片（CSS精灵） 对图片的处理：去水印 注意：编辑前先将背景变为普通图层 前端常用PS快捷键 Ctrl+n 新建 前端用透明色 Alt+delete 前景色 Ctrl+delete 背景色 Alt 复制 Ctrl+Alt+z 一直返回上一步 Ctrl+d 取消选区 Alt+鼠标滚轮 Ctrl+“+”：放大 Ctrl+“-”：缩小 Ctrl+t 自由变换 (右拉覆盖右侧文字) Ctrl+o 快捷回到全屏 空格移动图片 点击图片——鼠标右键——扭曲 菜单栏和工具栏 顶部菜单栏： 1、文本——存储为Web所用模式 2、编辑——首选项——单位与标尺——改成像素 3、图像——模式——RGB模式 4、视图——标尺 5、视图——显示——网格 （最后清除参考线） 左侧工具栏 1、矩形选框工具，量图形像素； 2、先给羽化值在画图形； 3、新选区，到选区去，从选区减去，与选区交叉； 4、不同的图形画在不同的图层； 5、新建组、图层、删除图层 自动选择 小眼睛(隐藏) 套索工具 1、将打开的图片背景图层的小锁打开才能编辑； 2、套索——抠图，空格可移动图片（不常用）；用多边形抠图 3、shift，等比变幻；Ctrl+t，变换 4、保存——存储——文件名最好改英文——通常为png(透明),jpg,gif格式 魔棒工具 1、用于选择同一种颜色，容差； 2、不能删除魔棒选择区域，因为图片小锁未打开； 切图 1、切图边缘部分 2、切图完成后——存储为Web格式——左下角缩小到6%——全部框选——保存为PNG-24格式 存储——英文名，仅显示图像，所有用户切片 3、将小图标拼合在一起——存储——png格式(小图标不拼合，会影响加载速度) 按Ctrl键，重新选择上，然后修改。 图章———仿制图章工具 Alt+鼠标左键 Shift+鼠标左键 其他 FireWork切图：导出所选插片（保存为 仅图片，雪碧图，CSS和图像......） DreamWave: 生成复杂表格 或 验证是否符合W3C标准。 SVG图标iconmoon：在各个网站不会模糊 PS插件CSSPs：获取CSS样式 图像 ——&gt; 智能对象 ——&gt; 拖拽过程中会清晰 ","link":"https://h8396x.coding-pages.com/post/qly7rA7jC/"}]}